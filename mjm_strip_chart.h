#ifndef MJM_STRIP_CHART_H__
#define MJM_STRIP_CHART_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_tokenized_points.h"
#include "mjm_colors_2023.h"


//#include "mjm_block_matrix.h"
#include "mjm_instruments.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_worm_blob.h"
#include "mjm_collections.h"
//#include "mjm_tokenized_collections.h"
#include "mjm_string_tokenizer.h"
#include "mjm_canned_methods.h"

#include "mjm_pawnoff.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_generic_iterators.h"



#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


/*
<one line to give the program's name and a brief idea of what it does.>


Conceived and written by Mike Marchywka from 2024 to present.
See dates in individual code pieces as they were 
generated from my wizards. 
Copyright (C) <year> <name of author>


This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
@software{,
  author = {Michael J Marchywka},
  city = {Jasper GA 30143 USA},
  title = {},
abstract={},
institution={},
license={Knowledge sir should be free to all },
publisher={Mike Marchywka},
email={marchywka@hotmail.com},
authorid={orcid.org/0000-0001-9237-455X},
  filename={mjm_strip_chart.h},
  url = {},
  version = {0.0.0},
  date-started={2024-04-05},
}
*/

// Fri 05 Apr 2024 08:00:08 PM EDT
// generated by /home/documents/cpp/scripts/cpputil -operand -classhdr mjm_strip_chart   
// QUICKCOMPILE  g++  -MMD -MF mjm_strip_chart.deps  -Wall -Wno-misleading-indentation  -std=gnu++11 -DTEST_MJM_STRIP_CHART -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_strip_chart.h  -o mjm_strip_chart.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_strip_chart("mjm_strip_chart" , "  ");

template <class Tr>
class mjm_strip_chart 
{
 typedef mjm_strip_chart Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

// TYPEDEF 
enum { BAD=~0};
//typedef mjm_canned_methods Canned;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map<StrTy, Ragged> RaggedMap;
typedef std::vector<StrTy> Words;
typedef mjm_string_base_params<Tr> BaseParams;
typedef string_tokenizer Tokenizer;
typedef string_tokenizer St;






typedef mjm_tokenized_points<Tr>  TokPoints;
typedef typename TokPoints::PointEntry PointEntry;
typedef mjm_vector_shapes<Tr> Shapes;
typedef typename Shapes::shape_t Shape;
typedef typename Shapes::point_t Point;

typedef std::map<IdxTy, TokPoints> ChartMap;
 
typedef mjm_colors_2023<Tr> ColorTable;
class _chart_info  
{

public:
_chart_info() {Init_chart_info(); } 
~_chart_info() {Free_chart_info(); } 

_chart_info(const Line & l,  const IdxTy first ) { Init_chart_info(l,first); }
_chart_info(const StrTy & s,  const IdxTy flags ) { Init_chart_info(s,flags); }
_chart_info(const Ragged & r, const IdxTy first,const IdxTy i0, const IdxTy flags ) 
{Init_chart_info(r,first,i0,flags); } 

//_chart_info(const _chart_info & that ) { *this=that ; }  
//bool operator<(const _chart_info & that) const { return false;}
//bool operator==(const _chart_info & that) const { return false;}
//bool operator>(const _chart_info & that) const { return false;}
//_chart_info & operator++() const { return *this;}
//_chart_info & operator+=(const _chart_info & that ) { return *this;}
//_chart_info & operator=(const _chart_info & that ) { return *this;}
bool blank() const { return m_r+m_g+m_b==0; }
const D & r() const { return m_r; } 
const D & g() const { return m_g; } 
const D & b() const { return m_b; } 
IdxTy color(const StrTy &v)
{
static ColorTable ct;
const auto x=ct.color(v); 
m_r=D(x.r())/255.0;
m_g=D(x.g())/255.0;
m_b=D(x.b())/255.0;
MM_ERR(MMPR3(m_r,m_g,m_b))
return 0;
} // color
void color( const D & r, const D & g, const D & b) 
{ m_r=r; m_g=g; m_b=b; }
void color(const IdxTy n) 
{
const IdxTy idx=n&7;
switch ( idx)
{
case 0: { m_r=1; m_g=1; m_b=1; break; }
case 1: { m_r=1; m_g=1; m_b=0; break; }
case 2: { m_r=1; m_g=0; m_b=1; break; }
case 3: { m_r=0; m_g=1; m_b=1; break; }
case 4: { m_r=1; m_g=0; m_b=0; break; }
case 5: { m_r=0; m_g=1; m_b=0; break; }
case 6: { m_r=0; m_g=0; m_b=1; break; }
case 7: { m_r=1; m_g=.5; m_b=.5; break; }
//default:
} // idx

} // color
StrTy save( const IdxTy flags=0) const { return Save_chart_info(flags); } 
StrTy dump( const IdxTy flags=0) const { return Dump_chart_info(flags); } 
private:
void Init_chart_info(const StrTy & s,  const IdxTy flags ) 
{ Init_chart_info(); 
BaseParams kvp(s);

}
void Init_chart_info(const Line & l,  const IdxTy first ) 
{ 
Init_chart_info();
const IdxTy len=l.size();
for(IdxTy i=first; i<len; ++i)
{


} // i 

} // Init_chart_info

void Init_chart_info(const Ragged & r, const IdxTy first,const IdxTy i0,const IdxTy flags ) 
{
Init_chart_info();
const IdxTy sz=r.size();
for(IdxTy i=i0; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();

} // i 

} // Init_chart_info

StrTy Save_chart_info( const IdxTy flags=0) const  
{
StrTy s;
//BaseParams kvp();
BaseParams kvp;
//kcp,encode(s,"",);
return s; 
} // Dump 



StrTy Dump_chart_info( const IdxTy flags=0) const  
{
Ss ss;
// ss<<MMPR4(); 
 ss<<MMPR3(m_r,m_g,m_b); 
return ss.str(); 
} // Dump 


void Free_chart_info()
{

} // Free_chart_info

void Init_chart_info()
{
m_r=1;
m_g=1;
m_b=1;
} // Init_chart_info

// _chart_infoMEMBERS
D m_r,m_g,m_b;
 
}; // _chart_info

typedef _chart_info Info;

typedef std::map<IdxTy, Info> InfoMap;
typedef std::map<StrTy,StrTy> Parameters;



// API

public:
mjm_strip_chart() {Init(); }
mjm_strip_chart(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
mjm_strip_chart(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}
const IdxTy size() const { return m_size; } 
void clear() { Clear(); } 
void load(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
void load(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}
template <class ModelInfo, class ViewInfo, class DrawInfo>
IdxTy draw_points(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{
return DrawPoints(m,v,sdp); 
}
const D & xmin() const { return m_x0; } 
const D & xmax() const { return m_x1; } 
const D & ymin() const { return m_y0; } 
const D & ymax() const { return m_y1; } 



void append(const Ragged & r, const IdxTy flags) { Append(r,flags); } 
template <class Tm> void append(const Ragged & r, Tm & mi, const IdxTy flags) { Append(r,mi,flags); } 
void append(const Myt & that, const IdxTy flags) { Append(that,flags); } 
void save(const StrTy & fn,const StrTy &s) {Save(fn,s); }

void set_color(const IdxTy idx, const D & r, const D & g, const D & b,const IdxTy flags)
{ SetColor(idx, r, g,b, flags); } 
~mjm_strip_chart() {}

mjm_strip_chart(const mjm_strip_chart & that ) { *this=that ; }  

void load_xny(const Ragged & r, const StrTy & sin, const IdxTy flags)
{ LoadXNY(r,sin,flags); } 

//bool operator<(const mjm_strip_chart & that) const { return false;}
//bool operator==(const mjm_strip_chart & that) const { return false;}
//bool operator>(const mjm_strip_chart & that) const { return false;}
//mjm_strip_chart & operator++() const { return *this;}
//mjm_strip_chart & operator+=(const mjm_strip_chart & that ) { return *this;}
//mjm_strip_chart & operator=(const mjm_strip_chart & that ) { return *this;}

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
StrTy show(const IdxTy flags=0)const  { return Show(flags); }
private:

void SetColor(const IdxTy idx, const D & r, const D & g, const D & b,const IdxTy flags)
{
// the key is a tokenized string this is dumb... 
auto ii=m_map.find(idx);
if (ii==m_map.end()) 
{
MM_ERR(" index not found "<<MMPR2(idx,m_map.size()))
return;
} // ii==end 
MM_LOOP(jj,(*ii).second)
{
PointEntry& pi=(*jj);
pi.color(r,g,b); 

} // ii 
} // SetColor


template <class ModelInfo, class ViewInfo, class DrawInfo>
IdxTy DrawPoints(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{
const int style=v.style();
const bool as_points=Bit(style,0);
//MM_ERR(" drawing ornate ")
glPointSize(4.0);
glLineWidth(4.0);
//double xraw=0;
MM_LOOP(jj,m_map)
{
if (as_points) glBegin(GL_POINTS);
else glBegin(GL_LINE_STRIP);

auto& p=(*jj).second; // m.m_ornate_points;
//MM_ERR(MMPR(p.size()))
IdxTy oldgroup=BAD;
MM_LOOP(ii,p)
{
//MM_ERR(" point ")
// this is a tokenized_point
const PointEntry& pi=(*ii);
const IdxTy group=pi.group();
const IdxTy pflags=pi.flags();
if (pflags){ MM_ERR(MMPR3(pflags,group,oldgroup)) }
if (group!=oldgroup)
{
glEnd();
if (as_points) glBegin(GL_POINTS);
else glBegin(GL_LINE_STRIP);
} // group 
glColor3f(pi.r(),pi.g(),pi.b() );//
// these need to be translated internally.
const StrTy & shape=p(pi.shape());
Shape * pshape=(Shape*)pi.shapep();
// can have a retrace blanking problem in line mode 
v.doglutpos(glVertex3f,pi.x(),pi.y(),pi.z());
if (pshape==NULL)
{
//MM_ERR(" no pshapep")
//continue;
} // null 
//MM_ERR(MMPR4(shape,pi.x(),pi.y(),pshape))
//MM_ERR(MMPR(pi.dump()))
//DrawOrnateShape(pi,pshape,v,sdp);
if (false) v.draw_ornate_shape(pi,pshape,sdp);
oldgroup=group;
} // ii 
glEnd();
} // jj 

return 0;
} // DrawPoints


int myatoi(const StrTy & s )const   { return mjm_canned_methods::myatoi(s.c_str()); }
int myatoi(const char * c) const  { return mjm_canned_methods::myatoi(c); }
static bool Bit(const IdxTy f, const IdxTy b) { return  ((f>>b)&1)!=0; }
// should loop over map now 
static void Set(IdxTy& f, const IdxTy b,const bool x) //const  
    { if (x) f|=(1<<b); else f&=((~1)<<b); }
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


void Save(const StrTy & fn,const StrTy &s) {
// std::ofstream ofs(fn);

 } // Save
void Append(const Ragged & r, const IdxTy flags) { m_params.clear();  LoadXNY(r,"",flags); } 
template <class Tm> 
void Append(const Ragged & r, Tm & mi, const IdxTy flags) { 
m_params=mi.params();
m_etc=mi.etc();
Ss ss; MM_LOOP(ii,m_params) { ss<<MMPR2((*ii).first,(*ii).second); } 
ss<<" etc ";
 MM_LOOP(ii,m_etc) { ss<<MMPR2((*ii).first,(*ii).second); } 
MM_ERR(MMPR3(m_etc.size(),m_params.size(),ss.str()))
LoadXNY(r,"",flags); 
} 
// these all have different m_st values doh... 
// ASFCK now this is called fcking later fk
void Append(const Myt & that, const IdxTy flags)
{
m_params.clear();
// needs to sort out groups... 
MM_LOOP(ii,that.m_map)
{
const IdxTy oldkey=(*ii).first;
const StrTy nm=that.m_st(oldkey);
// will want to chnage color... 
auto  old=(*ii).second;
const IdxTy chart=m_st(nm);
// want to update colors if default but no idea...
const auto ff=that.m_info.find(oldkey);
// better exist ... 
const auto & oldinfo=(*ff).second; // that.m_info[oldkey];

auto & tnew=m_map[chart];
if (m_info.find(chart)==m_info.end())
{ m_info[chart].color(chart); } 
const auto & ci=m_info[chart];

// f-es up color.. 
//tnew+=old;
MM_LOOP(jj,old)
{
//auto
tnew.load((*jj).x(),(*jj).y(),(*jj).z(),ci.r(),ci.g(),ci.b(),0);
} // jj 
//tnew.next_group();

} // ii 

//m_groups+=that.m_groups;
}  // Append 

void LoadXNY(const Ragged & r, const StrTy & sin, const IdxTy flags)
{ 
//LoadXNY(r,sin,flags); 
// load single points into named chart,
const IdxTy sz=r.size();
const IdxTy start=0;
D red=1;
D g=1;
D b=1;
IdxTy oldchart=BAD;
TokPoints * pp=NULL;
Info * pi=NULL;
std::map<IdxTy,IdxTy> hits;
//auto ii=m_params.find("color");
//bool have_color=(ii!=m_params.end());
auto ii=m_etc.find("color");
bool have_color=(ii!=m_etc.end());


Info def;
bool rainbow=false;
if (have_color)
{
const StrTy & colspec=(*ii).second;
if (colspec!="rainbow") def.color(colspec);
else rainbow=true;
MM_ERR("have color "<< MMPR3(sin,colspec,def.dump()))

}
for(IdxTy i=start; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();
if (len==0)  continue;
if (l[0].c_str()[0]=='#') continue;
if (len!=3) { MM_ERR(" ignoring line "<<MMPR2(i,l[0])) continue; }
// FIXME this is incredibly slow per-point need a differnet format...
const IdxTy chart=m_st(l[1]);
const D x=atof(l[0].c_str());
const D y=atof(l[2].c_str());
if (chart!=oldchart)
{
if (m_info.find(chart)==m_info.end()) { m_info[chart].color(chart); } 
pi=&(m_info[chart]);
pp=&(m_map[chart]);
++hits[chart];
oldchart=chart;
if (hits[chart]==1) (*pp).next_group(); 
MM_ERR(MMPR2((*pp).groups(),(*pp).size()))
}
if (rainbow) def.color((*pp).groups());
//MM_ERR(MMPR2((*pp).groups(),def.dump()))
const auto & ci=have_color?def:(*pi); // m_info[chart];
//MM_ERR(MMPR2(have_color,ci.dump()))
//m_map[chart].load(x,y,0,ci.r(),ci.g(),ci.b(),0);
(*pp).load(x,y,0,ci.r(),ci.g(),ci.b(),0);

Bounds(x,y);
++m_size;
}  // i 




}  // LoadXNY
void Bounds( const D& x, const D & y)
{
if (m_size==0) { m_x0=x; m_x1=x; m_y0=y; m_y1=y; return; } 
if (x>m_x1) m_x1=x; if (x<m_x0) m_x0=x;
if (y>m_y1) m_y1=y; if (y<m_y0) m_y0=y;

} // Bounds 

void Init(const Ragged & r, const IdxTy start=0, const IdxTy first=0, const IdxTy flags=0  )
{
Init();
const IdxTy sz=r.size();
for(IdxTy i=start; i<sz; ++i)
{
//const Line & l=r[i];
//const IdxTy len=l.size();


}  // i 

} // Init 
void Init(const StrTy  & sin,const IdxTy flags =0  )
{
Init();
BaseParams kvp(sin);
} // Init 

void Init()
{
m_size=0;
m_x0=0;
m_x1=0;
m_y0=0;
m_y1=0;
//m_groups=0;
} // Init

StrTy Show(const IdxTy flags=0)const {Ss ss;  
ss<<MMPR4(m_size,m_x0,m_x1,m_y0)<<MMPR(m_y1);
ss<<CRLF;
MM_LOOP(ii,m_map) { const IdxTy tok=(*ii).first; const StrTy nm=m_st(tok);   ss<<MMPR2(tok,nm)<<" ";  }
//ss<<",";
ss<<CRLF;
MM_LOOP(ii,m_info) { const IdxTy tok=(*ii).first; const StrTy nm=m_st(tok);   ss<<MMPR2(tok,nm)<<" ";  }

return ss.str(); }
void Clear()
{
MM_LOOP(ii,m_map) { (*ii).second.clear(); }  // TokPoints
Init();
} // Cleap 

// MEMBERS
St m_st;
ChartMap m_map;
InfoMap m_info;
IdxTy m_size;
//IdxTy m_groups;
D m_x0,m_x1,m_y0,m_y1;
Parameters m_params,m_etc;
}; // mjm_strip_chart

//////////////////////////////////////////////

template <class Tr>
class mjm_strip_chart_map : public std::map<typename Tr::StrTy, mjm_strip_chart< Tr > >  
{
 typedef mjm_strip_chart_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_strip_chart< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_strip_chart_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{


}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_strip_chart_map




////////////////////////////////////////////
#ifdef  TEST_MJM_STRIP_CHART
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_strip_chart <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_STRIP_CHART "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_MSG(ss.str())

}
typedef mjm_ragged_table Ragged;
int main(int argc,char **args)
{
about();
typedef mjm_strip_chart<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="loadragged") {
 	const IdxTy start=atoi(cip.wif(2).c_str()); 
	const IdxTy first=atoi(cip.wif(3).c_str()); 
	const IdxTy flags=atoi(cip.wif(4).c_str()); 
Ragged r; r.load(cip.p1); x.load(r,start,first,flags); }
if (cmd=="load") {x.load(cip.p1,atoi(cip.p2.c_str())); }
if (cmd=="save") {x.save(cip.p1,cip.p2); }
if (cmd=="quit") break;
// NB this does not work in gneral when errors are disabled
//if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="dump") { auto wtf=x.dump();  MM_ERR(wtf) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_STRIP_CHART_H__ 
