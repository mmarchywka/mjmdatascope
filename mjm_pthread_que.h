#ifndef MJM_PTHREAD_QUE_H__
#define MJM_PTHREAD_QUE_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include <map> 
#include <vector> 
#include <queue> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Mon Mar 20 04:18:04 EDT 2023
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_pthread_que   
// g++  -Wall -std=gnu++11 -DTEST_MJM_PTHREAD_QUE -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_pthread_que.h  -o mjm_pthread_que.out -lpthread -lreadline
// https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html#SYNCHRONIZATION
mjm_global_credits::credit __credit__mjm_pthread_que("mjm_pthread_que"
, "  ");

template <class Tr, class Td >
class mjm_pthread_que 
{
 typedef mjm_pthread_que Myt;
typedef Td DataType;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

enum { MAP_MU=0 , MU_SZ=3, COUNT_MUX=0, COND_MUX=1};
typedef pthread_mutex_t MutexTy;
typedef pthread_cond_t CondTy;
typedef std::queue<DataType*> Que;
public:
mjm_pthread_que() {Init();}
~mjm_pthread_que() {}
void limit(const IdxTy n) 
{
EnterSerial(COUNT_MUX);
m_limit_size=n;
ExitSerial(COUNT_MUX);
} // limit
IdxTy size() const
{
EnterSerial(COUNT_MUX);
IdxTy sz=m_que.size();
ExitSerial(COUNT_MUX);
return sz;
} // size
void clear()
{
EnterSerial(COUNT_MUX);
//m_que.clear();
while (!m_que.empty()) { Dispose(); } 
MM_ERR(MMPR2(__FUNCTION__,m_dropped ))
ExitSerial(COUNT_MUX);
}
void done()
{
EnterSerial(COUNT_MUX);
m_done=true;
ExitSerial(COUNT_MUX);
Wake();
}
// code may terminate when que is empty before object
// is sent so defer pulling from queue ... 
DataType * next(const bool peek_only=false)
{
DataType * p=0;
EnterSerial(COUNT_MUX);
while (!m_done&&m_que.empty())
{
ExitSerial(COUNT_MUX);
// TODO FIXME  should take a object and function ptr or similar... 
m_wait.wait();
EnterSerial(COUNT_MUX);
if (m_done) break;
} // while
if (!m_done) if (!m_que.empty()) { p=m_que.front(); if (!peek_only) m_que.pop();  }
ExitSerial(COUNT_MUX);

return p;
} // next 
void pop()
{
EnterSerial(COUNT_MUX);
if (!m_done) if (!m_que.empty()) { m_que.pop();  }

ExitSerial(COUNT_MUX);
} // pop 



bool full()  const 
{
EnterSerial(COUNT_MUX);
 const bool x  =(m_que.size()>=m_limit_size) ; 
ExitSerial(COUNT_MUX);
return x; 
}// full

bool empty()  const 
{
EnterSerial(COUNT_MUX);
 const bool x  =(m_que.size()==0) ; 
ExitSerial(COUNT_MUX);
return x; 
}// full


bool push(DataType * p )
{
bool rc=true;
EnterSerial(COUNT_MUX);
if (m_limit_size!=0){ 
IdxTy dr=m_dropped;
 while (m_que.size()>m_limit_size) Dispose(); 
if (false) {IdxTy mask=(-1)<<4;
if (dr!=m_dropped) 
	if ((m_dropped&mask)-(dr&mask)) 
		//MM_ERR(" queue overflow "<<MMPR3((-int(mask)),(m_dropped&mask),(dr&mask))<<MMPR3(dr,m_dropped,(m_dropped-dr)))
		MM_ERR(" queue overflow "<<MMPR3(dr,m_dropped,(m_dropped-dr)))
}

} 
if (!m_done) m_que.push(p);
rc=!m_done;
ExitSerial(COUNT_MUX);
Wake();
return rc;
} // push 
// call with lock 
void Dispose() { ++ m_dropped; delete m_que.front();  m_que.pop(); } 
void wake() { Wake(); }
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
void Wake()
{
m_wait.notify();
} // Wake 
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss; 
EnterSerial(COUNT_MUX);
 ss<<MMPR4(m_done,m_limit_size,m_dropped,size());
ExitSerial(COUNT_MUX);
  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;
typedef typename mjm_thread_util<Tr>::wait_notify Waiter;

void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
void Init()
{
//m_count_mutex     = PTHREAD_MUTEX_INITIALIZER;
//m_condition_mutex = PTHREAD_MUTEX_INITIALIZER;
//m_condition_cond  = PTHREAD_COND_INITIALIZER;
m_mutex_vector = MutexVector(MU_SZ);
// my class does this already.. 
//MM_LOOP(ii,m_mutex_vector){ (*ii)=PTHREAD_MUTEX_INITIALIZER; } 
m_done=false; 
m_limit_size=0;
m_dropped=0;
} // Init


// MEMBERS

//MutexTy count_mutex, ondition_mutex;
//CondTy  m_condition_cond;
mutable MutexVector m_mutex_vector;
Waiter m_wait;
Que m_que;
bool m_done;
IdxTy m_limit_size,m_dropped;
}; // mjm_pthread_que

//////////////////////////////////////////////

template <class Tr,class Td>
class mjm_pthread_que_map : public std::map<typename Tr::StrTy, mjm_pthread_que< Tr,Td > >  
{
 typedef mjm_pthread_que_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_pthread_que< Tr, Td > >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_pthread_que_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_pthread_que_map




////////////////////////////////////////////
#ifdef  TEST_MJM_PTHREAD_QUE
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_pthread_que <Tr,char>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_PTHREAD_QUE "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_pthread_que<Tr,char>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_PTHREAD_QUE_H__ 
