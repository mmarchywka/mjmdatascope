 //  cpputil rename on Sat Sep 6 09:17:44 AM EDT 2025 from _point_entry to mjm_dscope_point
 //  cpputil rename on Sat Sep 6 09:17:16 AM EDT 2025 from mjm_tokenized_points to mjm_dscope_point
#ifndef MJM_DSCOPE_POINT_H__
#define MJM_DSCOPE_POINT_H__

#include "mjm_globals.h"
#include "mjm_vector_shapes.h"
#include "mjm_thread_util.h"
#include "mjm_string_tokenizer.h"
#include "mjm_bounds.h"
//#include "mjm_block_matrix.h"
#include "mjm_instruments.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_worm_blob.h"
#include "mjm_collections.h"
//#include "mjm_tokenized_collections.h"
#include "mjm_canned_methods.h"

#include "mjm_pawnoff.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_generic_iterators.h"



#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


/*
<one line to give the program's name and a brief idea of what it does.>


Conceived and written by Mike Marchywka from 2023 to present.
See dates in individual code pieces as they were 
generated from my wizards. 
Copyright (C) <year> <name of author>


This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
@software{,
  author = {Michael J Marchywka},
  city = {Jasper GA 30143 USA},
  title = {},
abstract={},
institution={},
license={Knowledge sir should be free to all },
publisher={Mike Marchywka},
email={marchywka@hotmail.com},
authorid={orcid.org/0000-0001-9237-455X},
  filename={mjm_dscope_point.h},
  url = {},
  version = {0.0.0},
  date-started={2023-12-18},
}
*/

// Mon 18 Dec 2023 05:58:26 PM EST
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_dscope_point   
// QUICKCOMPILE  g++  -Wall -Wno-misleading-indentation  -std=gnu++11 -DTEST_MJM_DSCOPE_POINT -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_dscope_point.h  -o mjm_dscope_point.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_dscope_point("mjm_dscope_point" , "  ");

template <class Tr>
 class mjm_dscope_point  
{
 typedef mjm_dscope_point  Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;


// TYPEDEF 

typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map<StrTy, Ragged> RaggedMap;
typedef std::vector<StrTy> Words;
typedef mjm_string_base_params<Tr> BaseParams;
typedef string_tokenizer Tokenizer;
typedef string_tokenizer St;
typedef mjm_bounds<Tr> Bounds;
typedef mjm_vector_shapes<Tr> Shapes;
//typedef mjm_canned_methods Canned;

enum { BAD=~0};
// API
public:
mjm_dscope_point() {Initmjm_dscope_point(); } 
~mjm_dscope_point() {Freemjm_dscope_point(); } 

mjm_dscope_point(const Line & l,  const IdxTy first ) { Initmjm_dscope_point(l,first); }
mjm_dscope_point(const StrTy & s,  const IdxTy flags ) { Initmjm_dscope_point(s,flags); }
mjm_dscope_point(const Ragged & r, const IdxTy first,const IdxTy i0, St & st, const IdxTy flags ) 
{Initmjm_dscope_point(r,first,i0,st, flags); } 
mjm_dscope_point( const D &x, const D &y, const D &z, const IdxTy flags)  
{
Initmjm_dscope_point();  
m_x=x; m_y=y; m_z=z;
m_shapep=0;
} 
mjm_dscope_point( const D &x, const D &y, const D &z, 
 const D &r, const D &g, const D &b, 
const IdxTy flags=0)  
{
Initmjm_dscope_point();  
m_x=x; m_y=y; m_z=z; m_r=r; m_g=g; m_b=b;
m_shapep=0;
} 
// really should use containers for this but may become
// much more granular hard to know how... 
IdxTy flags() const { return m_flags; }
IdxTy flags(const IdxTy n)  {m_flags=n;  return m_flags; }
IdxTy group() const { return m_group; }
IdxTy group(const IdxTy n)  {m_group=n;  return m_group; }


StrTy save( const IdxTy flags=0) const { return Savemjm_dscope_point(flags); } 
StrTy dump( const IdxTy flags=0) const { return Dumpmjm_dscope_point(flags); } 
// arghhhhh
void color( const D & r, const D & g, const D  & b)
{ m_r=r; m_g=g; m_b=b; } 
const D r() const { return m_r;}
const D g() const { return m_g;}
const D b() const { return m_b;}
const D x() const { return m_x;}
const D y() const { return m_y;}
const D z() const { return m_z;}
const D size() const { return m_size;}
void size(const D & x)  {  m_size=x;}
bool valid() const { return m_shapep!=this; } 
const IdxTy color() const { return m_color; }
const IdxTy shape() const { return m_shape; }
void * shapep() const { return m_shapep; }
void shapep(void * p)  {  m_shapep=p; }
private:
int myatoi(const StrTy & s )const   { return mjm_canned_methods::myatoi(s.c_str()); }
int myatoi(const char * c) const  { return mjm_canned_methods::myatoi(c); }
static int myatoix(const char * c)   { return mjm_canned_methods::myatoix(c); }
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
void Initmjm_dscope_point(const StrTy & s,  const IdxTy flags ) 
{ Initmjm_dscope_point(); 
BaseParams kvp(s);

}
void Initmjm_dscope_point(const Line & l,  const IdxTy first ) 
{ 
Initmjm_dscope_point();
const IdxTy len=l.size();
for(IdxTy i=first; i<len; ++i)
{


} // i 

} // Initmjm_dscope_point
//PointEntry
//PointEntry p(r,i,0,m_st,0);
void Initmjm_dscope_point(const Ragged & r, const IdxTy first,const IdxTy i0,St & st, const IdxTy flags ) 
{
Initmjm_dscope_point();
const IdxTy sz=r.size();
IdxTy j=i0;
for(IdxTy i=first; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();
//MM_ERR(MMPR2(len,(i0+6)));
if (len<(i0+6)) return; 
//const IdxTy top=len-1-i0;
//switch (top) { default: } // len 
m_x=atof(l[j].c_str()); ++j;
m_y=atof(l[j].c_str()); ++j;
m_z=atof(l[j].c_str()); ++j;
m_size=atof(l[j].c_str()); ++j;
//m_color=st(l[j]); ++j;
m_color=myatoix(l[j].c_str()); ++j;
m_ri=(m_color>>16)&255;
m_gi=(m_color>>8)&255;
m_bi=(m_color>>0)&255;
m_r=D(m_ri)/255.0;
m_g=D(m_gi)/255.0;
m_b=D(m_bi)/255.0;

m_shape=st(l[j]); ++j;
m_shapep=0; 
//MM_ERR(MMPR(dump()))
break; // only do one iteration   
} // i 

} // Initmjm_dscope_point

StrTy Savemjm_dscope_point( const IdxTy flags=0) const  
{
StrTy s;
//BaseParams kvp();
BaseParams kvp;
//kcp,encode(s,"",);
return s; 
} // Dump 



StrTy Dumpmjm_dscope_point( const IdxTy flags=0) const  
{
Ss ss;
 ss<<MMPR4(m_x,m_y,m_z,m_size); 
 ss<<MMPR4(m_color,m_shape,m_ri,m_gi); 
 ss<<MMPR4(m_bi,m_r,m_g,m_b); 
 ss<<MMPR2(m_shapep,this); 
return ss.str(); 
} // Dump 


void Freemjm_dscope_point()
{

} // Freemjm_dscope_point

void Initmjm_dscope_point()
{
m_x=0;
m_y=0;
m_z=0;
m_size=1;
m_color=0;
m_shape=0;
// should kill copy ctor etc lol 
m_shapep=this; // invalud lol 
m_ri=0; m_gi=0; m_bi=0; m_b=0; m_g=0; m_r=0; 
m_flags=0;
m_group=0;
} // Initmjm_dscope_point

// mjm_dscope_pointMEMBERS

D m_x,m_y,m_z;
D m_size;
IdxTy m_color , m_shape;
void * m_shapep;
// moved to shape 
IdxTy m_ri,m_gi,m_bi;
D m_r,m_g,m_b;
IdxTy m_flags,m_group;
}; // mjm_dscope_point




#endif // MJM_DSCOPE_POINT_H__ 
