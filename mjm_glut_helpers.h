#ifndef MJM_GLUT_HELPERS_H__
#define MJM_GLUT_HELPERS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_glut_graticule.h"
#include "mjm_strip_chart.h"
#include "mjm_tokenized_points.h"
#include "mjm_svg_render.h"

#include "mjm_glut_decorations.h"
#include "mjm_glut_molecule.h"


// TODO FIXME should use template move this crap out 
#include "mjm_hot_zones.h"


#include "mjm_collections.h"

#include "mjm_strings.h"
#include "mjm_string_kvp.h"


#include <freeglut.h>

#include "mjm_glut_elements.h"
#include "mjm_dscope_heatmap.h"
#include "mjm_worm_blob.h"
#include "mjm_block_matrix.h"

#include "mjm_ff_mesh.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Fri Mar 24 04:11:15 EDT 2023
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_glut_helpers   
// g++  -Wall -std=gnu++11 -DTEST_MJM_GLUT_HELPERS -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_glut_helpers.h  -o mjm_glut_helpers.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_glut_helpers("mjm_glut_helpers"
, "  ");

template <class Tr>
class mjm_glut_helpers 
{
 typedef mjm_glut_helpers Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
// traits? 
enum {BAD=~0};


typedef mjm_string_base_params<Tr> BaseParams;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line; 
typedef mjm_worm_blob<Tr,D> WORMBlob;
typedef mjm_glut_elements<Tr> Elements;
typedef  typename Elements::Element Element ;

typedef mjm_strip_chart<Tr> strip_t;

typedef mjm_glut_decorations<Tr> decorations_t;
typedef mjm_glut_molecule<Tr> mole_t; 



typedef mjm_glut_graticule<Tr> graticule_t;

typedef GLfloat Gf ;


typedef std::map<StrTy,Elements> Scenes;

// accumlate hot zones with actions etc. 
typedef mjm_hot_zones<Tr>  HotZones;


class _draw_info
{

public:
typedef HotZones hot_type;
_draw_info() { Init(); }
// i or n in a chrono sequence 
void hist_index(const IdxTy n) {m_hist=n;  } 
IdxTy hist_index()const  {return m_hist;  } 
void hist_size(const IdxTy n) {m_hist_cnt=n;  } 
IdxTy hist_size()const  {return m_hist_cnt;  } 
// total number of actives 
void actives(const IdxTy n) { m_act_cnt=n; } 
IdxTy actives()const  {return  m_act_cnt; } 
// this one
void active(const IdxTy n) { m_act=n; } 
IdxTy active()const  {return m_act; } 
void Init()
{m_act_cnt=0;
m_act=0;

}
hot_type m_hz;
IdxTy m_act_cnt,m_act;
IdxTy m_hist_cnt,m_hist;

}; // _draw_info
class _key_info
{

}; // _key_info

class _ptr_info
{

}; // _ptr_info



class _view
{
public:
typedef Gf G;
typedef std::vector<G> Vec;

#include "mjm__inner__triple.h"
typedef _triple GeoState;
typedef mjm_block_matrix<Gf> Matrix;

class _action
{

public:
GeoState tgt;
Matrix mat,imat,in;
D xzed,yzed;
IdxTy action;
}; // _action

typedef _action action_t;
public:

typedef GeoState triple_t;
_view() {Init(); }
int style() const { return m_style;}
void style(const int s) { m_style=s; } 
void reset() { Init(); } 
void reset_geometry() { InitGeometry(); } 
void reset(const StrTy & s ) { Init(s); } 
StrTy encode(const IdxTy flags=0) { return Encode(flags);}
const IdxTy vidx() const { return m_vidx; }
void  vidx(int d )  { int x=m_vidx+d; if (x<0) x=0; m_vidx=x;  }
void mov(const D dx, const D dy,const D dz)
{
m_tgt.move(dx,dy,dz);
//m_c[0]+=dx; m_c[1]+=dy; m_c[2]+=dz;

}
// change scale and move camera along line
// between m_tgt and m_pov.
void zoom(const D & f, const IdxTy flags)
{
//MM_ERR(" zoom empty "<<MMPR2(f,flags))
// need to keep the camera back not sure how "field of view"
// is done with projection? 
//_triple dir=(m_tgt-m_pov)*f;
//m_pov=m_tgt-dir;
m_scale.scale(f);

auto & m=m_mat;
//m.diag(1);
MM_ILOOP(i,3) {m(i,0)*=f; }
MM_ILOOP(i,3) {m(i,1)*=f; }
MM_ILOOP(i,3) {m(i,2)*=f; }
m_imat=m.invert3x3();

}

template <class Ty> void contain(const Ty & bb)
{ contain(bb.xmin(),bb.xmax(),bb.ymin(),bb.ymax()); }
void contain(const D & xmin, const D & xmax, const D & ymin, const D & ymax)
{
MM_ERR(MMPR4(xmin,xmax,ymin,ymax))
// want to center...
const D dx=xmax-xmin;
const D dy=ymax-ymin;
m_tgt[0]=xmin+.5*dx;
m_tgt[1]=ymin+.5*dy;
m_tgt[2]=0;
m_mat.zero();
m_mat(0,0)=1; if (dx>0 ) m_mat(0,0)=1.0/(dx);
m_mat(1,1)=1; if (dy>0 ) m_mat(1,1)=1.0/(dy);
m_mat(2,2)=1;
 m_imat=m_mat.invert3x3();

} // contain 
void unscale(const IdxTy flags)
{
const bool invert=Bit(flags,0);
auto & m=m_mat;
//m.diag(1);
MM_ILOOP(i,3) {m(i,0)/=m_scale[0]; }
MM_ILOOP(i,3) {m(i,1)/=m_scale[1]; }
MM_ILOOP(i,3) {m(i,2)/=m_scale[2]; }
if (invert) {  m_imat=m.invert3x3(); }

} // unscale

void scale_factor(const D & fx, const D & fy, const D & fz, const IdxTy flags )
{

const bool absolute=Bit(flags,0);
if (absolute)
{
unscale(0);
m_scale[0]=fx;
m_scale[1]=fy;
m_scale[2]=fz;
}
else
{
m_scale[0]*=fx;
m_scale[1]*=fy;
m_scale[2]*=fz;
}

auto & m=m_mat;
//m.diag(1);
MM_ILOOP(i,3) {m(i,0)*=fx; }
MM_ILOOP(i,3) {m(i,1)*=fy; }
MM_ILOOP(i,3) {m(i,2)*=fz; }
// need to do this only when needed.. 
m_imat=m.invert3x3();

MM_ERR(MMPR(m_mat.dump()))

} // scale_factor

template <class PointEntry , class Shape, class DrawInfo >
IdxTy draw_ornate_shape(const PointEntry & pi,Shape * pshape,  DrawInfo * sdp)
{
if (pshape==0)
{
glColor3f(pi.r(),pi.g(),pi.b() );//
glColor3f(255.0,1.0,1.0 );//
glPointSize(1.0);
glBegin(GL_POINTS);
//MM_ERR(MMPR3(pi.x(),pi.y(),pi.z()))
doglutpos(glVertex3f,pi.x(),pi.y(),pi.z());
glEnd();
return 0;
} // null 
Shape & s=*pshape;
// size and place ok... 
// maybe output vectors or something? 
// FIXME the bastard coords- both glut and view have xforms, make this
// confusing. Need to pick one but too time consuming for now. 
//glTranslatef(); 
//glColor3f();//
// TODO use the color in shape this is dumb 
glColor3f(pi.r(),pi.g(),pi.b() );//
if (s.filled())  glBegin(GL_POLYGON);
else  glBegin(GL_LINE_LOOP);
// this has to be a translated shape or else translated... 
MM_LOOP(ii,s)
{
//v.doglutpos(glVertex3f,pi);
//v.doglutpos(glVertex3f,(*ii).triple(pi.x(),pi.y(),pi.z(),pi.size()));
doglutpos(glVertex3f,(*ii).triple(pi.x(),pi.y(),pi.z(),pi.size()));
} // ii 

glEnd();


return 0;
} // DrawOrnateShape





void svg_zoom()
{
//v.svg_zoom();
//float zf=v.distance;
//glRasterPos2f(v.m_c[0],v.m_c[1]);
//glPixelZoom(1,-zf);


} 
// these are floats
void pan(const D & x,const D& y,const D & z)
{
slew(x,y,0,0); 
//m_tgt.move(x,y,z);

}
//void slew(x,y,gls.m_last_x,gls.m_last_y);
// this is in mouse pixels and should be int  
// as the glut crap is fixed the unproject crap can be unincluded
// TODO FIXME 
void slew(const D&  x,const D& y,const D& last_x,const D & last_y)
{
D xw=x,yw=y,zw=0;
D xwl=last_x,ywl=last_y,zwl=0;
unproject( xw,yw,zw,x,y);
//MM_ERR(MMPR4(x,y,xw,yw)<<MMPR(zw))
unproject( xwl,ywl,zwl,last_x,last_y);
//MM_ERR(MMPR4(gls.m_last_x,gls.m_last_y,xwl,ywl)<<MMPR(zwl))
const D fu=-1.0; // / distance;
const D dx=(xw-xwl)*fu;
const D dy=-(yw-ywl)*fu;
Matrix in=Matrix(3,1);
in[0]=dx; in[1]=dy; in[2]=0;
Matrix out=m_imat*in;
// MM_ERR(MMPR(out.dump()))
m_tgt[0]+=out[0];
m_tgt[1]+=out[1];
m_tgt[2]+=out[2];


} // slew 

// tilt the z-axis on screen towards direction dy/dx
// by amount related to r

static void assign(_triple & x, const Matrix & y)
{  MM_ILOOP(i,3){  x[i]=y[i]; }  }  
static void assign(Matrix& x, const _triple & y)
{ x= Matrix(3,1); MM_ILOOP(i,3){  x[i]=y[i]; }  }  
static void pluseq(Matrix& x, const _triple & y)
{  MM_ILOOP(i,3){  x[i]+=y[i]; }  }  
static void minuseq(Matrix& x, const _triple & y)
{  MM_ILOOP(i,3){  x[i]-=y[i]; }  }  



// doh, this needs the location of the button down
// and maintain the origin during roatation not change
// on each move ... doh 
// note too that this requires backing out the origin or saving
// it somwere... 
// the axis of evil needs to be defined at the initail click and
//mainttained as the mosue moes. 
void tilt(const D & x,const D & _xl, const D & y, const D & _yl,const IdxTy evct)
{
D xw,yw,zw;
D xwl,ywl,zwl;
Matrix in;
if (m_action==evct)
{
in=m_act.in;
}
else
{
m_action=evct;
m_act.xzed=_xl;
m_act.yzed=_yl;
m_act.mat=m_mat;
m_act.imat=m_imat;
m_act.tgt=m_tgt;

unproject( xw,yw,zw,x,y);
unproject( xwl,ywl,zwl,_xl,_yl);
if (m_squash!=0) { zw=zw/m_squash; zwl=zwl/m_squash; }
in=Matrix(3,1); in[0]=xw; in[1]=yw; in[2]=zw;
m_act.in=in;

} 
D xl=m_act.xzed;
D yl=m_act.yzed;

//MM_ERR(MMPR4(x,y,xw,yw)<<MMPR(zw))
// find the origin point fo rthe tilr
const D dp=atan2(-y+yl,x-xl);
const D dt=M_PI*.001*sqrt((x-xl)*(x-xl)+(y-yl)*(y-yl));
MM_ERR(MMPR4(x,y,dp,dt))
const D ct=cos(dt);
const D cp=cos(dp);
const D sp=sin(dp);
const D st=sin(dt);
Matrix B=Matrix(3,3);
B.rotation(0,1,dp);
Matrix C=Matrix(3,3);
C.rotation(0,2,dt);
Matrix R=C*B;
// then this needs to unrotate the xy plane... doh 
B.rotation(0,1,-dp);
R=B*R;
// this is the rotation origin
//in=m_imat*in;
//pluseq(in,m_tgt); 
//in[0]+=m_tgt[0]; in[1]+=m_tgt[1]; in[2]+=m_tgt[2];
#if 0 
Matrix R=Matrix(3,3);
R.zero();
R(0,0)=ct*cp;
R(0,2)=st*cp;
R(0,1)=st*sp;
R(1,1)=ct*dp;
R(1,2)=st*sp;
R(1,0)=st*cp;

R(2,0)=st*cp;
R(2,1)=st*sp;
R(2,2)=ct;
#endif
// but this is around the unproected origin,
// m_tgt is a triple, should make mat operator lol. 
//Matrix dtgt=m_mat*(in- R*in); //  - A*R*m_tgt;
Matrix Ri=R.invert3x3();
Matrix dtgt=m_act.imat*in - Ri*m_act.imat*in;


MM_ERR(MMPR3(in.dump(),dtgt.dump(),R.dump())<<MMPR2(m_mat.dump(),m_tgt.dump()))

//in[0]=m_tgt[0]; in[1]=m_tgt[1]; in[2]=m_tgt[2];
//drgr=dtgt-A*in
// pre-multiply and fix offsets
m_tgt[0]=m_act.tgt[0]-dtgt[0];
m_tgt[2]=m_act.tgt[1]-dtgt[1];
m_tgt[2]=m_act.tgt[2]-dtgt[2];
// this is dumb it has to operate on xformed coords... 
//m_mat=m_mat*R;
m_mat=R*m_act.mat;
m_imat=m_mat.invert3x3();
Matrix aia=m_mat*m_imat;
MM_ERR(MMPR(aia.dump()))


} // tilt


// rotate in plane of screen only dp matters now... 
// kind of dumb 
void rot(const D &  dt, const D & dp)
{

const D ct=1; // cos(dt);
const D st=1; // sin(dt);
const D cp=cos(dp);
const D sp=sin(dp);

// so now need some "thing" to rotate around screen z
// ( phi ) and tilt screen z ( theta ).
// x' = B*A(x-t)
// where B is the two rotation things. 
Matrix B=Matrix(3,3);
B(0,0)=ct*cp;
B(0,1)=ct*sp;
B(0,2)=0;
B(1,0)=-ct*sp;
B(1,1)=ct*cp;
B(1,2)=0;
B(2,0)=0; // -ct*sp;
B(2,1)=0; // ct*cp;
B(2,2)=1;
m_mat=B*m_mat;
m_imat=m_mat.invert3x3();


}

template < class Tf, class Tp> void doglutpos(Tf * f, const Tp & p)
{
Gf fukx=p.x();   Gf fuky=p.y();   Gf fukz=p.z();  
inplacepos(fukx,fuky,fukz);
(*f)(fukx,fuky,fukz);//r
} // doglutpos
template < class Tf, class Tp> void doglutpos(Tf * f, const Tp & x, const Tp & y, const Tp & z)
{
Gf fukx=x;   Gf fuky=y; Gf fukz=z;  
inplacepos(fukx,fuky,fukz);
//glVertex3f(fukx,fuky,fukz);//upper-right corner
(*f)(fukx,fuky,fukz);//r
} // doglutpos

template < class Tf, class Tp> void dogluttext(Tf * f, const Tp & x, const Tp & y, const Tp & z, const Tp &_sz, const Tp & ang=0)
{
Gf fukx=x;   Gf fuky=y; Gf fukz=z;  
inplacepos(fukx,fuky,fukz);
draw_string(fukx,fuky,fukz,f);
//glVertex3f(fukx,fuky,fukz);//upper-right corner
//(*f)(fukx,fuky,fukz);//r
// goog ai
glPushMatrix();
glTranslatef(fukx, fuky, fukz);
glRotatef(ang,0,0,1);
const Gf sz=.5*.0416667*_sz; // thought to normalize more oe less lol
MM_ERR(MMPR4(fukx,fuky,fukz,sz)<<MMPR2(_sz,f))
// this is partially managed by us and glut lol.
glScalef(sz,sz,sz); // Adjust scale for better visibility
glutStrokeString(GLUT_STROKE_ROMAN, (const unsigned char*)f);
glPopMatrix();

} // dogluttext






// this is called in heatmap
// TODO in general there are a lot of cllipped points
// and we need a wa to clip them early...
// inverse is available and clipping fixed but
// checking every point may be slow in genera
// need special cases of no rotation etc. 
template <  class Tp> void inplacepos( Tp & x, Tp & y, Tp & z)
{
Matrix in=Matrix(3,1);
in[0]=x-m_tgt[0]; in[1]=y-m_tgt[1]; in[2]=z-m_tgt[2];

Matrix out=m_mat*in;
//MM_ERR(MMPR2(in.dump(),out.dump()))
x=out[0]; y=out[1];// 
// put everything at the z==0 plane in  glut space lol
// TODO FIXME this may confuse things like shaders etc.
// need to figure out something here. 
//z=0;
z=out[2]*m_squash;
if ((z>1)||(z< -1))
{
static int  n=0;
++n;
if (n>=1000) {  MM_ERR(" z clipping "<<MMPR2(z,n)) n=0;  } 

} 
} // inplacepos

template <  class Tp> void inv_inplacepos( Tp & x, Tp & y, Tp & z)
{
Matrix in=Matrix(3,1);
//in[0]=x-m_tgt[0]; in[1]=y-m_tgt[1]; in[2]=z-m_tgt[2];
in[0]=x; in[1]=y; in[2]=z;
Matrix out=m_imat*in;
x=out[0]+m_tgt[0];
y=out[1]+m_tgt[1];
z=out[2]+m_tgt[2];
} // inv_inplacepos




StrTy Encode(const IdxTy flags=0) { 
BaseParams kvp;
StrTy s;
//kvp.encode(s,"vifx",m_vidx);
kvp.encode(s,"vidx",m_vidx);
return s;} // Encode
void Init(const StrTy & s,const IdxTy flags)
{
const bool reinit=!Bit(flags,0);
BaseParams kvp(s);
if (reinit) Init();
kvp.get(m_vidx,"vidx");
kvp.get(m_style,"style");
kvp.get(m_scale[0],"scalex");
kvp.get(m_scale[1],"scaley");
kvp.get(m_scale[2],"scalez");
kvp.get(m_tgt[0],"scalex");
kvp.get(m_tgt[1],"scaley");
kvp.get(m_tgt[2],"scalez");

ResetA();

} // Init

void ResetA()
{


auto & m=m_mat;
m.diag(1);
MM_ILOOP(i,3) {m(i,0)*=m_scale[0]; }
MM_ILOOP(i,3) {m(i,1)*=m_scale[1]; }
MM_ILOOP(i,3) {m(i,2)*=m_scale[2]; }
m_imat=m.invert3x3();
//m_imat.diag(1);
m_imat=m.invert3x3();


} // ResetA

void InitGeometry()
{
//m_lookat=0; 
m_mat=Matrix(3,3);
m_mat.diag(1);
ResetA();

} // InitGeometry 
void Init()
{
m_vidx=5;
m_squash= 1e-12;
m_scale=1;
m_tgt=0;
m_style=0;
m_action=BAD;
InitGeometry();
}


StrTy dump(const IdxTy flags=0) const
{
Ss ss;
ss<<MMPR(m_tgt.dump());
ss<<MMPR(m_scale.dump());
ss<<MMPR4(m_action,m_squash,m_vidx,m_style);
ss<<MMPR(m_mat.dump());
ss<<MMPR(m_imat.dump());
//ss<<MMPR4(m_vidx,theta,phi,distance);
return ss.str();
}

// _view_MEMBERS

GeoState   m_tgt,m_scale;
mutable Matrix m_mat,m_imat;
IdxTy m_vidx,m_style;
D m_squash;
action_t m_act;
IdxTy m_action;


}; // _view



class _color_desc
{

public:
_color_desc(): r(1),g(1),b(1) {}
template <class Tt> _color_desc(const Tt & t): r(t.r),g(t.g),b(t.b) {}
_color_desc( const D& _r, const D& _g,const D& _b) 
	: r(_r),g(_g),b(_b) {}
const D & x() const { return r; } 
const D & y() const { return g; } 
const D & z() const { return b; } 
D r,g,b;
}; // _color_desc

typedef _color_desc color_type;









class _point_desc
{
public:
// bit 0 : 2d face user. 
//_point_desc(): x(0),y(0),z(0),r(1),g(1),b(1),sz(24),flags(0) {}
_point_desc(): x(0),y(0),z(0),sz(24),flags(0) {}
_point_desc( const D& _x, const D& _y,const color_type & _r=color_type())
//: x(_x),y(_y),z(0),r(1),g(1),b(1),sz(24),flags(1) {}
: x(_x),y(_y),z(0),rgb(_r),sz(24),flags(1) {}
_point_desc( const D& _x, const D& _y,const D& _z,const color_type & _r=color_type())
//: x(_x),y(_y),z(_z),r(1),g(1),b(1),sz(24),flags(1) {}
: x(_x),y(_y),z(_z),rgb(_r),sz(24),flags(1) {}
//StrTy m_s;
D x,y,z;
color_type rgb;
//D r,g,b;
D sz;
IdxTy flags;
}; // _point_desc


class _text_desc : public _point_desc
{
typedef _point_desc Super;
public:
_text_desc() {}
_text_desc(const StrTy & s,  const D& _x, const D& _y)
: m_s(s),Super(_x,_y){}
StrTy m_s;

}; // _text_desc


class _seg_desc : public std::vector<_point_desc>
{

}; // _seg_desc
// does not accomodate draw order/Z-buffer etc
// although each is a 3D point and gl should
// do z processing huh? 
class _junk_bin
{

typedef mjm_svg_render<Tr>  SvgRender;
typedef std::map<IdxTy,IdxTy> Umap;
public:
//_junk_bin(): m_code(0),m_szlim(10),m_pstrip(0)  {}
_junk_bin(): m_code(0),m_szlim(10)  {}
//~_junk_bin() {delete m_pstrip; }
~_junk_bin() { }
void add_point(const D & x, const D & y, const D & z=0)
{ _point_desc p(x,y,z); m_points.push_back(p); } 
void add_svg(const StrTy& s)
{
SvgRender x;
x.load(s.c_str(),s.length(),0);
svgs().push_back(x);

}
void add_seg(const IdxTy s, const D & x, const D & y, const D & z, const
color_type & ct)
{ _point_desc p(x,y,z,ct); 
if (s>=segs().size()) segs().resize(s+1); 
segs()[s].push_back(p); } 

void add_params( const Line & l, const IdxTy ii,const IdxTy len )
{
for(IdxTy i=ii; i<(len-1); i+=2)
{
params()[l[i]]=l[i+1];
} // i 

} // add_names
void add_etc( const Line & l, const IdxTy ii,const IdxTy len )
{
for(IdxTy i=ii; i<(len-1); i+=2)
{
etc()[l[i]]=l[i+1];
} // i 

} // add_etc 

const StrTy etc(const StrTy & k) const
{
const auto ii=etc_d().find(k);
if (ii==etc_d().end()) return StrTy();
return (*ii).second;

}


void add_names( const Line & l, const IdxTy ii, const IdxTy len )
{
//const IdxTy ii=2;
for(IdxTy i=ii; i<len; ++i)
{
Ss ss; ss<<"name"<<(i-ii);
params()[ss.str()]=l[i];
} // i 

}// add_params

// should have already loaded etc before
IdxTy load_heatmap(const Ragged & r, const IdxTy flags)
{
IdxTy taxin=7;
auto ii=etc_d().find("ntax");
if (ii!=etc_d().end()) taxin=atoi((*ii).second.c_str());
MM_ERR(MMPR4(r.size(),taxin,etc_d().size(),params_d().size()))
// only keep 2 
return heatmap().load_heatmap(r, taxin, 2, flags);
}
//IdxTy load_heatmap(const Ragged & r, const IdxTy taxin, const IdxTy taxkeep, const IdxTy flags)
typedef mjm_dscope_heatmap<Tr> Heatmap;

typedef mjm_tokenized_points<Tr>  TokPoints;

// easy for now but need a better general mesh 
typedef mjm_ff_mesh<Tr> _ff_mesh_t;

typedef std::vector<SvgRender> SvgVec;
typedef std::vector<_point_desc> PointVec;
typedef std::vector<_seg_desc> SegVec;
typedef std::vector<_text_desc> StrVec;
typedef std::map<StrTy, StrTy> Parameters;
#if 0
template <class PointEntry , class Shape, class DrawInfo > 
IdxTy draw_ornate_shape(const PointEntry & pi,Shape * pshape,  DrawInfo * sdp)
{
Shape & s=*pshape;
// size and place ok... 
// maybe output vectors or something? 
// FIXME the bastard coords- both glut and view have xforms, make this
// confusing. Need to pick one but too time consuming for now. 
//glTranslatef(); 
//glColor3f();//
// TODO use the color in shape this is dumb 
glColor3f(pi.r(),pi.g(),pi.b() );//
if (s.filled())  glBegin(GL_POLYGON);
else  glBegin(GL_LINE_LOOP);
// this has to be a translated shape or else translated... 
MM_LOOP(ii,s)
{
//v.doglutpos(glVertex3f,pi);
//v.doglutpos(glVertex3f,(*ii).triple(pi.x(),pi.y(),pi.z(),pi.size()));
doglutpos(glVertex3f,(*ii).triple(pi.x(),pi.y(),pi.z(),pi.size()));
} // ii 

glEnd();


return 0;
} // DrawOrnateShape
#endif
IdxTy set_strip_color( const IdxTy idx, const D & r,
const D & g, const D & b)
{
 strip().set_color(idx,r,g,b,0);
return 0; 
}


void clear() { m_strings.clear(); m_points.clear(); m_segs.clear();
}
void add_strip( const Ragged & r, const IdxTy flags)
{
//if (m_pstrip==0) m_pstrip= new strip_t();
//m_pstrip->append(r,flags); 
add_common_hdr(r,flags);
//strip().append(r,flags); 
strip().append(r,*this,flags); 
} // add_strip

void add_common_hdr( const Ragged & r, const IdxTy flags)
{

MM_ILOOP(i,r.size())
{
const Line & l=r[i];
const IdxTy len=l.size();
if (l[0]=="#")
{
if (len<2) continue;
const StrTy & cmd=l[1];
if (cmd=="params"){   add_params(l,2, len); continue; }
//mi.add_params(l,2,len);
if (cmd=="etc"){  add_etc(l,2,len);  continue; }
//if (cmd=="names") {  AddNames(mi,l,len); continue; }
//MM_ONCE(" silently ignoring future comments like  "<<MMPR(cmd),)
//continue;
}  // # 
else break; // should be contig header for now doh 
} // i 

} // add_common_hdr

void add_decorations( const Ragged & r, const IdxTy flags)
{ decorations().append(r,flags); 
} // add_decorations

void add_molecule( const Ragged & r, const IdxTy flags)
{ 
molecule().append(r,flags); 
} // add_decorations

// alled by rges for strip chart
// usually one entity gets updated along with params and etc. 
// this gets the data but maintains our current view etc. 
void append_asfck(const _junk_bin  & that,const IdxTy flags=0)
{
//MM_ERR(" append not complete")
MM_ERR(" model append "<<MMPR2(usages(), that.usages()))
//if (that.used(M_STRIP)) strip().append(that.strip_d(),flags); 
//if (that.used(M_STRINGS)) m_strings.append(that.m_strings,flags); 
//if (that.used(M_POINTS)) m_points.append(that.m_points,flags); 
if (that.used(M_ORNATE_POINTS)) m_ornate_points.append(that.m_ornate_points,flags); 
//if (that.used(M_SEGS)) m_segs.append(that.m_segs,flags); 
//if (that.used(M_SVGS)) m_svgs.append(that.m_svgs,flags); 
//if (that.used(M_CODE)) m_code.append(that.m_code,flags); 
//if (that.used(M_SZLIM)) m_szlim.append(that.m_szlim,flags); 
// update or overwrite? 
//if (that.used(M_PARAMS)) m_params.append(that.m_params,flags); 
//if (that.used(M_ETC)) m_etc.append(that.m_etc,flags); 
if (that.used(M_HEATMAP)) m_heatmap.append(that.m_heatmap,flags); 
if (that.used(M_FF_MESH)) m_ff_mesh.append(that.m_ff_mesh,flags); 
if (that.used(M_STRIP)) m_strip.append(that.m_strip,flags); 
if (that.used(M_GRATICULE)) m_graticule.append(that.m_graticule,flags); 
if (that.used(M_DECORATIONS)) m_decorations.append(that.m_decorations,flags); 
if (that.used(M_MOLECULE)) m_molecule.append(that.m_molecule,flags); 
} // append 

// new accessors to account for usage...
// cat pieces.txt| sed -e 's/;//g'  | while read ; do t=`echo $REPLY | awk '{print $1}' `; v=`echo $REPLY | awk '{print $2}'`; e=`echo $v | tr "[a-z]" "[A-Z]" `;n=`echo $v| sed -e 's/m_//' `;  enum="$enum,$e" ; echo $v $t $e $enum; echo -e "$t & $n() { ++m_usage_map[$e];  return $v; } "  ; done | grep "()"

enum { M_STRINGS,M_POINTS,M_ORNATE_POINTS,M_SEGS,M_SVGS,M_CODE,M_SZLIM,M_PARAMS,M_ETC,M_HEATMAP,M_FF_MESH,M_STRIP,M_GRATICULE,M_DECORATIONS,M_MOLECULE};


SegVec & segs() { ++m_usage_map[M_SEGS];  return m_segs; } 
const SegVec & segs_d() const  {  return m_segs; } 
SvgVec & svgs() { ++m_usage_map[M_SVGS];  return m_svgs; } 
const SvgVec & svgs_d() const {   return m_svgs; } 
IdxTy & code() { ++m_usage_map[M_CODE];  return m_code; } 
IdxTy & szlim() { ++m_usage_map[M_SZLIM];  return m_szlim; } 

StrVec & strings() { ++m_usage_map[M_STRINGS];  return m_strings; } 
const StrVec & strings_d() const {  return m_strings; } 
PointVec & points() { ++m_usage_map[M_POINTS];  return m_points; } 
const PointVec & points_d() const {  return m_points; } 
TokPoints & ornate_points() { ++m_usage_map[M_ORNATE_POINTS];  return m_ornate_points; } 
const TokPoints & ornate_points_d() const  {  return m_ornate_points; } 
Parameters & params() { ++m_usage_map[M_PARAMS];  return m_params; } 
const Parameters & params_d() const {  return m_params; } 
Parameters & etc() { ++m_usage_map[M_ETC];  return m_etc; } 
const Parameters & etc_d()const { return m_etc; } 
Heatmap & heatmap() { ++m_usage_map[M_HEATMAP];  return m_heatmap; } 
const Heatmap & heatmap_d()const {  return m_heatmap; } 
_ff_mesh_t & ff_mesh() { ++m_usage_map[M_FF_MESH];  return m_ff_mesh; } 
const _ff_mesh_t & ff_mesh_d() const  {  return m_ff_mesh; } 
strip_t & strip() { ++m_usage_map[M_STRIP];  return m_strip; } 
const strip_t & strip_d() const  {  return m_strip; } 
graticule_t & graticule() { ++m_usage_map[M_GRATICULE];  return m_graticule; } 
graticule_t & graticule_d() {  return m_graticule; } 
decorations_t & decorations() { ++m_usage_map[M_DECORATIONS];  return m_decorations; } 
decorations_t & decorations_d() { return m_decorations; } 
mole_t & molecule() { ++m_usage_map[M_MOLECULE];  return m_molecule; } 
mole_t & molecule_d() { return m_molecule; } 


typedef  std::map<IdxTy,StrTy> UmapTy;

static UmapTy & umaps()
{
static UmapTy m;
if (m.size()==0) { 
// cat xxx | sed -e 's/,/\n/g' | awk '{print "m["$1"]=\""$1"\";"}'
m[M_STRINGS]="M_STRINGS";
m[M_POINTS]="M_POINTS";
m[M_ORNATE_POINTS]="M_ORNATE_POINTS";
m[M_SEGS]="M_SEGS";
m[M_SVGS]="M_SVGS";
m[M_CODE]="M_CODE";
m[M_SZLIM]="M_SZLIM";
m[M_PARAMS]="M_PARAMS";
m[M_ETC]="M_ETC";
m[M_HEATMAP]="M_HEATMAP";
m[M_FF_MESH]="M_FF_MESH";
m[M_STRIP]="M_STRIP";
m[M_GRATICULE]="M_GRATICULE";
m[M_DECORATIONS]="M_DECORATIONS";
m[M_MOLECULE]="M_MOLECULE";
}



return m;
} // umaps
StrTy usages() const
{
UmapTy   m=umaps();
Ss ss;
MM_LOOP(ii, m_usage_map) { if ((*ii).second!=0) ss<<m[(*ii).first]<<"="<<(*ii).second<<" "; }
return ss.str();
} // usages

bool used(const IdxTy e) const { const auto ii=m_usage_map.find(e); 
if (ii==m_usage_map.end()) return false;  return (*ii).second !=0; } 


StrTy show() const
{
Ss ss;
MM_LOOP(ii,m_usage_map)
{
const IdxTy id=(*ii).first;
ss<<" "<<umaps()[id];
if (id==M_STRIP) { ss<< m_strip.show(); } 
ss<<CRLF;
} // ii 
return ss.str();
} // show
// junk_MEMBERS

// operator += designed to add a new update existing entry.
// often just append but may want to overwrite parameters.
// In reality, the viewer may want to distinguish points by
// bin or origin so adding together tosses info but history
// typicall 10 or so while may want unlimited += operation. 
StrTy m_type,m_src;

// make private to allow more intelligent merger or append

//private:

IdxTy m_code;
IdxTy m_szlim;
private:

Umap m_usage_map;
SegVec m_segs;
SvgVec m_svgs;
StrVec m_strings;
PointVec m_points;
TokPoints m_ornate_points;

Parameters m_params;
Parameters m_etc;
Heatmap m_heatmap;
_ff_mesh_t m_ff_mesh;
strip_t  m_strip;
graticule_t m_graticule;
decorations_t m_decorations;
mole_t m_molecule; 

}; // _junk_bin
typedef _junk_bin junk_bin_type;

private:
mjm_glut_helpers() {}
~mjm_glut_helpers() {}


// these things need mutexes.... 
public:
// TYPEDEFS
typedef _draw_info draw_info_t;
typedef _ptr_info ptr_info_t;
typedef _key_info key_info_t;
typedef _view view_info_t;
typedef _junk_bin junk_bin_t;
typedef color_type color_t;

// API


typedef GLdouble Gc;
static IdxTy unproject(Gc & x, Gc & y, Gc & z, const Gc xin, const Gc yin)
{ return Unproject(x, y, z,  xin,  yin); } 


static IdxTy start_view(const view_info_t & v) 
{ return StartView(v); } 
static IdxTy start_view_zed(const IdxTy flags=0) { return StartViewZed( flags) ; }
static IdxTy start_view_zed(const IdxTy w, const IdxTy h, const IdxTy flags=0) { return StartViewZed(w,h, flags) ; }
static IdxTy display(const junk_bin_t & bin, const view_info_t & view, const IdxTy flags)
{ return Display(bin,view,flags); } 
static IdxTy draw_quad_elements
(const Elements   & el, const view_info_t & view, const IdxTy flags)
{ return  DrawQuadElements( el, view,  flags); } 
// https://stackoverflow.com/questions/538661/how-do-i-draw-text-with-glut-opengl-in-c
static void render_string(float x, float y,  const char* string, const color_t & rgb)
{ render_string(x,y,0,string,rgb); } 
static void render_string(float x, float y, void *font, const char* string, const color_t & rgb)
{  
  char *c;

  glColor3f(rgb.r, rgb.g, rgb.b); 
  glRasterPos2f(x, y);
//  glRasterPos3f(x, y,0.0);
if (font==0)
  glutBitmapString(GLUT_BITMAP_TIMES_ROMAN_24, (const unsigned char *)string);
  else glutBitmapString(font, (const unsigned char *) string);
}

//RenderString(0.0f, 0.0f, GLUT_BITMAP_TIMES_ROMAN_24, "Hello", RGB(1.0f, 0.0f, 0.0f));



// https://users.cs.jmu.edu/bernstdh/web/common/lectures/summary_opengl-text.php
static void begin_screen_coords(const view_info_t & v=view_info_t() ) {
  glMatrixMode(GL_PROJECTION);

  // Save the current projection matrix
  glPushMatrix();

  // Make the current matrix the identity matrix
  glLoadIdentity();
int w,h;
w=glutGet(GLUT_WINDOW_WIDTH);
h=glutGet(GLUT_WINDOW_HEIGHT);
  // Set the projection (to 2D orthographic)
  gluOrtho2D(0, w, 0, h);
//  gluOrtho2D(0, 1, 0, 1);

  glMatrixMode(GL_MODELVIEW);
  
// new code 
glPushMatrix();
  glLoadIdentity();
} // begin_screen_coords


static void draw_string(float x, float y, float z, const StrTy & s) {
draw_string(x,y,z,s.c_str()); } 
static void draw_string(float x, float y, float z, const char *string) {
  // Save the current matrix
  glPushMatrix();
  // Translate to the appropriate starting point
  glTranslatef(x, y, z);
  // Note: We could change the line width with glLineWidth()
  // Render the characters
void * currentFont=GLUT_STROKE_MONO_ROMAN;
  for (const char* c = string; *c != '\0'; c++) {
    glutStrokeCharacter(currentFont, *c);
  }
  // Another useful function
  //    int glutStrokeWidth(void *font, int character);

  // Retrieve the original matrix
  glPopMatrix();
} // draw_string



static void end_screen_coords(const view_info_t & v=view_info_t()) {

  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();
  glMatrixMode(GL_PROJECTION);

  // Restore the original projection matrix
  glPopMatrix();
  glMatrixMode(GL_MODELVIEW);

}




StrTy dump(const IdxTy flags=0) { return Dump(flags); }




static D dmod( const D & x, const D & m)
{return x-int(x/m)*m-.5*m; }
static color_t  theta_color(const D & t)
{
const D m=2*M_PI;
IdxTy i=0;
D r=2.0*255*fabs(dmod(t,m)/m);
D g=2.0*255*fabs(dmod(t+m/3.0,m)/m);
D b=2.0*255*fabs(dmod(t+2.0*m/3.0,m)/m);
//i=(int(r)&255);
//i|=(int(g)&255)<<8;
//i|=(int(b)&255)<<16;
//Ss ss; ss<<"#"<<std::hex<<i;
int ri=int(r)&255;
int gi=int(g)&255;
int bi=int(b)&255;
color_t ct(ri,gi,bi);
// if (r<2) if (g<2) if (b<2) MM_ERR(MMPR4(r,g,b,ss.str()))
//MM_ERR(MMPR(ss.str()))
return ct; //  ss.str();
} // theta_color
static color_t  range_color(const D & _t,const D & min, const D& max)
{
if (max<=min) { return color_t(1,1,1); } 
const D t=(_t-min)/(max-min);
D scale=1;
D r=scale*fabs(t);
D g=scale*(2.0*(.5-fabs(t-.5)));
D b=scale*fabs(1.0-t);
//int ri=int(r)&255; int gi=int(g)&255; int bi=int(b)&255;
//color_t ct(ri,gi,bi);
color_t ct(r,g,b);
//if (r<2) if (g<2) if (b<2) MM_ERR(MMPR4(r,g,b,ss.str()))
//MM_ERR(MMPR(ss.str()))
return ct; //  ss.str();
} // range_color

















private:
static bool Bit(const IdxTy f, const IdxTy b)  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
static IdxTy Display(const junk_bin_t & bin, const view_info_t & view, const IdxTy flags)
{
MM_LOOP(ii,bin.m_strings) { DisplayString((*ii),view,flags); } 
MM_LOOP(ii,bin.segs_d()) { DisplaySeg((*ii),view,flags); } 
MM_LOOP(ii,bin.m_points) { DisplayPoint((*ii),view,flags); } 
//StrVec m_strings;
//PointVec m_points;
//SegVec m_segs;

return 0; 
} // Display junk_bin_t

static IdxTy DisplaySeg(const _seg_desc & s, const view_info_t & view, const IdxTy flags)
{



return 0; 
} // DisplaySeg  


static IdxTy DisplayPoint(const _point_desc & p, const view_info_t & view, const IdxTy flags)
{

return 0; 
} // DisplayPoint  


static IdxTy DisplayString(const _text_desc & t , const view_info_t & view, const IdxTy flags)
{

return 0; 
} // DisplayString  


// https://stackoverflow.com/questions/538661/how-do-i-draw-text-with-glut-opengl-in-c
static void RenderString(float x, float y, void *font, const  char* string)
{  
//  char *c;

  glColor3f(1.0,1.0,1.0);
  glRasterPos2f(x, y);

  glutBitmapString(font, (const unsigned char *) string);
}
IdxTy Scene(const Ragged & r, const StrTy _scene, const IdxTy flags)
{
const StrTy scene=_scene; // "";
IdxTy rc=0;
Elements el;
//r.save("wtf.xxx");
el.make_elements(r,0);
MM_ERR(MMPR2(r.size(),el.size()))
//MM_ERR(" scene "<<MMPR2(el.size(),scene))
// this is not threa safe... 
//p()->EnterSerial(0);
//p()->m_scenes[scene]=el; // .make_elements(r,0);
//MM_ERR(MMPR(m_scenes[scene].size()))
//p()->ExitSerial(0);
//MM_ERR(MMPR(m_scenes[scene].size()))

// this should only be when a new one is added
MM_ERR(" FIXME  scene post redisplay ")
      glutPostRedisplay();
return rc;
} // Scene

#if 0 
// https://www.khronos.org/opengl/wiki/Viewing_and_Transformations
//static float zoomFactor; /* Global, if you want. Modified by user input. Initially 1.0 */

   /* A routine for setting the projection matrix. May be called from a resize
      event handler in a typical application. Takes integer width and height 
      dimensions of the drawing area. Creates a projection matrix with correct
      aspect ratio and zoom factor. */
   void setProjectionMatrix (int width, int height, float zoomFactor,  float conditionalaspect)
   {
     glMatrixMode(GL_PROJECTION);
     glLoadIdentity();
     if ( (float)width / (float)height < conditionalaspect ) { // Adjust zoom factor to extend vertical aspect ratio if below the aspect ratio constraint otherwise extend horizontal. By default, the aspect constraint is 1.0.
     zoomfactor *= ((float)width / (float)height) / conditionalaspect;
     }
     gluPerspective(atan(tan(50.0 * 3.14159 / 360.0) / zoomFactor) * 360.0 / 3.14159, (float)width/(float)height, zNear, zFar);
     /* ...Where 'zNear' and 'zFar' are up to you to fill in. */
   }

/*
How can I automatically calculate a view that displays my entire model? (I know the bounding sphere and up vector.)
The following is from a posting by Dave Shreiner on setting up a basic viewing system:

First, compute a bounding sphere for all objects in your scene. This should provide you with two bits of information: the center of the sphere (let ( c.x, c.y, c.z ) be that point) and its diameter (call it "diam").

Next, choose a value for the zNear clipping plane. General guidelines are to choose something larger than, but close to 1.0. So, let's say you set

   zNear = 1.0;
   zFar = zNear + diam;
Structure your matrix calls in this order (for an Orthographic projection):

   GLdouble left = c.x - diam;
   GLdouble right = c.x + diam;
   GLdouble bottom c.y - diam;
   GLdouble top = c.y + diam;

   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   glOrtho(left, right, bottom, top, zNear, zFar);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
This approach should center your objects in the middle of the window and stretch them to fit (i.e., its assuming that you're using a window with aspect ratio = 1.0). If your window isn't square, compute left, right, bottom, and top, as above, and put in the following logic before the call to glOrtho():

   GLdouble aspect = (GLdouble) windowWidth / windowHeight;

   if ( aspect < 1.0 ) { // window taller than wide
     bottom /= aspect;
     top /= aspect;
   } else {
     left *= aspect;
     right *= aspect;
   }
The above code should position the objects in your scene appropriately. If you intend to manipulate (i.e. rotate, etc.), you need to add a viewing transform to it.

A typical viewing transform will go on the ModelView matrix and might look like this:

gluLookAt(0., 0., 2.*diam, c.x, c.y, c.z, 0.0, 1.0, 0.0);


*/
#endif


//typedef GLdouble Gc;
static IdxTy Unproject(Gc & x, Gc & y, Gc & z, const Gc xin, const Gc yin)
{
  Gc zs; Gf zsf;
  //glReadPixels (x, y, 1, 1, GL_DEPTH_COMPONENT, GL_DOUBLE, &zs);
  glReadPixels (x, y, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &zsf);
zs=zsf;
Gc mp[128],pp[128];
GLint vp[128];
glGetDoublev(GL_MODELVIEW_MATRIX, &mp[0]);
glGetDoublev(GL_PROJECTION_MATRIX, &pp[0]);
glGetIntegerv(GL_VIEWPORT, &vp[0]);
gluUnProject(xin,yin,zs,mp,pp,vp,&x,&y,&z);
return 0; 
} // Unproject 



static IdxTy StartViewZed(const IdxTy flags=0) 
{
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  
 //  glLoadIdentity();
   glMatrixMode(GL_PROJECTION);     //
   glLoadIdentity();     
//glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);
return 0; 
}
static IdxTy StartViewZed(const IdxTy w, const IdxTy h, const IdxTy flags=0) 
{
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  
 //  glLoadIdentity();
//glViewport(0,0,w*10,h*10);
glViewport(0,0,w,h);
   glMatrixMode(GL_PROJECTION);     //
   glLoadIdentity();     

   //gluPerspective(65.0, (float)g_Width / g_Height, g_nearPlane, g_farPlane);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();


//glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);
return 0; 
}

           
static IdxTy StartView(const view_info_t & v) 
{
// https://lmb.informatik.uni-freiburg.de/people/reisert/opengl/doc/glOrtho.html

   glMatrixMode(GL_PROJECTION);     //
   glLoadIdentity();     
   glMatrixMode(GL_MODELVIEW);     // To operate on model-view matrix
   glLoadIdentity();                 // Reset the model-view matrix

// camera position, center of reference, dir of "up" vector 
gluLookAt(0,0,1,  0,0,0, 0,1,0);

glLineWidth(Gf(1.0));
glDisable(GL_LIGHTING);
glDisable(GL_LIGHT0);
return 0; 
} // StartView



IdxTy Stream(const StrTy s )
{
MM_ERR(MMPR(__FUNCTION__))
BaseParams sk(s);
StrTy scene="";
StrTy fn="fddump.txt";
sk.get(fn,"fn");
sk.get(scene,"scene");
Ragged r;
r.load(fn);
//Draw(r,0);
Elements el;
el.make_elements(r,0);
// this is not threa safe... 
EnterSerial(0);
//m_scenes[scene]=el; // .make_elements(r,0);
ExitSerial(0);

return 0;
} // Stream






static IdxTy DrawQuadElements(const Elements   & el, const view_info_t & view, const IdxTy flags)
{
EnterSerial(0);
//const Elements  el=m_scenes[scene]; // ; el.make_elements(r,0);
//const View view=m_views[scene];
ExitSerial(0);
if (el.size()==0)
{
//MM_ERR("no scene yet "<<MMPR2(scene,m_scenes.size()))
return -1; 
}
//MM_ERR(" have scene "<<MMPR(el.size()))
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   // Set up viewing transformation, looking down -Z axis
   glLoadIdentity();
   
Gf g_fViewDistance=1;;
Gf nx= -view.m_focus[0]* g_fViewDistance;
Gf ny= -view.m_focus[1]* g_fViewDistance;
Gf nz= -view.m_focus[2]* g_fViewDistance;
float g_lightPos[4] = { 10, 10, -100, 1 }; 
gluLookAt(nx,ny,nz, 
Gf(view.m_c[0]), Gf(view.m_c[1]), Gf(view.m_c[2]), 
  0, 1, 0);
   glLightfv(GL_LIGHT0, GL_POSITION, g_lightPos);
glDisable(GL_LIGHTING);
glDisable(GL_LIGHT0);
//glEnable(GL_LIGHTING);
//glEnable(GL_LIGHT0);
   glBegin(GL_QUADS);       
IdxTy vidx=view.vidx();
const IdxTy nvals=el.nvalues();
vidx=vidx%nvals;
// so now this has for each node a node number, x, y, values, and then 4 elements
Gf vmin=0;
Gf vmax=0;
//MM_ERR(MMPR2(el.nvalues(),el.size()))
const auto & stats=el(vidx);
vmin=stats.mmin;
vmax=stats.mmax;
//MM_ERR(MMPR2(vmax,vmin))

if (vmax==vmin) vmax=vmin+1;
Gf rna=1.0/(vmax-vmin);
Gf c1=vmin*rna;
MM_LOOP(ii,el)
{
const Element & e=(*ii);
if (4!=e.m_vx.size()) continue;
// these need to be ordered... 
const auto& vs=view.m_scale;
for(IdxTy j=0; j<4; ++j) { 
const auto & ei=e.m_vx[j];
const auto & lo=ei.first;
const auto & v=ei.second;

//Gf gb= (v[vidx]-vmin)/(vmax-vmin);
Gf gb= v[vidx]*rna-c1;
Gf r= gb;
Gf g=1.0-4.0*(r-.5)*(r-.5) ;
Gf b=1.0-r ;
//MM_ERR(MMPR4(lo[0],lo[1],gb,r)<<MMPR2(g,b))
  glColor3f(r,g,b);     // Green
      glVertex3f(Gf(lo[0]*vs[0]),Gf(lo[1]*vs[1]),gb*vs[2]);

} // j 

} // i 

glEnd();  // End of drawing color-cube

{ Ss ss;
el.text(ss,0);
ss<<CRLF;
ss<<MMPR2(vidx,nvals);
ss<<CRLF;
ss<<MMPR2(vmin,vmax);
StrTy s=ss.str();
RenderString(5.0,5.0, GLUT_BITMAP_TIMES_ROMAN_24, s.c_str());
}

//MM_ERR(" wt f ")

//glutSwapBuffers();
//      glutPostRedisplay();


return 0;
} // Draw



// MEMBERS



}; // mjm_glut_helpers

//////////////////////////////////////////////

template <class Tr>
class mjm_glut_helpers_map : public std::map<typename Tr::StrTy, mjm_glut_helpers< Tr > >  
{
 typedef mjm_glut_helpers_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_glut_helpers< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_glut_helpers_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_glut_helpers_map




////////////////////////////////////////////
#ifdef  TEST_MJM_GLUT_HELPERS
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_glut_helpers <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_GLUT_HELPERS "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_glut_helpers<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_GLUT_HELPERS_H__ 

