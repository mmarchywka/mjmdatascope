#ifndef MJM_GLUT_SAVER_H__
#define MJM_GLUT_SAVER_H__


// https://stackoverflow.com/questions/3191978/how-to-use-glut-opengl-to-render-to-a-file
// sudo apt-get install libpng-dev libavcodec-dev libavutil-dev
/*

 gcc -DPPM=1 -DLIBPNG=1 -DFFMPEG=1 -ggdb3 -std=c99 -O0 -Wall -Wextra   -x c movie_Example.h -lGL -lGLU -lglut -lpng -lavcodec -lswscale -lavutil
movie_Example.h:3:1: warning: multi-line comment [-Wcomment]
 //gcc -DPPM=1 -DLIBPNG=1 -DFFMPEG=1 -ggdb3 -std=c99 -O0 -Wall -Wextra \
 ^
marchywka@happy:/home/documents/cpp/proj/datascope$ g++ -DPPM=1 -DLIBPNG=1 -DFFMPEG=1 -ggdb3 -std=c99 -O0 -Wall -Wextra   -x c movie_Example.h -lGL -lGLU -lglut -lpng -lavcodec -lswscale -lavutil
movie_Example.h:3:1: warning: multi-line comment [-Wcomment]
 //gcc -DPPM=1 -DLIBPNG=1 -DFFMPEG=1 -ggdb3 -std=c99 -O0 -Wall -Wextra \
 ^

This appears to link have not run yet 
marchywka@happy:/home/documents/cpp/proj/datascope$ g++ -DPPM=1 -DLIBPNG=1 -DFFMPEG=1 -ggdb3 -std=c99 -O0 -Wall -Wextra   -x c movie_Example.h -lGL -lGLU -lglut -lpng -lavcodec -lswscale -lavutil
marchywka@happy:/home/documents/cpp/proj/datascope$ ls -al a.out
-rwxrwxr-x 1 marchywka marchywka 404216 May  2 13:53 a.out



//gcc -DPPM=1 -DLIBPNG=1 -DFFMPEG=1 -ggdb3 -std=c99 -O0 -Wall -Wextra -o offscreen offscreen.c -lGL -lGLU -lglut -lpng -lavcodec -lswscale -lavutil

this fails to link, 
g++ -fpermissive -x c++  movie_Example.h -lGL  -lGLU -lglut  -lpng  -lavcodec-ffmpeg -lswscale-ffmpeg -lavutil-ffmpeg


*/




#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_string_kvp.h"
#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>



#ifndef PPM
#define PPM 1
#endif
#ifndef LIBPNG
#define LIBPNG 1
#endif
#ifndef FFMPEG
#define FFMPEG 1
#endif

#define MJMTIFF 1

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define GL_GLEXT_PROTOTYPES 1
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>
#include <GL/glext.h>
#if MJMTIFF
#include <tiffio.h>
#endif

#if LIBPNG
#include <png.h>
#endif

#if FFMPEG
extern "C" {
#include <libavcodec/avcodec.h>
#include <libavutil/imgutils.h>
#include <libavutil/opt.h>
#include <libswscale/swscale.h>
}; 
#endif


// https://openshot.org/files/libopenshot/FFmpegUtilities_8h_source.html
// this should 4.0 but I can'f tind the right values fuyck 
 #ifndef IS_FFMPEG_DEP
 #define IS_FFMPEG_DEP (LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 64, 101))
 #endif
#ifdef IS_FFMPEG_DEP
#warning ate out deprecated crap 
#endif
// Tue May  2 15:13:31 EDT 2023
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_glut_saver   

// g++  -std=gnu++11 -DTEST_MJM_GLUT_SAVER -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_glut_saver.h  -o mjm_glut_saver.out -lpthread -lreadline  -lGL -lGLU -lglut -lpng -lavcodec -lswscale -lavutil 




// g++  -Wall -std=gnu++11 -DTEST_MJM_GLUT_SAVER -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_glut_saver.h  -o mjm_glut_saver.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_glut_saver("mjm_glut_saver"
, "  ");


namespace old_carp {
enum Constants { SCREENSHOT_MAX_FILENAME = 256 };
static GLubyte *pixels = NULL;
static GLuint fbo;
static GLuint rbo_color;
static GLuint rbo_depth;
static int offscreen = 1;
static unsigned int max_nframes = 128;
static unsigned int nframes = 0;
static unsigned int time0;
static unsigned int height = 128;
static unsigned int width = 128;
//#define PPM_BIT (1 << 0)
//#define LIBPNG_BIT (1 << 1)
//#define FFMPEG_BIT (1 << 2)
//static unsigned int output_formats = PPM_BIT | LIBPNG_BIT | FFMPEG_BIT;

/* Model. */
//static double angle;
//static double delta_angle;



}; // namespace


#define PPM_BIT (1 << 0)
#define LIBPNG_BIT (1 << 1)
#define FFMPEG_BIT (1 << 2)
#define TIFF_BIT (1 << 3)



template <class Tr>
class mjm_glut_saver 
{
 typedef mjm_glut_saver Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

enum Constants { SCREENSHOT_MAX_FILENAME = 256 };


typedef mjm_string_kvp<Tr> StrKvp;
typedef mjm_string_base_params<Tr> BaseParams;

class _save_params  
{
enum {BAD=~0};
public:
_save_params(const StrTy & s)
{
BaseParams sk(s);
# if FFMPEG
m_codec_id=AV_CODEC_ID_MPEG1VIDEO;
#else
m_codec_id=BAD;
#endif
MM_ERR(MMPR2(m_codec_id,AV_CODEC_ID_MPEG1VIDEO))
offscreen=0;
// output_formats = PPM_BIT | LIBPNG_BIT | FFMPEG_BIT;
output_formats=0;
m_fps=30;
m_width=128;
m_height=128;
m_stuffer=3;
manual_start=false;
sk.get(m_fn_mpeg,"mpeg_name");
sk.get(m_codec_id,"mpeg_codec_id");
sk.get(m_fps,"fps");
sk.get(m_width,"width");
sk.get(m_height,"height");
sk.get(output_formats,"output_formats");
sk.get(manual_start,"manual");
sk.get(m_stuffer,"stuffer");
{ bool x=false; sk.get(x,"mpeg"); if (x) output_formats|=FFMPEG_BIT; } 
{ bool x=false; sk.get(x,"ppm"); if (x) output_formats|=LIBPNG_BIT; } 
{ bool x=false; sk.get(x,"png"); if (x) output_formats|=PPM_BIT; } 
{ bool x=false; sk.get(x,"tiff"); if (x) output_formats|=TIFF_BIT; } 
sk.get(offscreen,"offscreen");
}

_save_params()
{
offscreen=0;
  output_formats=0;
manual_start=false;
 output_formats = PPM_BIT | LIBPNG_BIT | FFMPEG_BIT|TIFF_BIT;
m_codec_id=BAD;
m_fps=30;
m_width=128;
m_height=128;
}
void cancel_capture() { output_formats=0; } 
void start_mpeg_capture(const StrTy & fn ) { 
if (fn.length()) m_fn_mpeg=fn; 
output_formats|=FFMPEG_BIT; } 

//ffmpeg_encoder_start("tmp.mpg", AV_CODEC_ID_MPEG1VIDEO, 25, width, height);
IdxTy offscreen;
IdxTy output_formats;
StrTy m_fn_mpeg;
IdxTy m_codec_id,m_fps,m_width,m_height,m_stuffer;
bool manual_start;
}; // _save_params  
// API
public:
mjm_glut_saver() {Init();}
~mjm_glut_saver() {}

typedef _save_params  save_params_type;
enum SIGNALS {STOP_CAPTURE=0, START_CAPTURE=1,PAUSE_CAPTURE };
// non functrional easy way to get linker to look for everything 
int main(int argc, char **argv) { return  Main(argc, argv);} 
IdxTy display(const save_params_type & sp){ return Display(sp); } 
#if MJMTIFF 
IdxTy save_tiff(const StrTy & sin, const IdxTy flags)
{ return SaveTiff(sin,flags); } 
#endif
void start_capture(){ signal(Sig(START_CAPTURE));  } 
void stop_capture(){ signal(Sig(STOP_CAPTURE));  } 
void pause_capture(){ signal(Sig(PAUSE_CAPTURE),1);  } 
IdxTy signal(const IdxTy sig,const bool toggle=false) { return Signal(sig,toggle); } 
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
IdxTy Sig(const IdxTy b) { return 1<<b; } 
void Set( IdxTy& f, const IdxTy b)   { f|=(1<<b); }
void Reset(IdxTy& f, const IdxTy b)   { f&= ~(1<<b); }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

#if PPM
/* Take screenshot with glReadPixels and save to a file in PPM format.
 *
 * -   filename: file path to save to, without extension
 * -   width: screen width in pixels
 * -   height: screen height in pixels
 * -   pixels: intermediate buffer to avoid repeated mallocs across multiple calls.
 *     Contents of this buffer do not matter. May be NULL, in which case it is initialized.
 *     You must `free` it when you won't be calling this function anymore.
 */
void screenshot_ppm(const char *filename, unsigned int width,
        unsigned int height, GLubyte **pixels) {
    size_t i, j, cur;
    const size_t format_nchannels = 3;
    FILE *f = fopen(filename, "w");
    fprintf(f, "P3\n%d %d\n%d\n", width, height, 255);
    *pixels = (GLubyte*)realloc((GLubyte*)*pixels, format_nchannels * sizeof(GLubyte) * width * height);
	//glReadBuffer(GL_BACK);
	glReadBuffer(GL_FRONT);
    glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, *pixels);
    for (i = 0; i < height; i++) {
        for (j = 0; j < width; j++) {
            cur = format_nchannels * ((height - i - 1) * width + j);
            fprintf(f, "%3d %3d %3d ", (*pixels)[cur], (*pixels)[cur + 1], (*pixels)[cur + 2]);
        }
        fprintf(f, "\n");
    }
    fclose(f);
}
#endif


#if MJMTIFF 
// int w=glutGet(GLUT_WINDOW_WIDTH);

void GetPixels()
{
    const size_t format_nchannels = 3;
 int w=glutGet(GLUT_WINDOW_WIDTH);
 int h=glutGet(GLUT_WINDOW_HEIGHT);
   pixels = (GLubyte*)realloc((GLubyte*)pixels, format_nchannels * sizeof(GLubyte) * w * h);

	glReadBuffer(GL_FRONT);
    glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, pixels);

} // GetPixels

IdxTy SaveTiff(const StrTy & sin, const IdxTy flags)
{ 
GetPixels();


return 0; 
}  //SaveTiff

void screenshot_tiff(const char *filename, unsigned int width,
        unsigned int height, GLubyte **pixels) {
    size_t i, j, cur;
    const size_t format_nchannels = 3;
    //FILE *f = fopen(filename, "w");
//    fprintf(f, "P3\n%d %d\n%d\n", width, height, 255);
    *pixels = (GLubyte*)realloc((GLubyte*)*pixels, format_nchannels * sizeof(GLubyte) * width * height);
	//glReadBuffer(GL_BACK);
	glReadBuffer(GL_FRONT);
    glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, *pixels);

    TIFF *tif = TIFFOpen(filename, "w");
// goog ai generated.. 
   if (!tif) {
        // Handle error: file could not be opened
		MM_ERR(" cant open tiff "<<MMPR(filename))
        return ;
    } 
int bitsPerSample=8; // 24;
int samplesPerPixel=3; // 1;
    // Set essential TIFF tags
    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);
    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);
    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerSample);
    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, samplesPerPixel);
//    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric);
    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT); // Top-left origin
    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); // Chunky organization
    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE); // No compression

    // Create sample pixel data (e.g., a simple gradient)
const IdxTy bw=width*samplesPerPixel;
    uint8* scanline = new uint8[bw]; // width * samplesPerPixel];
    for (uint32 y = 0; y < height; ++y) {
        for (uint32 x = 0; x < bw; ++x) {
            scanline[x] = (*pixels)[x+bw*y] ; //  static_cast<uint8>((x + y) / 2); // Simple gradient
        }
        // Write the scanline to the TIFF file
        if (TIFFWriteScanline(tif, scanline, y, 0) < 0) {
            // Handle error: scanline could not be written
			MM_ERR(" writing tiff error "<<MMPR4(y,filename,width,height))
            TIFFClose(tif);
            delete[] scanline;
            return ;
        }
    }

    // Close the TIFF file and free resources
    TIFFClose(tif);
    delete[] scanline;


}
#endif // MJmTIFF





#if LIBPNG
/* Adapted from https://github.com/cirosantilli/cpp-cheat/blob/19044698f91fefa9cb75328c44f7a487d336b541/png/open_manipulate_write.c */

 void screenshot_png(const char *filename, unsigned int width, unsigned int height,
        GLubyte **pixels, png_byte **png_bytes, png_byte ***png_rows) {
    size_t i, nvals;
    const size_t format_nchannels = 4;
    FILE *f = fopen(filename, "wb");
    nvals = format_nchannels * width * height;
    *pixels =(GLubyte*) realloc(*pixels, nvals * sizeof(GLubyte));
    *png_bytes =(png_byte*) realloc(*png_bytes, nvals * sizeof(png_byte));
    *png_rows = (png_byte**) realloc(*png_rows, height * sizeof(png_byte*));
	//glReadBuffer(GL_BACK);
	glReadBuffer(GL_FRONT);
    glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, *pixels);
    for (i = 0; i < nvals; i++)
        (*png_bytes)[i] = (*pixels)[i];
    for (i = 0; i < height; i++)
        (*png_rows)[height - i - 1] = &(*png_bytes)[i * width * format_nchannels];
    png_structp png = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
    if (!png) abort();
    png_infop info = png_create_info_struct(png);
    if (!info) abort();
    if (setjmp(png_jmpbuf(png))) abort();
    png_init_io(png, f);
    png_set_IHDR(
        png,
        info,
        width,
        height,
        8,
        PNG_COLOR_TYPE_RGBA,
        PNG_INTERLACE_NONE,
        PNG_COMPRESSION_TYPE_DEFAULT,
        PNG_FILTER_TYPE_DEFAULT
    );
    png_write_info(png, info);
    png_write_image(png, *png_rows);
    png_write_end(png, NULL);
    png_destroy_write_struct(&png, &info);
    fclose(f);
}
#endif
#if FFMPEG
/* Adapted from: https://github.com/cirosantilli/cpp-cheat/blob/19044698f91fefa9cb75328c44f7a487d336b541/ffmpeg/encode.c */
 void ffmpeg_encoder_set_frame_yuv_from_rgb(uint8_t *rgb) {
    const int in_linesize[1] = { 4 * c->width };
    sws_context = sws_getCachedContext(sws_context,
            c->width, c->height, AV_PIX_FMT_RGB32,
            c->width, c->height, AV_PIX_FMT_YUV420P,
            0, NULL, NULL, NULL);
    sws_scale(sws_context, (const uint8_t * const *)&rgb, in_linesize, 0,
            c->height, frame->data, frame->linesize);
}
IdxTy  ffmpeg_encoder_start(const save_params_type  & sp ) {
//ffmpeg_encoder_start("tmp.mpg", AV_CODEC_ID_MPEG1VIDEO, 25, width, height);

return ffmpeg_encoder_start(sp.m_fn_mpeg.c_str(),( AVCodecID )sp.m_codec_id,sp.m_fps,sp.m_width,sp.m_height ); 
} // ffmpeg_encode_start

IdxTy  ffmpeg_encoder_start(const char *filename, AVCodecID codec_id, int fps, int width, int height) {
    const AVCodec *codec;
    int ret;
#ifndef IS_FFMPEG_DEP
    avcodec_register_all();
#endif

    codec = avcodec_find_encoder(codec_id);
    if (!codec) {
//        fprintf(stderr, "Codec not found\n");
//        exit(1);
	MM_ERR(" codec no found "<<MMPR(codec_id)) 
	throw "bad codec ";

    }
    c = avcodec_alloc_context3(codec);
    if (!c) {
        fprintf(stderr, "Could not allocate video codec context\n");
        MM_ERR( "Could not allocate video codec context"<<MMPR(codec))
		throw " existing mpeg start ";
      //  exit(1);
    }
    c->bit_rate = 400000;
    c->width = width;
    c->height = height;
    c->time_base.num = 1;
    c->time_base.den = fps;
    c->gop_size = 10;
    c->max_b_frames = 1;
    c->pix_fmt = AV_PIX_FMT_YUV420P;
    if (codec_id == AV_CODEC_ID_H264)
        av_opt_set(c->priv_data, "preset", "slow", 0);
    if (avcodec_open2(c, codec, NULL) < 0) {
        fprintf(stderr, "Could not open codec\n");
        exit(1);
    }
    file = fopen(filename, "wb");
    if (!file) {
        fprintf(stderr, "Could not open %s\n", filename);
		throw " existing mpeg start ";
        //exit(1);
    }
    frame = av_frame_alloc();
    if (!frame) {
        fprintf(stderr, "Could not allocate video frame\n");
		throw " existing mpeg start ";
        //exit(1);
    }
    frame->format = c->pix_fmt;
    frame->width  = c->width;
    frame->height = c->height;
    ret = av_image_alloc(frame->data, frame->linesize, c->width, c->height, c->pix_fmt, 32);
    if (ret < 0) {
        fprintf(stderr, "Could not allocate raw picture buffer\n");
		throw " existing mpeg start ";
        //exit(1);
    }
m_mpeg_state=1;
MM_ERR(" mpeg codec started ")
return 0; 
}


IdxTy ffmpeg_encoder_finish(void) {
if (m_mpeg_state==0)
{
MM_ERR(" mpeg alrady fniished doh")
return 0;
}
// this may be some kind of flush but pkt needs to be inited. 
if (!false) {
    uint8_t endcode[] = { 0, 0, 1, 0xb7 };
    int got_output=0, ret;
    do {
        fflush(stdout);
    av_init_packet(&pkt);
        ret = my_avcodec_encode_video2(c, pkt, NULL, got_output);
        if (ret < 0) {
            fprintf(stderr, "Error encoding frame\n");
            MM_ERR("Error encoding frame"<<MMPR(ret));
			throw "";
//            exit(1);
        }
        if (got_output) {
            fwrite(pkt.data, 1, pkt.size, file);
            av_packet_unref(&pkt);
        }
    } while (got_output);
    fwrite(endcode, 1, sizeof(endcode), file); } // false
    fclose(file);
    avcodec_close(c);
    av_free(c);
    av_freep(&frame->data[0]);
    av_frame_free(&frame);
m_mpeg_state=0;
return 0;
}

// https://stackoverflow.com/questions/59470927/how-to-replace-avcodec-encode-audio2-avcodec-encode-video2-with-avcodec-send
// fucking deprectaed fucker
    //ret = my_avcodec_encode_video2(c, &pkt, frame, &got_output);
        //ret = avcodec_encode_video2(c, &pkt, NULL, &got_output);
        int   my_avcodec_encode_video2( AVCodecContext* c, 
AVPacket & pkt, AVFrame * frame, int & got_output)
{
int ret = avcodec_send_frame(c, frame);
if (ret < 0) {
    fprintf(stderr, "Error sending a frame for encoding\n");
    exit(1);
}
while (ret >= 0) {
    ret = avcodec_receive_packet(c, &pkt);
    if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF){
        return (ret==AVERROR(EAGAIN)) ? 0:1;
     }
    else if (ret < 0) {
        fprintf(stderr, "Error during encoding\n");
        exit(1);
    }
// this is an audio assfuck
//    ret = write_frame(oc, &c->time_base, ost->st, &pkt);
//    if (ret < 0) {
//       fprintf(stderr, "Error while writing video frame: %s\n", av_err2str(ret));
//       exit(1);
//    }
    av_packet_unref(&pkt);
}
return (frame) ? 0 : 1;
}
///////////////////////////////////////////////////////
void ffmpeg_encoder_encode_frame(uint8_t *rgb) {
    int ret, got_output=0;
    ffmpeg_encoder_set_frame_yuv_from_rgb(rgb);
    av_init_packet(&pkt);
    pkt.data = NULL;
    pkt.size = 0;
    ret = my_avcodec_encode_video2(c, pkt, frame, got_output);
    if (ret < 0) {
        fprintf(stderr, "Error encoding frame\n");
        exit(1);
    }
    if (got_output) {
        fwrite(pkt.data, 1, pkt.size, file);
        av_packet_unref(&pkt);
    }
}


void ffmpeg_encoder_glread_rgb(uint8_t **rgb, GLubyte **pixels, unsigned int width, unsigned int height) {
    size_t i, j, k, cur_gl, cur_rgb, nvals;
    const size_t format_nchannels = 4;
    nvals = format_nchannels * width * height;
    *pixels =(GLubyte*) realloc(*pixels, nvals * sizeof(GLubyte));
    *rgb =( GLubyte*) realloc(*rgb, nvals * sizeof(uint8_t));
    /* Get RGBA to align to 32 bits instead of just 24 for RGB. May be faster for FFmpeg. */
	glReadBuffer(GL_FRONT);
    glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, *pixels);
    for (i = 0; i < height; i++) {
        for (j = 0; j < width; j++) {
            cur_gl  = format_nchannels * (width * (height - i - 1) + j);
            cur_rgb = format_nchannels * (width * i + j);
            for (k = 0; k < format_nchannels; k++)
                (*rgb)[cur_rgb + k] = (*pixels)[cur_gl + k];
        }
    }
}


#endif

 void init(void)  {
    int glget;

    if (offscreen) {
        /*  Framebuffer */
        glGenFramebuffers(1, &fbo);
        glBindFramebuffer(GL_FRAMEBUFFER, fbo);

        /* Color renderbuffer. */
        glGenRenderbuffers(1, &rbo_color);
        glBindRenderbuffer(GL_RENDERBUFFER, rbo_color);
        /* Storage must be one of: */
        /* GL_RGBA4, GL_RGB565, GL_RGB5_A1, GL_DEPTH_COMPONENT16, GL_STENCIL_INDEX8. */
        glRenderbufferStorage(GL_RENDERBUFFER, GL_RGB565, width, height);
        glFramebufferRenderbuffer(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, rbo_color);

        /* Depth renderbuffer. */
        glGenRenderbuffers(1, &rbo_depth);
        glBindRenderbuffer(GL_RENDERBUFFER, rbo_depth);
        glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, width, height);
        glFramebufferRenderbuffer(GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rbo_depth);

        glReadBuffer(GL_COLOR_ATTACHMENT0);

        /* Sanity check. */
        assert(glCheckFramebufferStatus(GL_FRAMEBUFFER));
        glGetIntegerv(GL_MAX_RENDERBUFFER_SIZE, &glget);
        assert(width < (unsigned int)glget);
        assert(height < (unsigned int)glget);
    } else {
        glReadBuffer(GL_BACK);
    }

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glEnable(GL_DEPTH_TEST);
    glPixelStorei(GL_PACK_ALIGNMENT, 1);
    glViewport(0, 0, width, height); 
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glMatrixMode(GL_MODELVIEW);

    time0 = glutGet(GLUT_ELAPSED_TIME);
//    model_init();
#if FFMPEG
    ffmpeg_encoder_start("tmp.mpg", AV_CODEC_ID_MPEG1VIDEO, 25, width, height);
#endif
}
#if 0 
void deinit(void)  {
    printf("FPS = %f\n", 1000.0 * nframes / (double)(glutGet(GLUT_ELAPSED_TIME) - time0));
    free(pixels);
#if LIBPNG
    if (output_formats & LIBPNG_BIT) {
        free(png_bytes);
        free(png_rows);
    }
#endif
#if FFMPEG
    if (output_formats & FFMPEG_BIT) {
        ffmpeg_encoder_finish(); free(rgb);
    }
#endif
    if (offscreen) {
        glDeleteFramebuffers(1, &fbo);
        glDeleteRenderbuffers(1, &rbo_color);
        glDeleteRenderbuffers(1, &rbo_depth);
    }
} 
#endif

// return 1 to stop capture confirm 
IdxTy  Display(const save_params_type  & sp ) {
    char filename[SCREENSHOT_MAX_FILENAME];
    //draw_scene();
bool finish_mpeg=false;
EnterSerial(0);
if (Bit(m_signal,STOP_CAPTURE)){ finish_mpeg=true;
Reset(m_signal,STOP_CAPTURE); }
ExitSerial(0);
if (finish_mpeg)
{

ffmpeg_encoder_finish(); 
free(rgb);
rgb=0;
//EnterSerial(0);
//Reset(m_signal,STOP_CAPTURE);
//ExitSerial(0);
// doh
//m_signal=0; // TODO maybe just reset this bit 
return 1;
}

    if (sp.offscreen) { glFlush(); } else {/* glutSwapBuffers();*/ }
#if PPM
    if (sp.output_formats & PPM_BIT) {
        snprintf(filename, SCREENSHOT_MAX_FILENAME, "tmp.%d.ppm", nframes);
        screenshot_ppm(filename, sp.m_width, sp.m_height, &pixels);
    }
#endif
#if MJMTIFF 
    if (sp.output_formats & TIFF_BIT) {
        snprintf(filename, SCREENSHOT_MAX_FILENAME, "tmp.%d.tiff", nframes);
        screenshot_tiff(filename, sp.m_width, sp.m_height, &pixels);
    }
#endif



#if LIBPNG
    if (sp.output_formats & LIBPNG_BIT) {
        snprintf(filename, SCREENSHOT_MAX_FILENAME, "tmp.%d.png", nframes);
        screenshot_png(filename, sp.m_width, sp.m_height, &pixels, &png_bytes, &png_rows);
    }
#endif
# if FFMPEG
    if (sp.output_formats & FFMPEG_BIT) {
   	if (m_mpeg_state==0)
{  

EnterSerial(0);
	if (sp.manual_start) if(!Bit(m_signal,START_CAPTURE)) 
	{ ExitSerial(0); return 0; }
	if (sp.manual_start) if(Bit(m_signal,START_CAPTURE))  
		Reset(m_signal, START_CAPTURE) ;
	ExitSerial(0);
MM_ERR(" starting mpeg capture "<<MMPR2(sp.manual_start,m_signal))
	ffmpeg_encoder_start(sp);    
}
EnterSerial(0);
bool paused=Bit(m_signal,PAUSE_CAPTURE);	
ExitSerial(0);
if (!paused)
{
	  frame->pts = nframes;
// stuffer must be nonzero doh 
//++nframes;
        ffmpeg_encoder_glread_rgb(&rgb, &pixels, sp.m_width, sp.m_height);
MM_ILOOP(dummy, sp.m_stuffer) {frame->pts=nframes;    ffmpeg_encoder_encode_frame(rgb); ++nframes; } 
} // paused 
	MM_STATUS(" x to stop, mpeg frame "<<MMPR2(paused, nframes))   
 }
else if (m_mpeg_state!=0){ ffmpeg_encoder_finish(); free(rgb); } 
#endif
//    nframes++;
return 0; 
//    if (model_finished()) exit(EXIT_SUCCESS);
}

int Main(int argc, char **argv) {
    int arg;
    GLint glut_display;

    /* CLI args. */
    glutInit(&argc, argv);
    arg = 1;
    if (argc > arg) {
        offscreen = (argv[arg][0] == '1');
    } else {
        offscreen = 1;
    }
    arg++;
    if (argc > arg) {
        max_nframes = strtoumax(argv[arg], NULL, 10);
    }
    arg++;
    if (argc > arg) {
        width = strtoumax(argv[arg], NULL, 10);
    }
    arg++;
    if (argc > arg) {
        height = strtoumax(argv[arg], NULL, 10);
    }
    arg++;
    if (argc > arg) {
       // output_formats = strtoumax(argv[arg], NULL, 10);
    }

    /* Work. */
    if (offscreen) {
        /* TODO: if we use anything smaller than the window, it only renders a smaller version of things. */
        /*glutInitWindowSize(50, 50);*/
        glutInitWindowSize(width, height);
        glut_display = GLUT_SINGLE;
    } else {
        glutInitWindowSize(width, height);
        glutInitWindowPosition(100, 100);
        glut_display = GLUT_DOUBLE;
    }
    glutInitDisplayMode(glut_display | GLUT_RGBA | GLUT_DEPTH);
    glutCreateWindow(argv[0]);
    if (offscreen) {
        /* TODO: if we hide the window the program blocks. */
        /*glutHideWindow();*/
    }
    init();
// these wont work due to static  
//    glutDisplayFunc(display);
// this is nonfunctional no
//    glutIdleFunc(idle);
//    atexit(deinit);
    glutMainLoop();
    return EXIT_SUCCESS;
}
IdxTy Signal(const IdxTy sig,const bool toggle) 
{ 
EnterSerial(0);
//if (Bit(sig,STOP_CAPTURE) { m_signal|=STOP_CAPTURE; } // STOP_CAPTURE
if (!toggle) m_signal|=sig;
else
{
//if (m_signal&sig) m_signal&= ~sig; else m_signal|=sig;
m_signal^=sig;
}
ExitSerial(0);
return 0; // Signal(sig); 

} // Signal  
void Init()
{
m_mutex_vector=MutexVector(3);
m_signal=0;
#if FFMPEG
rgb=0;
m_mpeg_state=0;
sws_context=0;
c=0;
#endif
pixels=0;
max_nframes=10000;
nframes=0;
height=128;
width=129; 
}; // Init

// MEMBERS
IdxTy m_signal;

GLubyte *pixels; //  = NULL;
GLuint fbo;
GLuint rbo_color;
GLuint rbo_depth;
int offscreen = 1;
unsigned int max_nframes; //  = 128;
 unsigned int nframes; //  = 0;
 unsigned int time0;
unsigned int height ; //  = 128;
unsigned int width; //  = 128;
//static unsigned int output_formats = PPM_BIT | LIBPNG_BIT | FFMPEG_BIT;




#if LIBPNG
png_byte *png_bytes; //  = NULL;
png_byte **png_rows; //  = NULL;
#endif

#if FFMPEG

 AVCodecContext *c; //  = NULL;
 AVFrame *frame;
 AVPacket pkt;
 FILE *file;
 struct SwsContext *sws_context; //  = NULL;
 uint8_t *rgb ; //  = NULL;
IdxTy m_mpeg_state;
#endif



}; // mjm_glut_saver

//////////////////////////////////////////////

template <class Tr>
class mjm_glut_saver_map : public std::map<typename Tr::StrTy, mjm_glut_saver< Tr > >  
{
 typedef mjm_glut_saver_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_glut_saver< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_glut_saver_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_glut_saver_map




////////////////////////////////////////////
#ifdef  TEST_MJM_GLUT_SAVER
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_glut_saver <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_GLUT_SAVER "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_glut_saver<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="main") { MM_ERR(x.main(argc,args)) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_GLUT_SAVER_H__ 
