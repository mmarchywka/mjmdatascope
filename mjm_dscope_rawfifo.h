 //  cpputil rename on Mon 05 Jun 2023 09:45:03 AM EDT from mjm_dscope_pktfifo to mjm_dscope_rawfifo
 //  cpputil rename on Mon May 1 08:51:15 EDT 2023 from mjm_dscope_dgram to mjm_dscope_rawfifo
#ifndef MJM_DSCOPE_RAWFIFO_H__
#define MJM_DSCOPE_RAWFIFO_H__


#ifndef APP_VERSION
#define APP_VERSION 0
#endif

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_pthread_que.h"
#include "mjm_read_buffer.h"

#include "mjm_collections.h"
#include "mjm_canned_methods.h"
#include "mjm_string_kvp.h"
#include "mjm_so_loader.h"
#include "mjm_dscope_serial.h"
// needs this for negotiating fifo name etc 
// using control ports 
// #include "mjm_dscope_dgram.h"
// no idea where to put this... 
#include "mjm_buffer_alloc.h"



#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>

#include <ctime>
#include <chrono>
#include <iostream>


// https://www.geeksforgeeks.org/udp-server-client-implementation-c/

#include <bits/stdc++.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
   
//#define PORT     8080
//#define MAXLINE 1024


// Client side implementation of UDP client-server model
#include <bits/stdc++.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
   
#define PORT     8080
#define MAXLINE 1024
   
/*
Use a fifo for input to dscope but preserve non-blocking
dropping easier to support >64k scenes  for now. 
Retain the datagram feel and use the control port to
find active servers and pick a fifo name or agree
manually. 

*/


// Wed Mar 15 17:28:50 EDT 2023
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_dscope_rawfifo   
// QUICKCOMPILE g++  -Wall -std=gnu++11 -DTEST_MJM_DSCOPE_RAWFIFO -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_dscope_rawfifo.h  -o mjm_dscope_rawfifo.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_dscope_rawfifo("mjm_dscope_rawfifo"
, "  ");

template <class Tr>
class mjm_dscope_rawfifo 
{
 typedef mjm_dscope_rawfifo Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
typedef mjm_thread_util<Tr> ThreadTy;
typedef pthread_t ThreadId; 

typedef mjm_string_kvp<Tr> StrKvp;
typedef mjm_so_loader<Tr> Loader;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line ;
typedef mjm_read_buffer<Tr> RdBuf;
typedef mjm_dscope_serial<Tr> Serializer;

typedef mjm_string_base_params<Tr> BaseParams;
enum {BAD=~0};

typedef unsigned char Data;



//typedef mjm_pthread_que<Tr,Payload> PktQue;
typedef mjm_pthread_que<Tr,StrTy> RawQue;

public:
// API 
typedef Data data_type;
mjm_dscope_rawfifo() {Init(); }
~mjm_dscope_rawfifo() {Free();}
void debug(const IdxTy d) { m_debug=d; }
IdxTy send(const Ragged & r, const IdxTy flags=0) {return Send(r,flags); } 
// needs to be part of abstracted interace, better to setup a 
// header and body without merging... 
IdxTy send(const Ragged & rh,const Ragged & rb, const IdxTy flags=0) 
{return Send(rh,rb,flags); } 
bool send_note() const { return false;} 
bool read_note() const { return false;} 
bool full() const  { return m_sq.full(); } // not const due to mutex but mutable? 
bool empty() const  { return m_sq.empty(); } // not const due to mutex but mutable? 
IdxTy get( Ragged & r, const IdxTy flags=0) {return Get(r,flags); } 
StrTy*  next(const IdxTy flags=0 ) {return Next(flags); } 
// general purpose io
IdxTy send(const StrTy & s , const IdxTy flags=0) {return Send(s,flags); } 
IdxTy get( StrTy & s, const IdxTy flags=0) {return Get(s,flags); } 

IdxTy launch(const StrTy& s, const IdxTy flags )
{ return  Launch( s,  flags ); } 
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
static bool Bit(const IdxTy f, const IdxTy b)  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;
//enum{ASCII_RAG=267};
enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mux.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mux.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
// don't pass this, need to put it somewhere safe, 
class ThParam
{
public:
ThParam() :p(0),flags(0) {}
Myt * p;
StrTy s;
IdxTy flags;
typedef IdxTy (Myt:: * pFunc)(const StrTy & s,const IdxTy flags );
pFunc func;

}; // ThParam
IdxTy Launch(const StrTy& s, const IdxTy flags )
{ // the parameter here is a kluge anyway just ignore 
ThParam *  tp = new ThParam() ;
//StrTy * sp= new StrTy(s);
tp->s=s;
tp->p=this;
tp->flags=flags;
ThreadId * dest=0;
tp->func=&Myt::Start;
IdxTy sw=flags&15;
switch (sw)
{
case 0: { dest=&m_cc; tp->func=&Myt::StartControlClient; break; }
case 1: { dest=&m_cs; tp->func=&Myt::StartControlServer; break; }
case 2: { dest=&m_dc; tp->func=&Myt::StartDataClient; break; }
case 3: { dest=&m_ds; tp->func=&Myt::StartDataServer; break; }
default:
MM_ERR(" no function "<<MMPR4(flags,sw,s,__FUNCTION__))
}// switch 
// this needs to know what kind of thread it is,
// duplicate logic lateer.. 
ThreadId thread=ThreadTy::launch(& Myt::_Launch,tp);
*dest=thread;
// wait upto a second or two for display to draw 
return 0;
}
static void *  _Launch( void * x) { ThParam * tp =(ThParam*)x; 
Myt * p = tp->p; StrTy s=tp->s; IdxTy flags=tp->flags;  
auto pFunc=tp->func;
delete tp;  
//p->Start(s,flags); 
(p->*pFunc)(s,flags); 

return 0; }
IdxTy StartControlClient(const StrTy & s,const IdxTy flags )
{
IdxTy rc=0;
MM_ERR(MMPR2(__FUNCTION__,flags))
BaseParams sk(s);

return rc;
} // StartControlClient

IdxTy StartControlServer(const StrTy & s,const IdxTy flags )
{
IdxTy rc=0;
MM_ERR(MMPR2(__FUNCTION__,flags))
BaseParams sk(s);

return rc;
} // StartControlServer
IdxTy Send(const Ragged & r, const IdxTy flags=0)
{
//IdxTy rc=0;
Ss ss; ss<<r.dump_ssv_unsafe(); 
//MM_ERR(MMPR(ss.str()))
//MM_DIE(" ok here ")
if (false){  MM_ERR(" SENDING "<< MMPR2(r.size(),ss.str())) }
return Send(ss.str(),flags); 
} // Send
IdxTy Send(const Ragged & rh,const Ragged & rb, const IdxTy flags=0) 
{
// bit zed used by sendguard need better stff kk 
const bool deb=Bit(flags,1);
const bool dump=Bit(flags,2);
Ss ss; ss<<rh.dump_ssv_unsafe(); 
ss<<rb.dump_ssv_unsafe(); 
if (dump) MM_ERR(MMPR(ss.str()))
if (deb){  MM_ERR(" SENDING "<< MMPR3(rh.size(),rb.size(),ss.str().length())) }
return Send(ss.str(),flags); 
} // Send 
IdxTy Send(const StrTy  & s, const IdxTy flags=0)
{
IdxTy rc=0;
StrTy * p= new StrTy(s);
m_sq.push(p);
if ( send_note()) { MM_ERR(MMPR3(__FUNCTION__,s.length(),m_sq.size())) }
//MM_ERR(" queeded pkt to send "<<MMPR2(m_sq.size(),pload->size()))
return rc;
} // Send 
StrTy * Next( const IdxTy flags=0) { return m_rq.next(); } 
IdxTy Get( StrTy & s, const IdxTy flags=0)
{
IdxTy rc=0;
StrTy *  pload =m_rq.next(); //  new Payload(&m_s);
try { 
if (!pload) return BAD;
s=StrTy(*pload); // ->payload,pload.size());
} catch (...) { MM_ERR(" error in Get ") } 
MM_ERR(MMPR3(__FUNCTION__,s.length(),m_rq.size()))
delete pload;
return 0;
} // Get
IdxTy Get( Ragged & r, const IdxTy flags=0)
{
IdxTy rc=0;
//Ss ss;
//ss<<r.dump_ssv();
//MM_ERR(MMPR2(__FUNCTION__,m_rq.size()))
StrTy *  pload =m_rq.next(); //  new Payload(&m_s);
try { 
if (!pload) return BAD;
StrTy s=StrTy(*pload); // ->payload,pload.size());
Ss ss(s);
//r.load(ss);
r.load_stop(ss,">FILE");
if (false) { MM_ERR("GETTT "<< MMPR2(r.size(),r.dump_ssv())) } 
} catch (...) { MM_ERR(" error in Get ") } 
if (m_debug) MM_ERR(MMPR2(__FUNCTION__,r.size()))
delete pload;
//MM_ERR(" queeded pkt to send "<<MMPR2(m_sq.size(),pload->size()))
return rc;
} // Get 





// FIXME doh put this somwhere lol 
typedef mjm_canned_methods SHTT;
int myatoi(const StrTy & s ) const { return SHTT::myatoi(s.c_str()); }
int myatoi(const char * c) const { return SHTT::myatoi(c); }

IdxTy StartDataClient(const StrTy & s,const IdxTy flags )
{
IdxTy rc=0;
MM_ERR(MMPR2(__FUNCTION__,flags))
BaseParams sk(s);
StrTy fifo_name=m_default_fifo_name; // "/tmp/datascope_fifo.txt";
int mode=7+7*8+7*64; // lol 
//const IdxTy blocksz=1<<18;
signal(SIGPIPE, SIG_IGN);   
sk.get(fifo_name,"fifo_name");
 int fifo_rc=mkfifo( fifo_name.c_str(),mode);
int fd=0;
    MM_ERR(" fifo send started  "<<MMPR(fifo_rc)<<MMPR4(fd,rc,fifo_name,mode));
while (true)
{       

//MM_ERR("  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA getting nex t");
//Payload *  pload = m_sq.next();
// only peek do not pop until sent.. 
StrTy *  pload = m_sq.next(true);
if (read_note()) { MM_ERR(MMPR2(__FUNCTION__,(*pload).size())) } 
//MM_ERR(" AAAAAAAAAAAAAAAAAAAAAAAAAAA have next "<<MMPR(pload));
// should never have to pop a null but let queue do that 
if (pload==0){ m_sq.pop();  break;  }
try{ 
fd=open(fifo_name.c_str(),O_WRONLY);
IdxTy wrrc=write(fd,pload->c_str(),pload->length()+1);
if (false) MM_ERR(MMPR(wrrc))

} catch (...) { MM_ERR(" caught something "<<MMPR(__FUNCTION__))}

m_sq.pop();
if (false) MM_ERR(" sento "<<MMPR(rc));
 delete pload;
close(fd); 
} // true
MM_ERR(" leaving "<<MMPR(__FUNCTION__))  
  //  close(sockfd);

return rc;
} // StartDataClient

IdxTy StartDataServer(const StrTy & s,const IdxTy flags )
{
IdxTy rc=0;
IdxTy dumb=0;
MM_ERR(MMPR2(__FUNCTION__,flags))
BaseParams sk(s);
bool notify_data=false;
StrTy fifo_name=m_default_fifo_name; // "/tmp/datascope_fifo.txt";
int mode=7+7*8+7*64; // lol 
const IdxTy blocksz=1<<18;
sk.get(fifo_name,"fifo_name");

 int fifo_rc=mkfifo( fifo_name.c_str(),mode);
int fd=0;
fd = open(fifo_name.c_str(), O_RDONLY|O_NONBLOCK);
    MM_ERR(" fifo server "<<MMPR(fifo_rc)<<MMPR4(fd,rc,fifo_name,mode));
 

RdBuf rd;
char * p= new char[blocksz];
     while (true) {   
rd.clear();
try { 
while (true)
{
int n=read(fd, p, blocksz);
// this needs to take the zero or cap it later? 
//if (n>0){ bool br=false; if ( p[n-1]==0){  br=true; n=n-1; }    rd.append(p,n); if (br) break; } 
if (n>0)
	{ 
		bool br=false; 
		if ( p[n-1]==0){  br=true; n=n-1+1; }    
		rd.append(p,n); 
		if (br) break; 
	} 
if (n==0) usleep(1000);
if ( notify_data) { if (n>0) MM_ERR(MMPR3(__FUNCTION__,n,rd.size())) } 
if (n<0){ MM_ERR(MMPR(n))  break; }
} // true
} catch (...)
{
MM_ERR(" fifo read throws ") 

}
if (m_debug) MM_ERR(" have string "<< MMPR2(__FUNCTION__,rd.size()))
if (rd.size())
{
StrTy * pload= new StrTy(rd.buf()); 
//MM_ERR(MMPR((*pload)))
//MM_DIE(" ok or no")
m_rq.push(pload);
// need to prune m_rq from front ...
} else
{ 
++dumb;
MM_ERR(" dumb sleep "<<MMPR(dumb))
//usleep(2000000);
usleep(200);
}

} // truel 
delete[] p;
close(fd);
 MM_ERR("SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSexit" << MMPR(__FUNCTION__))       
return rc;
} // StartDataServer







//static IdxTy _Start(const StrTy & s ) { return p()->Start(s); }
IdxTy Start(const StrTy & s,const IdxTy flags )
{
IdxTy rc=0;
MM_ERR(MMPR2(__FUNCTION__,flags))
BaseParams sk(s);

return rc;
} // Start


void Init()
{
m_debug=0;
m_mux=MutexVector(5);
 m_default_fifo_name="/tmp/datascope_fifo.txt";
m_cs=0;
m_ds=0;
m_cc=0;
m_dc=0;
m_sq.limit(20);
m_rq.limit(20);
} // Init
void Free()
{

} // Free

// MEMBERS
IdxTy m_debug;
MutexVector m_mux;
ThreadId m_cs,m_cc,m_ds,m_dc;
Serializer m_s;
RawQue m_sq,m_rq;
StrTy m_default_fifo_name;// fifo_name="/tmp/datascope_fifo.txt";
}; // mjm_dscope_rawfifo

//////////////////////////////////////////////

template <class Tr>
class mjm_dscope_rawfifo_map : public std::map<typename Tr::StrTy, mjm_dscope_rawfifo< Tr > >  
{
 typedef mjm_dscope_rawfifo_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_dscope_rawfifo< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_dscope_rawfifo_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_dscope_rawfifo_map




////////////////////////////////////////////
#ifdef  TEST_MJM_DSCOPE_RAWFIFO
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_dscope_rawfifo <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_DSCOPE_RAWFIFO "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_dscope_rawfifo<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//if (cmd=="xxx") { MM_ERR(xxxmain()) }
//if (cmd=="yyy") { MM_ERR(yyymain()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_DSCOPE_RAWFIFO_H__ 
