#ifndef MJM_AI_ROOT_WTAP_H__
#define MJM_AI_ROOT_WTAP_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "gemini_root_finder.cpp"
#include "mjm_dscope_interface.h"

//#include "mjm_block_matrix.h"
#include "mjm_instruments.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_worm_blob.h"
#include "mjm_collections.h"
//#include "mjm_tokenized_collections.h"
#include "mjm_canned_methods.h"

#include "mjm_pawnoff.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_generic_iterators.h"



#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


/*
<one line to give the program's name and a brief idea of what it does.>


Conceived and written by Mike Marchywka from 2025 to present.
See dates in individual code pieces as they were 
generated from my wizards. 
Copyright (C) <year> <name of author>


This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
@software{,
  author = {Michael J Marchywka},
  city = {Talking Rock GA 30175 USA},
  title = {},
abstract={},
institution={},
license={Knowledge sir should be free to all },
publisher={Mike Marchywka},
email={marchywka@hotmail.com},
authorid={orcid.org/0000-0001-9237-455X},
  filename={mjm_ai_root_wtap.h},
  url = {},
  version = {0.0.0},
  date-started={2025-07-24},
}
*/

// Thu 24 Jul 2025 07:06:21 AM EDT
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_ai_root_wtap   
// QUICKCOMPILE  g++  -MMD -MF mjm_ai_root_wtap.deps  -Wall -Wno-misleading-indentation -Wno-use-after-free -Wno-overloaded-virtual  -std=gnu++20 -DTEST_MJM_AI_ROOT_WTAP -I. -I../../mjm/hlib -I../../mjm/num -I../datascope  -gdwarf-3 -O3  -x c++ mjm_ai_root_wtap.h  -o mjm_ai_root_wtap.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_ai_root_wtap("mjm_ai_root_wtap" , "  ");

template <class Tr>
class mjm_ai_root_wtap 
{
 typedef mjm_ai_root_wtap Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

// TYPEDEF 
enum { BAD=~0};
//typedef mjm_canned_methods Canned;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map<StrTy, Ragged> RaggedMap;
typedef std::vector<StrTy> Words;

typedef mjm_dscope_interface<Tr> Dscope;
typedef typename Dscope::simple_point_t Point;

typedef std::vector<Point> Points;



typedef mjm_string_base_params<Tr> BaseParams;

typedef gemini_root_ns::Polynomial GemPoly;

// API

public:
mjm_ai_root_wtap() {Init(); }
mjm_ai_root_wtap(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
mjm_ai_root_wtap(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}

void load(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
void load(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}
void save(const StrTy & fn,const StrTy &s) {Save(fn,s); }

StrTy xxx_test(const StrTy & sin, const IdxTy flags) 
{ return XXX_test(sin,flags); } 
~mjm_ai_root_wtap() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
D atof(const StrTy & s) const { return ::atof(s.c_str()); } 
int myatoi(const StrTy & s )const   { return mjm_canned_methods::myatoi(s.c_str()); }
int myatoi(const char * c) const  { return mjm_canned_methods::myatoi(c); }
static bool Bit(const IdxTy f, const IdxTy b) { return  ((f>>b)&1)!=0; }
// should loop over map now 
static void Set(IdxTy& f, const IdxTy b,const bool x) //const  
    { if (x) f|=(1<<b); else f&=((~1)<<b); }
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


void Save(const StrTy & fn,const StrTy &s) {
// std::ofstream ofs(fn);

 } // Save
StrTy XXX_test(const StrTy & sin, const IdxTy flags) 
{
StrTy sout="";
MM_ERR(MMPR3(sin,flags,sout))
BaseParams kvp(sin);
StrTy test="";
kvp.get(test,"test");
if (test=="gemini") Gemini(sin,flags); 
if (test=="delay") DelayHarmonic(sin,flags); 
if (test=="load") LoadRag(sin,flags); 
return sout;
} // XXX_test
StrTy LoadRag(const StrTy & sin, const IdxTy flags) 
{

BaseParams kvp(sin);
StrTy fn="";
StrTy name="";

kvp.get(fn,"fn");
kvp.get(name,"name");
m_map[name].load(fn);
MM_ERR(MMPR3(fn,name,m_map[name].size()))
return StrTy();
} // LoadRag
StrTy DelayHarmonic(const StrTy & sin, const IdxTy flags) 
{
Ss ss;
BaseParams kvp(sin);
StrTy name;
D omega=1;
D frac=2;
IdxTy color=(1<<16)-1;
// samplng interval
D dtxpi=.001;
int shift=0;
IdxTy der=2;
D tol=1e-7;
D epsilon=1e-9;
kvp.get(name,"ragged");
kvp.get(dtxpi,"dtxpi");
kvp.get(frac,"frac");
kvp.get(shift,"shift");
kvp.get(omega,"omega");
kvp.get(der,"der");
kvp.get(tol,"tol");
kvp.get(color,"color");
kvp.get(epsilon,"epsilon");
D dt=dtxpi*2*M_PI; 
D delay=frac*M_PI/dt;
IdxTy delayi=int(delay+.5+shift);

//dt=dt*M_PI;
{ Ss sscolor; sscolor<<std::hex<<color;  
MM_ERR(MMPR4(name,dtxpi,dt,delay)<<MMPR4(der,delayi,frac,shift)<<MMPR3(epsilon,tol,sscolor.str())) } 
gemini_root_ns::set_noise_floor(epsilon) ;
GemPoly gp;
// omega2 is 1, delta is point spacing and delay is
// number of samples delay 
//D d2=delta*delta;
//gp.add_term(n,{r,im});
// the current term
D dtomega=1;
MM_ILOOP(i,der) { dtomega=dtomega*dt; }
//gp.add_term(0,{dt*dt,0});
gp.add_term(0,{::pow(dt,der),0});
// plus delayed second dir is zero
// now use der to calculate this crap
int coef=1;
int sign=1;
int offs=der>>1;
MM_ILOOP(_i,(der+1))
{
int i=_i;

// TODO sub sample delay is based on linear interpolation

if (sign>0) gp.add_term(delayi+(offs-i),{D(coef),0});
else gp.add_term(delayi+(offs-i),{D(-coef),0});

MM_ERR(MMPR4((offs-i),coef,sign,i));
coef=CursingBinomial(coef,der,i);
sign=-sign;
} // cursing
//gp.add_term(delayi+1,{1,0}); //gp.add_term(delayi-1,{1,0}); //gp.add_term(delayi,{-2,0});

IdxTy npts=360;
ShowRoots(gp,tol,color);
AddUnitCircle(npts);
//AddAnalytic(der,delayi+(offs-der),dt*dt);
const D deltheta=.00001*M_PI/D(delayi+D(offs)-D(der));
//const D deltheta=.001*dt*dt;

// default fcking parm FCK 
//AddAnalytic(der,delayi+(offs-der),deltheta);
AddAnalytic(der,delayi+(offs-der),dt*dt, deltheta);

{ Ss ss; SendPoints(ss.str()); }
gp.print();
MM_ERR(MMPR4(name,dtxpi,dt,delay)<<MMPR3(delayi,frac,shift))

return ss.str();

} // DelayHarmonic
int CursingBinomial(const int last, const int n, const int k)
{

D wtf= last*(n-k)/(k+1);
if (wtf!=IdxTy(wtf))  { MM_ERR(MMPR4((wtf-IdxTy(wtf)),last,n,k))}
return last*(n-k)/(k+1);

}// CursingBinomial

void ShowRoots(GemPoly & gp, const D & tol=1e-7,const IdxTy & color=(1<<16)-1)
{


MM_ERR(" poluy ") 
gp.print();
typedef std::complex<double>  ZD;
typedef std::vector<ZD> ZVec;

/*
std::vector<std::complex<double>> find_all_roots(
    Polynomial p, // Pass by value to allow modification (deflation)
    double tolerance = 1e-7,
    int max_iterations = 1000,
    int num_initial_guesses_per_root = 20,
    double guess_range = 10.0


*/

ZVec roots=gemini_root_ns::find_all_roots(gp,tol,2000,50,10.0);
m_points.clear();
IdxTy imax=BAD;
D rmax=0;
std::vector<IdxTy> iunstable;
MM_ILOOP(i,roots.size())
{
D r=std::abs(roots[i]);
if (r>rmax) { imax=i; rmax=r; } 
if (r>1) iunstable.push_back(i);
MM_ERR(MMPR3(i,roots[i],r))
//m_points.push_back(Point(0,.2,0,(255<<8)|126));
m_points.push_back(Point(roots[i].real(),roots[i].imag(),0,color));
m_points.back().sz(10);
} // i  
MM_ERR(" unstable" <<MMPR(iunstable.size()))

MM_ILOOP(_i,iunstable.size())
{
IdxTy i=iunstable[_i];
D r=std::abs(roots[i]);
MM_ERR(MMPR3(i,roots[i],(r-1.0)))
}

if (imax!=IdxTy(BAD))
{
MM_ERR(" bggest "<<MMPR3(roots[imax].real(),roots[imax].imag(),rmax));

} // rmax

} // ShowRoots

StrTy Gemini(const StrTy & sin, const IdxTy flags) 
{
Ss ss;
BaseParams kvp(sin);
StrTy name;
kvp.get(name,"ragged");
MM_ERR(MMPR(name))
GemPoly gp;

const Ragged & r =m_map[name];
MM_ILOOP(i,r.size())
{
const Line & l=r[i];
const IdxTy len=l.size();
if (len<2) continue;
IdxTy n=0;
D r=atof(l[1]);
D im=(len>2)?atof(l[2]):0;
n=myatoi(l[0]);
gp.add_term(n,{r,im});
} // i 
//MM_ERR(MMPR(gp.print()));
ShowRoots(gp);


const IdxTy npts=300;
AddUnitCircle(npts);

{ Ss ss; SendPoints(ss.str()); }
//Polynomial p3;
  //  p3.add_term(100, {1.0, 0.0}); // 1 * x^100
  //  p3.add_term(5, {1.0, 0.0});   // 1 * x^5
  //  p3.add_term(0, {-2.0, 0.0});  // -2 * x^0
   // std::cout << "Polynomial: "; p3.print();
//    std::vector<std::complex<double>> roots3 = find_all_roots(p3, 1e-7, 2000, 50, 5.0); // Adjusted parameters
//    std::cout << "Roots found (" << roots3.size() << "):" << std::endl;
//    for (const auto& root : roots3) {
//        std::cout << "  " << root << std::endl;
//    }

return ss.str();
} // Gemini

/*

not analytic but  a speciliazed search.
The equation of interest is (z-1)^n z^m + g^n =0 
where g is actually gamma= omega *dt ; 
Define w=z-1=s*exp(i Omega ) and
end up with n Omega = -m Theta + pi 
and the positive radii error of  delta= s^n-gamma^n r^(-m) 
Tan and Cot are used to get y/x and y/(x-1) but there is
quadran confusion with this.  Go to sin/cos crap but should
be able to do the check with vector addition lol. 

*/

// ./mjm_ai_root_wtap.out  "test test=load;fn=gempol.txt;name=foo" "test test=delay;dtxpi=.02;frac=3;fhift=10;der=2;tol=1e-12;epsilon=1e-12;color=0xffffff" quit 2>
void AddAnalytic(const int der,const int delayi,const D &dt2, const D & deltheta=1e-5)
{
// again it would have been better to put these in a small param struct
// to keep sigs stable as params change.. 
//const IdxTy npts=delayi;
const int n=der;
const int m=delayi;
//const D rpow=D(n)/D(m);
const D anf=D(m)/D(n);
const D offa=M_PI/D(n);
// fortunately this was never used here doh 
//const D pfac=(D(n)*M_PI)/D(n-m);
const D pfac=(D(n)*M_PI)/(D(n)-D(m));
const D gamma=sqrt(dt2);
const D a=::pow(gamma,D(n));
MM_ERR(MMPR4(der,delayi,dt2,pfac))


//MM_DIE("fucj")
// apparently making n passes to get conjugates as
// Omega changes phase. 
IdxTy npts=1+D(n)*2.0*M_PI/deltheta; 
MM_ERR(MMPR3(npts,n,deltheta))
D lastdelta=0;
IdxTy pts=0;
MM_ILOOP(i,npts)
{
const D theta=D(i)*deltheta; // pfac*(D(i)+.5);
D x,y;
/*
const D Omega=-anf*theta+offa;
const D c1=::tan(theta);
const D c2=::tan(Omega);
const D x=1.0/(c2-c1);
const D y=c1*x;
const D r2=x*x+y*y;
const D s2=r2+1-2*x;
const D delta=::pow(s2,D(n)/2)-a*::pow(r2,-D(m)/2);
*/
bool ok=false;
const D delta=Eval(x,y,theta,a,anf,offa,n,m,ok);
// could get exactly zero ROFL 
if (((lastdelta*delta<0)||(delta==0))&&ok)
{
++pts;
//MM_ERR(MMPR4(i,theta,delta,lastdelta)<<MMPR4(x,y,pts,m_points.size()))
if (false)
{
D dd=delta-lastdelta; // hopefully linear ROFL
D f2=delta/dd;
//D f1=1.0-f2;
//D thetanew=f1*theta+f2*(theta-deltheta);
D thetanew=theta-f2*(deltheta);
D xnew,ynew;
Eval(xnew,ynew,thetanew,a,anf,offa,n,m,ok);
m_points.push_back(Point(xnew,ynew,0,255<<8));
} // false
else
{
if (delta==0) { m_points.push_back(Point(x,y,0,255<<8)); }
else
{
D thetah=theta;
D thetal=thetah-deltheta;
D deltah=delta;
D deltal=lastdelta;
D thetanew=(thetah+thetal)*.5;
D xnew,ynew;
IdxTy max=40;
IdxTy iter=0;
D thetatol=1e-12;
while (thetah-thetal>thetatol)
{
const D deltanew=Eval(xnew,ynew,thetanew,a,anf,offa,n,m,ok);
//MM_ERR(MMPR4(deltanew,deltah,deltal,iter)<<MMPR3((thetah-theta),(thetal-theta),theta))
if (	deltanew==0 ) break;
if (deltanew*deltah>0) { deltah=deltanew; thetah=thetanew; }
else{ deltal=deltanew; thetal=thetanew; }
thetanew=(thetah+thetal)*.5;
++iter;
if (iter>=max)
{
MM_ERR(MMPR4(thetah,thetal,(thetah-thetal),deltanew)<<MMPR2(deltah,deltal))
break;
} // iter
} // theta
//D dd=deltah-deltal; // hopefully linear ROFL
//D f2=deltanew/dd;
//D f1=1.0-f2;
//D thetanew=thetal+f2*(thetah-thetal);
//D xnew,ynew;
//Eval(xnew,ynew,thetanew,a,anf,offa,n,m);
m_points.push_back(Point(xnew,ynew,0,0x0ffff<<0));
} // delta != 0 
} // true

m_points.back().sz(25);
}  
//if (ok) 
lastdelta=delta;
//const D tnm=theta*m/n;
//m_points.push_back(Point(r*ct,r*st,0,255<<4));
//m_points.back().sz(5);
} // i 
if ((int(n)-int(m))&1) {
D xzed=xz(gamma,n,m);
m_points.push_back(Point(xzed,0,0,0x0ffff<<0));
m_points.back().sz(25);
}

MM_ERR(MMPR4(der,delayi,dt2,pfac)<<MMPR3(n,m,npts))
} // AddAnalytic
D xz( const D & gamma, const int n, const int m)
{
const D tol=1e-12;
const D g=::pow(gamma,n);
D xz=1;
D x1=100;
D x2=0;
IdxTy iter=0;
while (true)
{
D xs=::pow(xz+1,n);
D xr=g*::pow(xz,-m);
if (fabs(xs-xr)<tol) break;
//MM_ERR(MMPR4(x1,x2,xr,xs)<<MMPR(xz))
if ( xs>xr) x1=xz; else x2=xz;
xz=.5*(x2+x1);
++iter;
if (iter>100) break;
}
return -xz;
}// xz

bool Oor(const D & theta)
{
const D ovf=.25*M_PI;
const D center=.5*M_PI;
// thetat positive, mod 2pi for this to work.. 
const D dc=theta-center;
const bool p1=((dc<ovf)&&(dc>-ovf));
const D dc3=theta-3*center;
const bool p3=((dc3<ovf)&&(dc3>-ovf));
return p1||p3;
} // Oor
IdxTy Quadrant(const D & theta)
{
// 	save and easy but slow wtf
const D x=::cos(theta);
const D y=::sin(theta);
return ((x<0)?1:0)+((y<0)?2:0); 

} // Quadrant

bool Quadrant(D & x, D & y, const D & theta)
{
//if (true) return false; 
bool rc=false;
//const D tn=theta/M_PI; if (tn>.5) if ( tn<1.5) if (x>0) { x=-x; y=-y;} 
const D tn=theta/M_PI; 
const bool negx=(tn>.5)&&(tn<1.5);
//if (tn>.5) if ( tn<1.5) if (x>0) {rc=true;  x=-x; y=-y;} 
if (negx) if (x>0) {rc=true;  x=-x; y=-y;} 

// WTF compiler should flag this ROFL.
//if (tn<.5) if ( tn>1.5) if (x<0) {rc=true;  x=-x; y=-y;} 
if (!negx) if (x<0) {rc=true;  x=-x; y=-y;} 
return rc;

} // Quadrant
bool Isect(D & x, D &y, const D & theta, const D & Omega)
{
const D c1=::cos(theta);
const D c2=::cos(Omega);
const D s1=::sin(theta);
const D s2=::sin(Omega);
// something is wrong here never mind sn==0 fck 
//const D r=fabs(s2/(c1*s2-c2*s1));
const D r=(s2/(c1*s2-c2*s1));
const D s=s1/(c1*s2-c2*s1);
//x=(c1*r+c2*s+1)*.5;
x=(c1*r);
y=(s1*r); 

if (s1*s2<=0) return false;
if ((s<0)||(r<0)) return false; 
return true;
} // Isect
void IsectFck(D & x, D &y, const D & theta, const D & Omega)
{
const bool toor=Oor(theta);
const bool ooor=Oor(Omega);
bool quad=false;
if (!toor&&ooor) {
const D c1=::tan(theta);
const D d2=::cos(Omega)/::sin(Omega);
x=1.0/(1.0-d2*c1);
y=c1*x;
quad=Quadrant(x,y,theta);

}
else if (toor&&!ooor) {
const D d1=::cos(theta)/::sin(theta);
const D c2=::tan(Omega);
x=d1*c2/(c2*d1-1);
y=x/d1;
quad=Quadrant(x,y,theta);

}
else if (toor&&ooor) {
const D d1=::cos(theta)/::sin(theta);
const D d2=::cos(Omega)/::sin(Omega);
y=1.0/(d1-d2);
x=d1*y;
quad=Quadrant(x,y,theta);
}
else if (!toor&&!ooor)
{
const D c1=::tan(theta);
const D c2=::tan(Omega);
x=c2/(c2-c1);
y=c1*x;
quad=Quadrant(x,y,theta);
}

MM_ERR(MMPR4(theta,Omega,x,y)<<MMPR3(toor,ooor,quad))
} // IsectFck

D Eval(D & x, D &y, const D & theta, const D & a, const D & anf, const D & offa, const IdxTy n, const IdxTy m, bool & ok)
{
D tx=theta;
while (tx>=2*M_PI) {tx-=2*M_PI; } 
D Omega=-anf*tx+offa;
tx=theta;
while (tx>=2*M_PI) {Omega+=2*M_PI/n; tx-=2*M_PI; } 
// this helped some and hurt others ... doh 
//while (Omega>=2*M_PI) { Omega-=2*M_PI; } 
//while (Omega<0) { Omega+=2*M_PI; } 
ok=Isect(x,y,theta,Omega);
if (!ok) return 0;
const D r2=x*x+y*y;
const D s2=r2+1-2*x;
//const D delta=::pow(s2,D(n)/2)-a*::pow(r2,-D(m)/2);
const D r=sqrt(r2);
const D s=sqrt(s2);
const D delta=cheap_pow(s,n)-a/cheap_pow(r,m);
// could get exactly zero ROFL 
return delta;

} // Eval
// TODO need to look at accuracy of (1+d)^m with small d and large m
D cheap_pow(const D & b, const IdxTy n)
{
//MM_ERR(MMPR2(b,n))
if (n==0) return 1;
if (n==1) return b;
if (n==2) return b*b;
IdxTy nlog=n;
std::vector<D> pows;
pows.push_back(b);
// b^1,b^2,b^4,b^8 etc 
// if n==8, nlog=8,4,2,1
while (nlog>1)  { pows.push_back(pows.back()*pows.back()); nlog>>=1; } 
nlog=n;
D res=1;
IdxTy p=0;
while (nlog)  {if (nlog&1) res=res*pows[p]; ++p;  nlog>>=1; } 


return res;
} // cheap_pow

// this may have been based on something similar but not worth
// trying to figure out  
void AddAnalyticWTF(const int der,const int delayi,const D &dt2)
{
const IdxTy npts=delayi;
const int n=der;
const int m=delayi;
const D rpow=D(n)/D(m);
// denominator can't work 
const D pfac=(D(n)*M_PI)/(n-m);
MM_ERR(MMPR4(der,delayi,dt2,pfac))
//MM_DIE("fucj")
MM_ILOOP(i,npts)
{
const D theta=pfac*(D(i)+.5);
const D tnm=theta*m/n;
const D st=::sin(theta);
const D ct=::cos(theta);
D r=(ct*ct>.5)?(::cos(tnm)/ct):(::sin(tnm)/st);
r=::pow(r,rpow);
MM_ERR(MMPR4(i,pfac,r,theta))
m_points.push_back(Point(r*ct,r*st,0,255<<4));
m_points.back().sz(5);
}
MM_ERR(MMPR4(der,delayi,dt2,pfac))


} // AddAnalyticWTF




void AddUnitCircle(IdxTy npts)
{
MM_ILOOP(i,npts)
{
const D theta=M_PI*2*i/npts;
m_points.push_back(Point(::cos(theta),::sin(theta),0,255<<16));
m_points.back().sz(10);
}


} // AddUnitCircle


// TODO this should be intersgrated into dscope interface by now
bool SendPoints(const StrTy & params=StrTy())
{
const bool wait_on_full=true;
IdxTy cnt=0;
if (wait_on_full)
{ while (m_dscope.que_full()) {++cnt;  usleep(10000); }   }
else {
MM_ERR(" wtf ")
if (m_dscope.que_full()) return false;  }
if (cnt) MM_ERR(MMPR2(cnt,m_dscope.que_full()))
Ragged r;
//StrTy params="";
const StrTy ty="ornate-points";
const StrTy sid="orbit_test";
m_dscope.setup(r,sid,ty,params);
// orbit
//const D sz=.05;
// r-theta aurve 
///const D sz=.01;
//const D szd=1.0/::log(m_points.size())*log(10.0);
//const D sz=.15*szd*szd;
MM_LOOP(ii,m_points)
{
Line l;
r.add(l);
const auto & p=(*ii);
///const StrTy c="#FFFFFF";
//const StrTy c=m_d_scope.theta_color(p.theta()); // "#FFFFFF";
const StrTy c=m_dscope.to_color(p.rgb()); // "#FFFFFF";
const StrTy shape="point"; // p.shape(); // "circle";
//r<<p.x()<<p.y()<<"0"<<sz<<c<<shape;
// TODO need also interface for 2-d points etc 
//r<<p.x()<<p.y()<<p.z()<<sz<<c<<shape;
r<<p.x()<<p.y()<<p.z()<<p.sz()<<c<<shape;
//MM_ERR(MMPR((*ii).dump()))
} // ii 
m_dscope.send(r,0);
if (false) MM_ERR(MMPR(r.dump_ssv()));
m_points.clear();
usleep(1000);
return true;
} // send_points




void Init(const Ragged & r, const IdxTy start=0, const IdxTy first=0, const IdxTy flags=0  )
{
Init();
const IdxTy sz=r.size();
for(IdxTy i=start; i<sz; ++i)
{
//const Line & l=r[i];
//const IdxTy len=l.size();


}  // i 

} // Init 
void Init(const StrTy  & sin,const IdxTy flags =0  )
{
Init();
BaseParams kvp(sin);
} // Init 

void Init()
{

m_dscope.launch_default();
} // Init



// MEMBERS
RaggedMap m_map;
Dscope m_dscope;
Points m_points;

}; // mjm_ai_root_wtap

//////////////////////////////////////////////

template <class Tr>
class mjm_ai_root_wtap_map : public std::map<typename Tr::StrTy, mjm_ai_root_wtap< Tr > >  
{
 typedef mjm_ai_root_wtap_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_ai_root_wtap< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_ai_root_wtap_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{


}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_ai_root_wtap_map




////////////////////////////////////////////
#ifdef  TEST_MJM_AI_ROOT_WTAP
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_ai_root_wtap <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;

#define CI(n) atoi(cip.wif(n).c_str()) 

void about()
{
Ss ss;
ss<<" MJM_AI_ROOT_WTAP "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_MSG(ss.str())

}
typedef mjm_ragged_table Ragged;

#define CIP(n) atoi(cip.wif(n).c_str())
#define CFP(n) atof(cip.wif(n).c_str())

int main(int argc,char **args)
{
about();
typedef mjm_ai_root_wtap<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="loadragged") {
 	const IdxTy start=atoi(cip.wif(2).c_str()); 
	const IdxTy first=atoi(cip.wif(3).c_str()); 
	const IdxTy flags=atoi(cip.wif(4).c_str()); 
Ragged r; r.load(cip.p1); x.load(r,start,first,flags); }
if (cmd=="load") {x.load(cip.p1,atoi(cip.p2.c_str())); }
if (cmd=="save") {x.save(cip.p1,cip.p2); }
if (cmd=="test") {StrTy xxx=x.xxx_test(cip.p1,CIP(2)); MM_ERR(MMPR(xxx))  }
if (cmd=="quit") break;
// NB this does not work in gneral when errors are disabled
//if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="dump") { auto wtf=x.dump();  MM_ERR(wtf) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_AI_ROOT_WTAP_H__ 
