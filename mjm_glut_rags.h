#ifndef MJM_GLUT_RAGS_H__
#define MJM_GLUT_RAGS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_strings.h"
#include "mjm_index_buffer.h"
#include "mjm_tokenized_points.h"
#include "mjm_vector_shapes.h"
#include "mjm_svg_render.h"
#include "mjm_collections.h"
#include "mjm_string_kvp.h"
#include "mjm_so_loader.h"
#include "mjm_glut_elements.h"
#include "mjm_glut_helpers.h"
#include "mjm_ff_mesh.h"
#include "mjm_worm_blob.h"

#include <freeglut.h>
#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Wed Mar 22 13:35:49 EDT 2023
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_glut_rags   
// g++  -Wall -std=gnu++11 -DTEST_MJM_GLUT_RAGS -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_glut_rags.h  -o mjm_glut_rags.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_glut_rags("mjm_glut_rags"
, "  ");

/*
Base class for display types probably should be virtual but
decent defaults can be made. 


*/

template <class Tr>
class mjm_glut_rags 
{
 typedef mjm_glut_rags Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef pthread_t ThreadId;
typedef mjm_thread_util<Tr> ThreadTy;

typedef GLfloat Gf;

typedef mjm_glut_helpers<Tr> GlutUtil;

typedef typename  GlutUtil::draw_info_t DrawInfo;
typedef typename  GlutUtil::key_info_t KeyInfo;
typedef typename  GlutUtil::ptr_info_t PtrInfo;
typedef typename  GlutUtil::view_info_t ViewInfo;
typedef typename  GlutUtil::junk_bin_t ModelInfo;
typedef typename  GlutUtil::color_t color_type;

typedef std::vector<color_type> ColorVec;




typedef mjm_string_kvp<Tr> StrKvp;
typedef mjm_string_base_params<Tr> BaseParams;
typedef mjm_so_loader<Tr> Loader;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line ;
// this should be in traits... 
enum {BAD=~0};

// TYPEDEFS

typedef std::vector<ModelInfo>  Models;
typedef mjm_ff_mesh<Tr> FFmesh;
typedef mjm_worm_blob<Tr,D> WORMBlob;

typedef Ragged InputType;
typedef IdxTy (Myt:: * p_add_fun_type ) (const InputType & r, const IdxTy flags) ; 
typedef std::map<StrTy, p_add_fun_type> AddMap;
// these are the points specified by user 
typedef mjm_tokenized_points<Tr> TokPoints; 
typedef typename TokPoints::PointEntry PointEntry;
typedef mjm_vector_shapes<Tr> Shapes;
typedef typename Shapes::shape_t Shape;
typedef typename Shapes::point_t Point;
typedef mjm_strings StrUtil;
typedef mjm_index_buffer<Tr,ModelInfo> ModelIndex;
typedef typename ModelIndex::pool_t pool_t;
//typedef mjm_svg_render<Tr> SvgRender;

public:
#define HAPIRC virtual IdxTy 
typedef InputType input_type;
// too long doh 
typedef typename  GlutUtil::draw_info_t scope_draw_param_type;
//typedef typename  GlutUtil::draw_info_t DrawInfo;
typedef typename  GlutUtil::key_info_t scope_key_param_type;
typedef typename  GlutUtil::ptr_info_t scope_ptr_param_type;
enum { UNHANDLED=BAD, IGNORED=0 };
// API 
mjm_glut_rags() {Init();}
mjm_glut_rags(const StrTy & src) {Init(src);}
const StrTy srcname() const { return m_src; } 
void  srcname(const StrTy & s ) { m_src=s; } 
void pool(pool_t * p ) { m_data_idx.pool(p); } 
~mjm_glut_rags() {}
ViewInfo& view() { return m_view; } 
// add a rag to the contents
IdxTy add(const input_type & r, const IdxTy flags) 
{ return Add(r,flags); } 
void clear() {
//ModelIndex 
m_data_idx.clear();

}
// changed flag needs draw lock lol 
IdxTy config_grat(const StrTy & x=StrTy()) { m_grat_config=x;  m_grat_changed=1; return 0; } 
IdxTy set_strip_color(const IdxTy n, const IdxTy idx, const D & r,
const D & g, const D & b)
{
ModelInfo&  m=m_data_idx(n);
m.set_strip_color(idx,r,g,b);
return 0; 
}



void event(const IdxTy e)
{
MM_ERR(MMPR2(__FUNCTION__,e))


} // event 
// view- really internal a response to input and used in draw. 

// draw 0 uses vew to render 
HAPIRC draw(scope_draw_param_type * sdp , const IdxTy flags) 
{
return Draw(sdp,flags); 

} 
// keys - modifies view usually 

// need to unify keys and "special keys or inputs "

// mouse - modifices view usually. 

HAPIRC reshape(GLint width, GLint height) { return IGNORED; }
//HAPIRC mouse_button(int button, int state, int x, int y) { return 0; }
//HAPIRC mouse_motion(int x, int y) { return 0; }
HAPIRC mouse_event(scope_ptr_param_type * spt, const IdxTy flags) 
{ return IGNORED; }
//HAPIRC animate_scene(void) {return 0;  
HAPIRC animate(const scope_draw_param_type * sdp , const IdxTy flags) 
{ return IGNORED; } 
//HAPIRC SelectFromMenu(int idCommand) { return 0; }
HAPIRC key_event(scope_key_param_type * skt, const IdxTy flags) 
{

return UNHANDLED;
} 
//HAPIRC special_input(int key, int x, int y) { return 0; } 
//HAPIRC keyboard(unsigned char key, int x, int y) {return 0; }


ModelInfo &amodel()
{
const IdxTy szd=m_data_idx.used();
for(IdxTy i=0; i<szd; ++i)
{
ModelInfo&  m=m_data_idx(i);
if (m.strip_d().size())  return m;
} 
return m_data_idx(0);
} // amodel





// save 

// load 

// short human readable info 
StrTy show(const IdxTy flags=0) { return Show(flags); }
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
protected:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;
ss<<m_view.dump();
//ss<<MMPR(m_data.size());
ss<<MMPR(m_data_idx.size());
  return ss.str(); }


StrTy Show(const IdxTy flags=0) {Ss ss;
const IdxTy szd=m_data_idx.used();
if (szd>1) { MM_ERR(" should only have one to append "<<MMPR2(szd,m_src))}
MM_ILOOP(i,szd)
{
ModelInfo&  m=m_data_idx(i);
ss<<m.show();
ss<<CRLF;
} // i 
return ss.str();
} // Show



typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
// this is supposed to be a base class... doh 
// maybe a delegate? 
IdxTy Add(const input_type & r, const IdxTy flags) 
{
if (Bit(m_debug,0)) MM_ERR(" Adding "<<MMPR(r.dump(0,"|",6))) 

const IdxTy sz=r.size();
if (sz<3)
{
MM_ERR(" received ragged too small "<<MMPR2(r.size(),r.dump()))
 return 0;
}
if (r[2].size()<2)
{
MM_ERR(" received ragged no name "<<MMPR3(r[2].size(),r.size(),r.dump()))
return 0; 

}
// 2025-02-21 bombing duing updates lol 
EnterSerial(0);
// line zero is a comment sort of 
// it has to be of form "# id ... srcname"
// where the last word is used for on-screen id etc. 
// id on line 1 
const StrTy ty=r[1][1];
//if (ty=="oscilloscope") return AddOscilloscope(r,flags);
//if (ty=="ffmesh") return AddFFmesh(r,flags);
const auto ii=m_add_map.find(ty);
p_add_fun_type p=0;
if (ii!=m_add_map.end())  p=(*ii).second;
if (p) (this->*p)(r,flags); 
else {
MM_ERR(" danger ignoring ragged "<<MMPR(r.dump()))
MM_ERR(" ignoring ragged "<<MMPR(ty))
if (true)  { ExitSerial(0); return ExplainReject(r,flags); } 
}
ExitSerial(0);
return 0;
} // Add
void MakeAddMap()
{
m_add_map["oscilloscope"]=&Myt::AddOscilloscope;
m_add_map["strip-chart"]=&Myt::AddStripChart;
m_add_map["ornate-points"]=&Myt::AddOrnate;
m_add_map["ffmesh"]=&Myt::AddFFmesh;
m_add_map["time-snap"]=&Myt::AddTimeSnap;
m_add_map["heatmap"]=&Myt::AddHeatmap;
m_add_map["svg"]=&Myt::AddSvg;
m_add_map["decorations"]=&Myt::AddDecorations;
m_add_map["molecule"]=&Myt::AddMolecule;


} // MakeAddMap

IdxTy ExplainReject(const input_type & r, const IdxTy flags) 
{
for(IdxTy i=0; i<r.size(); ++i)
{
const Line & l = r[i];
if (l.size()<1) continue;
if (l[0]!="#" ) continue;
Ss ss;
for(int j=1; j<l.size(); ++j)  ss<<l[j]<<" ";
MM_ERR(ss.str())
} // i 
return BAD;
} // ExplainReject


/*
{ Line l; l.push_back("#"); l.push_back("id"); l.push_back("test pattern chunks "); l.push_back(idn);  r.add(l); }
{ Line l; l.push_back("#"); l.push_back("oscilloscope"); l.push_back("chunks"); r.add(l); }

{ Line l; l.push_back("#"); l.push_back("trace"); Ss ss; ss<<line;  l.push_back(ss.str()); r.add(l); }
*/

#define ADDITOR  const IdxTy sz=r.size(); for(IdxTy i=0; i<sz; ++i) { const Line & l=r[i]; const IdxTy len=l.size(); if (len<1) continue; if (l[0]=="#") continue;  

#define ADDITORC  const IdxTy sz=r.size(); for(IdxTy i=0; i<sz; ++i) { const Line & l=r[i]; const IdxTy len=l.size(); if (len<1) continue;   

#define ADDBLOBITOR  const IdxTy sz=wb.size(); for(IdxTy i=0; i<sz; i+=wb.pitch()) {     

D atof(const StrTy & s) const { return ::atof(s.c_str()); } 
#if 0
// This should retain the model mesh for later view choices 
IdxTy AddFFmeshOldd(const input_type & r, const IdxTy flags) 
{
MM_ERR(" adding ffmesh" )
IdxTy rc=0;
FFmesh fmesh;
IdxTy startline=0;
MM_ILOOP(i,r.size())
{
if (i>10) break;
const Line& l=r[i];
const IdxTy len=l.size();
if (len<1) continue;
if (l[0].c_str()[0]!='#') { startline=i; break; }
const StrTy & cmd=l[1];
//if (cmd=="params"){   AddParams(mi,l,len); continue; }
//mi.add_params(l,2,len);
//if (cmd=="etc"){  mi.add_etc(l,2,len);  continue; }

MM_ERR(MMPR2(i,r.dump_line(i)))

} 
// add flag for extra_vertex_data as fespace values are on the vertex lines
//fmesh.read_ff_mesh(r,StrTy(),2,0);
fmesh.read_ff_mesh(r,StrTy(),startline,8);
// now make the model...
// TODO the source is recurring, need to save this thing... 
WORMBlob wb;
fmesh.get_mesh(wb,1);
IdxTy elsz=wb.pitch();
// assert that the size is 0 mod 6 lol.
const IdxTy szwb=wb.size();
const IdxTy leftover=szwb%elsz;
const IdxTy ntri=szwb/elsz;
MM_ERR(MMPR4(elsz,szwb,leftover,ntri));
ModelInfo mi;
mi.clear();
D xbase=0;
bool setx=false;
bool segs=true;
if (segs)
{
const IdxTy sz=wb.size(); 
for(IdxTy i=0; i<sz; i+=wb.pitch()) {     
mi.add_point(wb[i],wb[i+1],0);
mi.add_point(wb[i+2],wb[i+3],0);
mi.add_point(wb[i+2],wb[i+3],0);
mi.add_point(wb[i+4],wb[i+5],0);
mi.add_point(wb[i+4],wb[i+5],0);
mi.add_point(wb[i],wb[i+1],0);
} // ADDBLOBITOR 
mi.m_code=2;
}
else 
{
//  This needs to be locked if used.. 
//ViewInfo & v=m_view;
const IdxTy sz=wb.size(); for(IdxTy i=0; i<sz; i+=wb.pitch()) {     
mi.add_point(wb[i],wb[i+1],0);
mi.add_point(wb[i+2],wb[i+3],0);
mi.add_point(wb[i+4],wb[i+5],0);
} // ADDBLOBITOR 
mi.m_code=1;
mi.m_szlim=1;
} // not segs

MM_ERR(" done making mi for  adding ffmesh" )
AddNewModel(mi);
MM_ERR(" done adding new model   adding ffmesh" )

return rc;
} // AddFFmeshOld
#endif

// This should retain the model mesh for later view choices 
IdxTy AddFFmesh(const input_type & r, const IdxTy flags) 
{
MM_ERR(" adding ffmesh" )
IdxTy rc=0;
FFmesh fmesh;
IdxTy startline=0;
ModelInfo mi;
MM_ILOOP(i,r.size())
{
if (i>10) break;
const Line& l=r[i];
const IdxTy len=l.size();
if (len<1) continue;
MM_ERR(MMPR2(i,r.dump_line(i)))
if (l[0].c_str()[0]!='#') { startline=i; break; }
const StrTy & cmd=l[1];
if (cmd=="params"){   AddParams(mi,l,len); continue; }
//mi.add_params(l,2,len);
if (cmd=="etc"){  mi.add_etc(l,2,len);  continue; }
//if (r[i].size()<1) continue;
//if (r[i][0].c_str()[0]!='#') { startline=i; break; }
//MM_ERR(MMPR2(i,r.dump_line(i)))
} // i  
// add flag for extra_vertex_data as fespace values are on the vertex lines
//fmesh.read_ff_mesh(r,StrTy(),2,0);
//fmesh.read_ff_mesh(r,StrTy(),startline,8);
mi.ff_mesh().read_ff_mesh(r,StrTy(),startline,8);
mi.ff_mesh().compile();

MM_ERR(" done making mi for  adding ffmesh" )
AddNewModel(mi);
MM_ERR(" done adding new model   adding ffmesh" )
return rc;
} // AddFFmesh





void AddNames(ModelInfo & mi, const Line & l, const IdxTy len )
{
mi.add_names(l,2,len);

} // AddNames
void AddParams(ModelInfo & mi, const Line & l, const IdxTy len )
{
mi.add_params(l,2,len);

}// AddParams

void Rainbow(ColorVec & ct, const IdxTy flags)
{
//std::vector<color_type> ct;
ct.push_back(color_type(1,1,1));
ct.push_back(color_type(1,0,0));
ct.push_back(color_type(0,1,0));
ct.push_back(color_type(0,0,1));
ct.push_back(color_type(1,0,1));
ct.push_back(color_type(0,1,1));
} // Rainbow

IdxTy AddTimeSnap(const input_type & r, const IdxTy flags) 
{
IdxTy rc=0;
ModelInfo mi;
D xbase=0;
bool setx=false;

ColorVec ct;
Rainbow(ct,0);

//  This needs to be locked if used.. 
//ViewInfo & v=m_view;
//reject blank linkes but let comment through
ADDITORC
// params etc. 
if (l[0]=="#")
{
if (len<2) continue;
const StrTy & cmd=l[1];
if (cmd=="params"){   AddParams(mi,l,len); continue; } 
if (cmd=="names") {  AddNames(mi,l,len); continue; } 
MM_ONCE(" silently ignoring future comments like  "<<MMPR(cmd),)
continue;
}  // # 
// "x" is now in the last line entry doh 
 D x=atof(l[len-1]);
//if ( !setx){  xbase=x; setx=true; } 
x=x-xbase;
for(IdxTy j=0; j<(len-1) ; ++j)
{
const IdxTy seg=j;
const D y=atof(l[j]);
if (false) if (y>2) { MM_ERR("ydanger" << MMPR4(seg,i,y,x))
Ss ss; MM_LOOP(ii,l) { ss<<(*ii)<<" "; }
MM_ERR(" ydanger "<<MMPR(ss.str())) 
 } 
const D z=0; // (len>2)?atof(l[2]):0;
//MM_ERR(MMPR4(j,x,y,z))
//mi.add_seg(
mi.add_seg(seg,x,y,z,ct[j%ct.size()]);
} // j 

} // ADDITOR 

AddNewModel(mi);




return rc;
} // AddTimeSnap
IdxTy AddSvg(const input_type & r, const IdxTy flags) 
{

IdxTy sz=r.size();
if (sz<3) 
{
MM_ERR(" too few lines for svg file "<<MMPR(r.size()))
return BAD;
}
// should not be padded but just in case 
while (sz>2)
{
const Line & l=r[sz-1];
const IdxTy len=l.size();
if (len) break;
--sz; 
}
const Line & l=r[sz-1];
const IdxTy len=l.size();
if (len<1)
{
MM_ERR(" cant find svg "<<MMPR(sz))
return BAD;
}
const StrTy& data=l[len-1];
ModelInfo mi;
mi.add_svg(data);
AddNewModel(mi);
return 0;
} // AddSvg
IdxTy AddOrnate(const input_type & r, const IdxTy flags) 
{
//MM_ERR(" adding ornate "<<MMPR2(__FUNCTION__,r.size()))
// junk_bin
ModelInfo mi;
//ADDITOR
// parameters can include aging and fading subserquent ones... 
// TODO seg faiult assign probably no wrok 
//mi.m_ornate_points= typename ModelInfo::TokPoints(r,0,0,0);
mi.ornate_points().load(r,0,0,0);

ADDITORC
if (l[0]=="#")
{
if (len<2) continue;
const StrTy & cmd=l[1];
if (cmd=="params"){   AddParams(mi,l,len); continue; }
//mi.add_params(l,2,len);
if (cmd=="etc"){  mi.add_etc(l,2,len);  continue; }
//if (cmd=="names") {  AddNames(mi,l,len); continue; }
//MM_ONCE(" silently ignoring future comments like  "<<MMPR(cmd),)
//continue;
}  // # 
// TODO this can break here at the first non-hash line  maybe?
} // ADDITROC 
//if (cmd=="params"){   AddParams(mi,l,len); continue; } 
//MM_ERR(MMPR(mi.m_ornate_points.size()))
//} // ADDITOR
AddNewModel(mi);
return 0;
} // AddOrnate




IdxTy AddHeatmap(const input_type & r, const IdxTy flags) 
{
MM_ERR(" adding  "<<MMPR2(__FUNCTION__,r.size()))
// junk_bin
ModelInfo mi;
// this hangs wtf 
//MM_ERR(MMPR(r.dump_ssv()))
//ADDITOR
// parameters can include aging and fading subserquent ones... 
// TODO seg faiult assign probably no wrok 
//mi.m_ornate_points= typename ModelInfo::TokPoints(r,0,0,0);
//mi.m_ornate_points.load(r,0,0,0);
ExtractHdrInfo(mi,r,flags);
mi.load_heatmap(r,flags);
AddNewModel(mi);
return 0;
} // AddHeatmap

IdxTy ExtractHdrInfo(ModelInfo & mi,const input_type & r,const IdxTy flags )
{


ADDITORC
if (l[0]=="#")
{
if (len<2) continue;
const StrTy & cmd=l[1];
if (cmd=="params"){   AddParams(mi,l,len); continue; }
//mi.add_params(l,2,len);
if (cmd=="etc"){  mi.add_etc(l,2,len);  continue; }
//if (cmd=="names") {  AddNames(mi,l,len); continue; }
//MM_ONCE(" silently ignoring future comments like  "<<MMPR(cmd),)
continue;
}  // # 
break; // only parse headers here.. 
} // ADDITROC 
//if (cmd=="params"){   AddParams(mi,l,len); continue; } 
//MM_ERR(MMPR(mi.m_ornate_points.size()))
//} // ADDITOR

 return 0; 

} // ExtractHdrInfo

IdxTy AddDecorations(const input_type & r, const IdxTy flags) 
{
ModelInfo mi;
mi.m_src=m_src;
mi.m_type="decorations";
ExtractHdrInfo(mi,r,flags);
mi.add_decorations(r,flags);
AppendModel(mi,flags);
return 0;
} // AddDecorations
IdxTy AddMolecule(const input_type & r, const IdxTy flags) 
{
ModelInfo mi;
mi.m_src=m_src;
mi.m_type="molecule";
mi.add_molecule(r,flags);
AppendModel(mi,flags);
return 0;
} // AddMolecule



// paradigm is to make a new one and add it to existing ones
// at the end. This screws up point grouping but maybe is cleaner
// and avoids some lock times although more moving etc.
// try this intergrated approachhereh.. 
IdxTy AddStripChart(const input_type & r, const IdxTy flags) 
{
// using append is ok but it would just be cleaner to do that
//here... 
ModelInfo* mip=0;
bool new_model=false;
const IdxTy szd=m_data_idx.used();
if (szd==0) { mip=new ModelInfo(); new_model=true;}
else { mip=&m_data_idx(0); } 
ModelInfo & mi=*mip;
if (szd>1) { MM_ERR(" should only have one to append "<<MMPR2(szd,m_src))}
mi.m_src=m_src;
mi.m_type="strip-chart";
mi.add_strip(r,flags);
if (new_model){  m_data_idx.push_back(mi); delete mip; } 
//AppendModel(mi,flags);
return 0;
} // AddStripChart

IdxTy AddStripChartOld(const input_type & r, const IdxTy flags) 
{
// using append is ok but it would just be cleaner to do that
//here... 
ModelInfo mi;
mi.m_src=m_src;
mi.m_type="strip-chart";
mi.add_strip(r,flags);
/*
D xbase=0;
bool setx=false;
ADDITOR
 D x=atof(l[0]);
x=x-xbase;
const D y=atof(l[1]);
const D z=(len>2)?atof(l[2]):0;
mi.add_point(x,y,z);
} // ADDITOR 

*/
AppendModel(mi,flags);
return 0;
} // AddStripChartOld

IdxTy AddOscilloscope(const input_type & r, const IdxTy flags) 
{
ModelInfo mi;
D xbase=0;
bool setx=false;
//  This needs to be locked if used.. 
//ViewInfo & v=m_view;
ADDITOR
 D x=atof(l[0]);
//if ( !setx){  xbase=x; setx=true; } 
x=x-xbase;
const D y=atof(l[1]);
const D z=(len>2)?atof(l[2]):0;
//MM_ERR(MMPR3(x,y,z))
mi.add_point(x,y,z);
} // ADDITOR 

AddNewModel(mi);

return 0;
} // AddOscilloscope

// models are mde outside of queue and then added
// when done although this requires a copy it keeps
// out invalid and partials. 
IdxTy AddNewModel(ModelInfo & mi, const IdxTy flags=0)
{
// create an "add_back" or += operator for the 
// last one to combine sequential things for 
// a single plot 
m_data_idx.push_back(mi);

return 0;
} // AddNewModel


IdxTy AppendModel(ModelInfo & mi, const IdxTy flags=0)
{
const IdxTy szd=m_data_idx.used();
if (szd==0) { return AddNewModel(mi,flags); }
if (szd>1) { MM_ERR(" should only have one to append "<<MMPR2(szd,m_src))}
ModelInfo&  m=m_data_idx(0);
// the new strips etc have no idea how to integrate with the old
// only too fcking late
m.append_asfck(mi);


return 0;
} // AppendModel
#if 0 
ss<<MMPR(m_data_idx.size());
m_data_idx.push_back(mi);
const IdxTy szd=m_data_idx.used();
ModelInfo&  m=m_data_idx(i);
ModelInfo&  m=m_data_idx(szd-1);
m_data_idx.set_size(10);
ModelIndex m_data_idx;
#endif



#if 0 
EnterSerial(0);

m_data.push_back(mi);
IdxTy mdsz=m_data.size();
// This is dumb it is 
const IdxTy szlim=mi.m_szlim; // 10;
if (mdsz>szlim)
{ // TODO need a different data struct of make a circular buffer
// FIXME this is dum 
Models  _data;
if (m_debug) { MM_ERR(" trimming data stack "<<MMPR2(mdsz,szlim)) } 
// This is dumb too it needs to be a circular queue.. 
IdxTy sz=szlim;
while (sz) { _data.push_back(m_data[mdsz-sz]); --sz; } 
m_data=_data;
} // size
ExitSerial(0);

#endif 







// https://www.ece.lsu.edu/koppel/gpup/code/gpup/demo-4-simple-ogl.cc.html
void wtfmisc()
{
  glClearColor(0, 0, 0, 0);    // Red, Green, Blue, Alpha
glClear( GL_COLOR_BUFFER_BIT );

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();

  glTranslatef(-1,-0.5,-3);
  glMatrixMode(GL_PROJECTION);

  glLoadIdentity();



  // Multiply projection matrix by a frustum transformation.
  //
  // Left, Right, Top, Bottom, Front, Back
  glFrustum( -0.8, +0.8, -0.8, 0.8, 1, 5000 );


} // wtfmisc 
IdxTy DrawMesh(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{
//ColorVec ctv;
//Rainbow(ctv,0);
//color_t  range_color(const D & _t,const D & min, const D& max)

  glColor3f(1,1,1);     // white default for mesh  
// this can't work since it subtracts m_c center lol 
//v.doglutpos(glColor3f,1.0,1.0,1.0);
auto& p=m.ff_mesh_d();
const StrTy sin=m.etc("kvp");
BaseParams kvp(sin);
const IdxTy ndofs=p.size(3);
const auto& dofs=p.get_dofs();
const typename ModelInfo::_ff_mesh_t::dof_type * dofp=0;
if (ndofs!=0) { dofp=& ((*(dofs.begin())).second); } 
//MM_ERR(MMPR2(ndofs,dofp))
bool filling=(ndofs!=0); // !true;
MM_ILOOP(i,p.size(1)) // triangles 
{
if (filling)  glBegin(GL_POLYGON);
else  glBegin(GL_LINE_LOOP);
// this has to be a translated shape or else translated... 
MM_ILOOP(j,3)
{
IdxTy vertex=BAD;
//glColor3f(pi.r(),pi.g(),pi.b() );//
typename ViewInfo::triple_t vt;
p.get_triangle(vertex,vt,i,j);
if (dofp)
{
const D val=(*dofp)[vertex];
//MM_ERR(MMPR2(val,vt.x()))
const D min=(*dofp).stats().min();
const D max=(*dofp).stats().max();
const D zz=(max>min)?(val-min)/(max-min):0; 
//MM_ERR(MMPR(vertex)<<MMPR4(val,min,max,zz))
color_type ct=GlutUtil::range_color(val,min,max);
//color_type ct=color_type(zz*1.0,0,0);
//MM_ERR(MMPR3(ct.x(),ct.y(),ct.z()) )//
glColor3f(ct.x(),ct.y(),ct.z() );//
//v.doglutpos(glColor3f,ct);
vt.m_z=zz;
} // dofp 

v.doglutpos(glVertex3f,vt);
} // j 
glEnd();
// need to have params for mesh and dof's 

} // i 

return 0; 
} // DrawMesh
IdxTy DrawTri(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{
 glBegin(GL_TRIANGLES);

auto p=m.points_d();
for(IdxTy j=0; j<p.size(); ++j)
{
const auto & pj=p[j];

Gf r=1.0;
Gf g=1.0;
Gf b=1.0;
int cx=j%3;
  glColor3f(r,g,b);     // Green
if (cx==0)  glColor3f(1.0,0,0);     // Green
else if (cx==1)   glColor3f(0,1.0,0);     // Green
else   glColor3f(0,0,1.0);     // Green
Gf fukx=(pj.x); // -v.m_c[0])*fu;
Gf fuky=(pj.y); // -v.m_c[1])*fu;
Gf fukz=(pj.z); // -v.m_c[2])*fu;
v.doglutpos(glVertex3f,fukx,fuky,fukz); 
} // j 
    glEnd();//end drawing of points

return 0;
} // DrawTri 
IdxTy DrawMolecule(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{

//m.m_molecule.draw(m,v,sdp);
m.molecule_d().draw(m,v,sdp);
return 0;
} // DrawMolecule
IdxTy DrawDecorations(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{

m.decorations_d().draw(m,v,sdp);

return 0;
} // DrawDecorations 

IdxTy DrawStrip(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{
m.strip().draw_points(m,v,sdp);
// need lock on the changed flag 
if (m_grat_changed) 
{ m_grat_changed=0; m.graticule_d().config(m_grat_config); }
m.graticule_d().draw(m,v,sdp);

return 0;
} // DrawStrip

IdxTy DrawOrnatePoints(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{
//MM_ERR(" drawing ornate ")
auto& p=m.ornate_points_d();
//MM_ERR(MMPR(p.size()))
MM_LOOP(ii,p)
{
//MM_ERR(" point ")
// this is a tokenized_point
const PointEntry& pi=(*ii); 
// these need to be translated internally.
const StrTy & shape=p(pi.shape());
Shape * pshape=(Shape*)pi.shapep();
if (pshape==NULL)
{
MM_ERR(" no pshapep")
continue;
} // null 
//MM_ERR(MMPR4(shape,pi.x(),pi.y(),pshape))
//MM_ERR(MMPR(pi.dump()))
//DrawOrnateShape(pi,pshape,v,sdp);
v.draw_ornate_shape(pi,pshape,sdp);
} // ii 

return 0;
} // DrawOrnatePoints
#if 0
IdxTy DrawOrnateShape(const PointEntry & pi,Shape * pshape, ViewInfo & v, DrawInfo * sdp)
{
Shape & s=*pshape;
// size and place ok... 
// maybe output vectors or something? 
// FIXME the bastard coords- both glut and view have xforms, make this
// confusing. Need to pick one but too time consuming for now. 
//glTranslatef(); 
//glColor3f();//
// TODO use the color in shape this is dumb 
glColor3f(pi.r(),pi.g(),pi.b() );//
if (s.filled())  glBegin(GL_POLYGON);
else  glBegin(GL_LINE_LOOP);
// this has to be a translated shape or else translated... 
MM_LOOP(ii,s)
{
//v.doglutpos(glVertex3f,pi);
v.doglutpos(glVertex3f,(*ii).triple(pi.x(),pi.y(),pi.z(),pi.size()));
} // ii 

glEnd();


return 0;
} // DrawOrnateShape
#endif


IdxTy DrawSeg(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{
 glBegin(GL_LINES);
// note no ref doh
auto p=m.points_d();
for(IdxTy j=0; j<p.size(); ++j)
{
const auto & pj=p[j];

Gf r=1.0;
Gf g=1.0;
Gf b=1.0;
  glColor3f(r,g,b);     // Green

int cx=j%3;
if (cx==0)  glColor3f(1.0,0,0);     // Green
else if (cx==1)   glColor3f(0,1.0,0);     // Green
else   glColor3f(0,0,1.0);     // Green

v.doglutpos(glVertex3f,pj.x,pj.y,pj.z); 

      //MM_ERR(MMPR3(Gf(pj.x),Gf(pj.y),Gf(pj.z)));//upper-right corner
} // j 
    glEnd();//end drawing of points

return 0;
} // DrawSeg


IdxTy DrawRealSeg(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{
// glBegin(GL_LINES);
// ref may not be prudcent until threading worked out lol 
// 2024-02-21 sure engough bombing during updates lol 
const auto & _p=m.segs_d();
for(IdxTy segs=0; segs<_p.size(); ++segs)
{
//const auto&  p=m.m_segs[segs];
const auto&  p=m.segs_d()[segs]; // non const but ok if already stuff there 

    glBegin(GL_LINE_STRIP); //starts drawing of points
for(IdxTy j=0; j<p.size(); ++j)
{
const auto & pj=p[j];

//Gf gb= v[vidx]*rna-c1; Gf r= gb; Gf g=1.0-4.0*(r-.5)*(r-.5) ;
//Gf b=1.0-r ;
//MM_ERR(MMPR4(lo[0],lo[1],gb,r)<<MMPR2(g,b))
const color_type & ct=pj.rgb;
Gf r=ct.r;
Gf g=ct.g;
Gf b=ct.b;
//D fu=v.distance;
  glColor3f(r,g,b);    
if (false) if (pj.y>2) { MM_ERR("xxdanger "<< MMPR4(segs,j,pj.x,pj.y)<<MMPR(pj.z)) } 

v.doglutpos(glVertex3f,pj.x,pj.y,pj.z); 

} // j 
    glEnd();//end drawing of points
} // segs
return 0;
} // DrawRealSeg

virtual IdxTy Draw(scope_draw_param_type * sdp , const IdxTy flags) 
{
//MM_ERR(__FUNCTION__)
EnterSerial(0);
ViewInfo & v=m_view;
//MM_ERR(MMPR(v.dump()))

GlutUtil::start_view(v);

//const IdxTy szd=m_data.size();
const IdxTy szd=m_data_idx.used();
if (sdp) sdp->hist_size(szd);
for(IdxTy i=0; i<szd; ++i)
//for(int i=(szd-1); i>=0; --i)
{
if (sdp) sdp->hist_index(i);
// TODO FIXME copy for threading issue... 
// bno help ... 
// this is organized by source so name collisions
// or different type from one source not handled right
// 
// TODO this should draw newest last for Z-buffering lol 
// need fase options etc. 
//ModelInfo&  m=m_data[i];
ModelInfo&  m=m_data_idx(i);
// do this first as right now it obliterate entire background
 DrawSvg(m,v,sdp); 
if (i==(szd-1)) {  DrawHeat(m,v,sdp);  }
// TOFO fix this... 
if (m.segs_d().size()) DrawRealSeg(m,v,sdp); 
 DrawLine(m,v,sdp); 
 DrawTri(m,v,sdp); 
 DrawMesh(m,v,sdp); 
DrawSeg(m,v,sdp); 
DrawOrnatePoints(m,v,sdp); 
DrawStrip(m,v,sdp); 
DrawMolecule(m,v,sdp);
DrawDecorations(m,v,sdp);
//ExitSerial(0);
} // i 
if (szd)
{
//ModelInfo&  m=m_data[szd-1];
ModelInfo&  m=m_data_idx(szd-1);
DrawParams(m,v,sdp);
}  // szd

ExitSerial(0);
return 0; 
} // Draw

IdxTy DrawOnCurve(ModelInfo & m, ViewInfo & v, const IdxTy seg,const char * string )
{
const auto & _p=m.segs(); // m_segs;
const IdxTy segs=_p.size();
//MM_ERR(MMPR2(seg,segs))
//const auto&  p=m.m_segs[seg];
const auto&  p=m.segs_d()[seg];
const IdxTy points=p.size();
const IdxTy j=points>>1;
const auto & pj=p[j];
const color_type & ct=pj.rgb;
Gf r=ct.r;
Gf g=ct.g;
Gf b=ct.b;
//D fu=v.distance;
Gf fukx=(pj.x); // -v.m_c[0])*fu;
Gf fuky=(pj.y); // -v.m_c[1])*fu;
Gf fukz=(pj.z); // -v.m_c[2])*fu;
MM_ERR(" code needs to be updated for m_mat etc ")

//MM_ERR(MMPR4(fukx,fuky,fukz,string))
      //glVertex3f(fukx,fuky,fukz);//upper-right corner
glPushMatrix();
      glTranslatef(fukx,fuky,fukz);//upper-right corner

  glutBitmapString(GLUT_BITMAP_TIMES_ROMAN_24, (const unsigned char *)string);
  glutStrokeString(GLUT_STROKE_MONO_ROMAN, (const unsigned char *)string);
glPopMatrix();

return 0;
} 

/*
// x and y will be resolved to avoid overlap ... hopefully ... lol 
void add_text(const D & x, const D & y, const D & sz, const StrTy & s, const Tc& col,
// code==BAD not hot 
p_handler_type ptr, const IdxTy code)

*/
IdxTy DrawTextToSdp(ModelInfo & m, ViewInfo & vv, DrawInfo * sdp )
{
// TODO FIXME  this needs to match repeated code in the display
// of the curves doh 
ColorVec ctv;
Rainbow(ctv,0);
IdxTy code=0;
const IdxTy sz=12;
D x=0;
D y=0;
const IdxTy np=m.params_d().size();
const IdxTy nl=2;
D dy=1.0/(nl+np);
//sdp->m_hz.add_text(x,y,sz,"MJMDatascope 1",ctv[0],this,code);
y+=dy; // 1.0/(nl+np);
MM_LOOP(ii,m.params_d())
{
++code; // k v start at 1 with src at zero 
const StrTy & k=(*ii).first;
const StrTy & v=(*ii).second;
// draw on trace
const char * pk=k.c_str();
const char * pv=v.c_str();
if (strncmp(pk,"name",4)==0)
{
const IdxTy trace=atoi(pk+4);
const IdxTy tc=trace%ctv.size();
const color_type & ct=ctv[tc]; // pj.rgb;
sdp->m_hz.add_text(x,y,sz,v,ct,this,code);
} // name 
else
{
sdp->m_hz.add_text(x,y,sz,pk,ctv[0],this,code);
sdp->m_hz.add_text(x+.5,y,sz,pv,ctv[0],this,code);
} // param 
y+=dy; // 1.0/(nl+np);
} // ii 
y+=dy; // 1.0/(nl+np);
//GlutUtil::render_string(0.0, 0.0,0, "MJMDatascope",ctv[0]);
code=0;
sdp->m_hz.add_text(x,y,sz,StrTy("Src:") + srcname(),ctv[0],this,code);
//srcname();
return 0;
} // DrawTextToSdp


IdxTy DrawParams(ModelInfo & m, ViewInfo & vv, DrawInfo * sdp )
{
if (sdp) return DrawTextToSdp(m,vv,sdp);
int w,h;
float ff=10;
w=glutGet(GLUT_WINDOW_WIDTH);
h=glutGet(GLUT_WINDOW_HEIGHT);
if (false) MM_ERR(MMPR2(w,h))
float pi=.05*h*ff;
float c2=.2*w*ff;
ColorVec ctv;
Rainbow(ctv,0);
// TODO FIXME pass 0 should draw the trace names in model
// coords over the respective traces but it doesn't f-ing work
// f 
for (int pass=1; pass<2; ++pass)
{

if (pass==1) GlutUtil::begin_screen_coords(vv);
// glClear(GL_COLOR_BUFFER_BIT);
IdxTy n=0;
glColor3f(1,1,1);
MM_LOOP(ii,m.params_d())
{

glColor3f(1,1,1);
const StrTy & k=(*ii).first;
const StrTy & v=(*ii).second;
// draw on trace
const char * pk=k.c_str();
const char * pv=v.c_str();
if (strncmp(pk,"name",4)==0)
{
const IdxTy trace=atoi(pk+4);
const IdxTy tc=trace%ctv.size();
const color_type & ct=ctv[tc]; // pj.rgb;
Gf r=ct.r;
Gf g=ct.g;
Gf b=ct.b;
  glColor3f(r,g,b);    
if (pass==1) { 
GlutUtil::render_string(0, (n+2)*pi, pk,ctv[tc]);
GlutUtil::render_string(c2, (n+2)*pi, pv,ctv[tc]);
}
//GlutUtil::end_screen_coords(vv);
// this clears crap doh 
//GlutUtil::start_view(vv);
if (pass==0) DrawOnCurve(m, vv, trace,pv);
//GlutUtil::begin_screen_coords(vv);

}
else
{ // draw in cursor 
if (pass==1) {
GlutUtil::render_string(0, (n+2)*pi, pk,ctv[0]);
GlutUtil::render_string(c2, (n+2)*pi, pv,ctv[0]);
}


}

//void render_tring(float x, float y, void *font, const char* string, const color_t & rgb)
if (pass==1){
//GlutUtil::draw_string(0.0, (n+1)*pi,0.0, pk);
//GlutUtil::draw_string(c2, (n+1)*pi,0.0, pv);
GlutUtil::render_string(0, (n+2)*pi,0, pk,ctv[0]);
GlutUtil::render_string(c2, (n+2)*pi,0, pv,ctv[0]);
} 


++n;
} // ii 
if (pass==1) { 
//GlutUtil::draw_string(0.0, 0.0,0.0, "MJMDatascope");
GlutUtil::render_string(0.0, 0.0,0, "MJMDatascope",ctv[0]);
GlutUtil::end_screen_coords(vv);
} // pass

// glFlush();
} // pass 

return 0; 
} // DrawParams
IdxTy DrawHeat(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{
auto & hm= m.heatmap_d();
int w=glutGet(GLUT_WINDOW_WIDTH);
int h=glutGet(GLUT_WINDOW_HEIGHT);
int rows=hm.rows();
int cols=hm.cols();
//MM_ERR(MMPR4(w,h,rows,cols)<<MMPR(hm.size()))
//MM_ERR(MMPR4(w,h,rows,cols))
Gf xz=0;
Gf yz=0;
Gf zz=0;
Gf bw=.1;
Gf bh=.1;
Gf xmin=0;
Gf ymin=0;
glTranslatef(0,0,0);
glBegin(GL_QUADS);
MM_LOOP(ii,hm)
{
const auto & b=(*ii);
//MM_ERR(MMPR(b.dump()))
const IdxTy i=b.i();
const IdxTy j=b.j();
const Gf x=xmin+j*bw;
const Gf y=ymin+i*bh;
glColor3ub(b.ri(),b.gi(),b.bi());
v.doglutpos(glVertex3f,x,y,zz);
v.doglutpos(glVertex3f,x,y+bh,zz);
v.doglutpos(glVertex3f,x+bw,y+bh,zz);
v.doglutpos(glVertex3f,x+bw,y,zz);
} // hm
glEnd();
{
glColor3ub(255,255,255);
Gf di=xmin+.2*bw;
Gf pitch=bw;

MM_LOOP(ii,hm.col_names())
{
// assfuck 
Gf yy=ymin; // +cols*bw;;
Gf xx=di;
Gf zz=0;
v.inplacepos(xx,yy,zz);
//MM_ERR(MMPR3(xx,yy,zz))
//drawString(xmin,ymin+di,0,(*ii).c_str());
drawStringfuck(xx,yy-.4,zz,(*ii).c_str());
di+=pitch; // pitch;

} // ii col_names
} // col guard 
Gf di=ymin+.2*bh;
Gf pitch=bh;
glColor3ub(255,255,255);
if (!false)
{
MM_LOOP(ii,hm.row_names())
{
//MM_ERR(MMPR4(x,y,z,(*ii)))
Gf xx=xmin+cols*bw;;
Gf yy=di;
Gf zz=0;
v.inplacepos(xx,yy,zz);
//MM_ERR(MMPR3(xx,yy,zz))
//drawString(xmin,ymin+di,0,(*ii).c_str());
drawString(xx,yy,zz,(*ii).c_str());
di+=pitch; // pitch;

} // ii 
} // false 
// shitty ass shit fuck test fucking pattern fuck this shit 
if (false)
{
MM_ILOOP(i,1000)
{
Gf x=i;
Gf y=i;
Ss ss;
ss<<MMPR3(i,x,y);
const char * string=ss.str().c_str();
 glRasterPos3f(x, y,0);
  for (const char* c = string; *c != '\0'; c++) {
    glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, *c);  // Updates the position
  }

} // i 
} // false
return 0;
} // DrawHeat

void drawString(float x, float y, float z, const char *string) {
//  glRasterPos3f(x, y, z);
//MM_ERR(" fuck "<<MMPR4(x,y,z,string))
//porject(x,y,z); // need the view first 
//MM_ERR(" shit "<< MMPR4(x,y,z,string))
// ASSFUCK 
// this shit doesn't fucking work for shit  ASSFUCK 
//glPushMatrix();
//glMatrixMode(GL_MODELVIEW) ;
//glRotatef(45,x,y,z);
//glRasterPos2f(x, y);
//glTranslatef(x,y,z);
//glScalef(20,20,20);
// works for bit map 
if (!false)  glRasterPos3f(x, y, z);
  for (const char* c = string; *c != '\0'; c++) {
    //glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, *c);  // Updates the position
    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, *c);  // Updates the position
//glTranslatef(x,y,z);
// no fucking work fuclk 
//    glutStrokeCharacter(GLUT_STROKE_MONO_ROMAN, *c);  // Updates the position
  }
// another assfuck
//glPopMatrix();
}


void drawStringfuck(float x, float y, float z, const char *string) {
//  glRasterPos3f(x, y, z);
//MM_ERR(" fuck "<<MMPR4(x,y,z,string))
//porject(x,y,z); // need the view first 
//MM_ERR(" shit "<< MMPR4(x,y,z,string))
// ASSFUCK 
// this shit doesn't fucking work for shit  ASSFUCK 
//glPushMatrix();
//glMatrixMode(GL_MODELVIEW) ;
//glRotatef(45,x,y,z);
//glRasterPos2f(x, y);
//glTranslatef(x,y,z);
//glScalef(20,20,20);
// works for bit map 
  for (const char* c = string; *c != '\0'; c++) {
    //glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, *c);  // Updates the position
if (!false)  glRasterPos3f(x, y-.4*(c-string), z);
    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, *c);  // Updates the position
//glTranslatef(x,y,z);
// no fucking work fuclk 
//    glutStrokeCharacter(GLUT_STROKE_MONO_ROMAN, *c);  // Updates the position
  }
// another assfuck
//glPopMatrix();
} // drawStringfuck


// https://community.khronos.org/t/placing-text-in-3d-world/59313/4
void porject(float & x, float & y, float &z )
{
 //glRasterPos3f(0,0,0);
 //glTranslatef(0,0,0);
// someone sets the last 4 to fucking shit 
//glMatrixMode(GL_MODELVIEW);
//   glLoadIdentity();

// this assfuck sets the fucking matrix vector fuck 
//glTranslatef(0,0,0);
	GLdouble modelview[16];
	GLdouble projection[16];
	GLint viewport[4];
// set from glScalef in StartView not identity 
	glGetDoublev(GL_MODELVIEW_MATRIX, modelview);
	glGetDoublev(GL_PROJECTION_MATRIX, projection);
	glGetIntegerv(GL_VIEWPORT, viewport);
//MM_ILOOP(i,4) { MM_ERR(MMPR(viewport[i]))}
//MM_ILOOP(i,16) { MM_ERR(MMPR(projection[i]))}
//MM_ILOOP(i,16) { MM_ERR(MMPR(modelview[i]))}
	//Coord outputCoord = { 0.0, 0.0, 0.0 };
 GLdouble xx=0,yy=0,zz=0;
	//gluProject(x, y, z, modelview, projection, viewport, &outputCoord.x, &outputCoord.y, &outputCoord.z);
if(GL_TRUE==	gluProject(x, y, z, modelview, projection, viewport, &xx, &yy, &zz))
{} // MM_ERR(" fucker worked ")
else
{

MM_ERR(" fucker failed ")

} ;
x=xx;
y=yy;
z=zz;
	//outputCoord.y = viewport[3] - outputCoord.y;
//	y = viewport[3] - y;

//	return outputCoord;

} // fuck         
IdxTy DrawSvg(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{
auto & sv= m.svgs_d();
int w=glutGet(GLUT_WINDOW_WIDTH);
int h=glutGet(GLUT_WINDOW_HEIGHT);
MM_LOOP(ii,sv)
{
// not const as it renders 
auto & svg=(*ii);
// right now no rendering specs 
// need to request a render first...
Ss rr;
rr<<"w="<<w;
rr<<";";
rr<<"h="<<h;
svg.render_saved(rr.str(),0);
if (svg.data())
{
// https://stackoverflow.com/questions/15871616/turning-picture-upside-down-when-using-gldrawpixels
v.svg_zoom();
//float zf=v.distance;
//glRasterPos2f(v.m_c[0],v.m_c[1]);
//glPixelZoom(1,-zf);

// red and blue seem to be interchanged 
//GLenum ty= GL_UNSIGNED_INT_8_8_8_8_REV;
GLenum ty= GL_UNSIGNED_BYTE;
//glDrawPixels(m_svg.w(),m_svg.h(),GL_RGBA, ty,m_svg.data());
glDrawPixels(svg.w(),svg.h(),GL_BGRA, ty,svg.data());

} // data 
else MM_ERR(" svg no data ")
} // ii 

return 0;
} // DrawSvg

IdxTy DrawLine(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{


    glBegin(GL_LINE_STRIP); //starts drawing of points
auto p=m.points_d();
for(IdxTy j=0; j<p.size(); ++j)
{
const auto & pj=p[j];

//Gf gb= v[vidx]*rna-c1; Gf r= gb; Gf g=1.0-4.0*(r-.5)*(r-.5) ;
//Gf b=1.0-r ;
//MM_ERR(MMPR4(lo[0],lo[1],gb,r)<<MMPR2(g,b))
Gf r=1.0;
Gf g=1.0;
Gf b=1.0;
//D fu=v.distance;
  glColor3f(r,g,b);     // Green
// fng distance doesn't fing work with fug line
Gf fukx=(pj.x); // -v.m_c[0])*fu;
Gf fuky=(pj.y); // -v.m_c[1])*fu;
Gf fukz=(pj.z); // -v.m_c[2])*fu;
v.doglutpos(glVertex3f,fukx,fuky,fukz); 
      //MM_ERR(MMPR(i)<<MMPR4(j,Gf(fu*pj.x),Gf(fu*pj.y),Gf(fu*pj.z)))
 //     glVertex3f(fukx,fuky,fukz);//upper-right corner
      //glVertex3f(Gf(fu*pj.x),Gf(fu*pj.y),Gf(fu*pj.z));//upper-right corner
      //MM_ERR(MMPR3(Gf(pj.x),Gf(pj.y),Gf(pj.z)));//upper-right corner
//      glVertex3f(-1.0f,-1.0f,0.0f);//lower-left corner
} // j 
    glEnd();//end drawing of points


return 0;
} // DrawLine




void Init()
{
m_debug=-1;
m_grat_changed=0;
m_data_idx.set_size(10);
  m_mutex_vector= MutexVector(3);;
 MakeAddMap();

} // Init

void Init(const StrTy & s)
{
m_src=s;
Init();
//m_debug=0;
//  m_mutex_vector= MutexVector(3);;
// MakeAddMap();

} // Init


// MEMBERS
StrTy m_src;
ViewInfo m_view;
ModelInfo m_background;
//Models  m_data;
// this is an index buffer not an object pool
ModelIndex m_data_idx;
AddMap m_add_map;
IdxTy m_debug;
IdxTy m_grat_changed;
StrTy m_grat_config;
//SvgRender m_svg;
}; // mjm_glut_rags

//////////////////////////////////////////////

template <class Tr,class KeyTy >
class mjm_glut_rags_map : public std::map< KeyTy, mjm_glut_rags< Tr > * >  
{
 typedef mjm_glut_rags_map Myt;

typedef   mjm_glut_rags< Tr> ObTy;
//typedef typename  mjm_glut_rags< Tr> * ValTy;
typedef  ObTy * ValTy;
//typedef typename std::map<KeyTy, mjm_glut_rags< Tr> * >   Super;
typedef typename std::map<KeyTy, ValTy >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
typedef mjm_ragged_table Ragged;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_glut_rags_map() {Init(); }
void debug(const IdxTy d) { m_debug=d; } 
// changed to use format of first line "# id ... srcname"
// this is a map with a key type right now as Line
// which hopefully gets the first line as the index. 
// this is the source 
StrTy src_name(const Ragged & r)
{
IdxTy sz=r.size();
if (m_debug) MM_ERR(" operator [] "<<MMPR2(sz,Super::size()))
if (sz==0) return StrTy();
const Ragged::Line & l =r[0];
const IdxTy len=l.size();
if (len<3) return StrTy();
if (l[0]=="#" ) if (l[1]=="id") return l[len-1];
MM_ERR(" bad id line "<<MMPR4(r.size(),l[0],l[1],l[len-1])<<MMPR(len))
return StrTy();
} // srcname 

ValTy operator[](const Ragged & r)
{
ValTy p=0;
StrTy src=src_name(r);
if (src.length()==0)
{
MM_ERR(" no src in ragged "<<MMPR(r.size()))
src="XXXMissing";
} // nothing;
auto ii=Super::find(src);
if (ii==Super::end()) { 
MM_ERR(" noew p "<<MMPR(src))
p=new ObTy(src);  Super::operator[](src)= p; } 
else p=(*ii).second;
p->srcname(src); 
/*
IdxTy sz=r.size();
if (m_debug) MM_ERR(" operator [] "<<MMPR2(sz,Super::size()))
if (sz==0) return p;
const Line & idline=r[0];
auto ii=Super::find(r[0]);
//if (ii==Super::end()) (*this)[r[0]]= p=new ObTy();
if (ii==Super::end()) { 
MM_ERR(" noew p ")
p=new ObTy();  Super::operator[](r[0])= p; } 
else p=(*ii).second;
*/

return p;
} // operator 

void remove(const KeyTy  & src )
{
auto ii=Super::find(src);
if (ii!=Super::end()) { 
ValTy p=(*ii).second;
Super::erase(ii);
delete p;
} // end 

} // remove

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
m_debug=0; 
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:
IdxTy m_debug;
}; // mjm_glut_rags_map




////////////////////////////////////////////
#ifdef  TEST_MJM_GLUT_RAGS
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_glut_rags <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_GLUT_RAGS "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_glut_rags<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_GLUT_RAGS_H__ 
