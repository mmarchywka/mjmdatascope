 //  cpputil rename on Fri 21 Mar 2025 02:01:47 PM EDT from mjm_strip_chart to mjm_glut_decorations
#ifndef MJM_GLUT_DECORATIONS_H__
#define MJM_GLUT_DECORATIONS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_tokenized_points.h"


//#include "mjm_block_matrix.h"
#include "mjm_instruments.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_worm_blob.h"
#include "mjm_collections.h"
//#include "mjm_tokenized_collections.h"
#include "mjm_string_tokenizer.h"
#include "mjm_canned_methods.h"

#include "mjm_pawnoff.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_generic_iterators.h"



#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


/*
<one line to give the program's name and a brief idea of what it does.>


Conceived and written by Mike Marchywka from 2024 to present.
See dates in individual code pieces as they were 
generated from my wizards. 
Copyright (C) <year> <name of author>


This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
@software{,
  author = {Michael J Marchywka},
  city = {Jasper GA 30143 USA},
  title = {},
abstract={},
institution={},
license={Knowledge sir should be free to all },
publisher={Mike Marchywka},
email={marchywka@hotmail.com},
authorid={orcid.org/0000-0001-9237-455X},
  filename={mjm_glut_decorations.h},
  url = {},
  version = {0.0.0},
  date-started={2024-04-05},
}
*/

// Fri 05 Apr 2024 08:00:08 PM EDT
// generated by /home/documents/cpp/scripts/cpputil -operand -classhdr mjm_glut_decorations   
// QUICKCOMPILE  g++  -MMD -MF mjm_glut_decorations.deps  -Wall -Wno-misleading-indentation  -std=gnu++11 -DTEST_MJM_GLUT_DECORATIONS -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_glut_decorations.h  -o mjm_glut_decorations.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_glut_decorations("mjm_glut_decorations" , "  ");

template <class Tr>
class mjm_glut_decorations 
{
 typedef mjm_glut_decorations Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

// TYPEDEF 
enum { BAD=~0};
//typedef mjm_canned_methods Canned;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map<StrTy, Ragged> RaggedMap;
typedef std::vector<StrTy> Words;
typedef mjm_string_base_params<Tr> BaseParams;
typedef string_tokenizer Tokenizer;
typedef string_tokenizer St;






typedef mjm_tokenized_points<Tr>  TokPoints;
typedef typename TokPoints::PointEntry PointEntry;
typedef mjm_vector_shapes<Tr> Shapes;
typedef typename Shapes::shape_t Shape;
typedef typename Shapes::point_t Point;

typedef std::map<IdxTy, TokPoints> ChartMap;

#if 0 
 class _chart_info  
{

public:
_chart_info() {Init_chart_info(); } 
~_chart_info() {Free_chart_info(); } 

_chart_info(const Line & l,  const IdxTy first ) { Init_chart_info(l,first); }
_chart_info(const StrTy & s,  const IdxTy flags ) { Init_chart_info(s,flags); }
_chart_info(const Ragged & r, const IdxTy first,const IdxTy i0, const IdxTy flags ) 
{Init_chart_info(r,first,i0,flags); } 

//_chart_info(const _chart_info & that ) { *this=that ; }  
//bool operator<(const _chart_info & that) const { return false;}
//bool operator==(const _chart_info & that) const { return false;}
//bool operator>(const _chart_info & that) const { return false;}
//_chart_info & operator++() const { return *this;}
//_chart_info & operator+=(const _chart_info & that ) { return *this;}
//_chart_info & operator=(const _chart_info & that ) { return *this;}

const D & r() const { return m_r; } 
const D & g() const { return m_g; } 
const D & b() const { return m_b; } 
void color( const D & r, const D & g, const D & b) 
{ m_r=r; m_g=g; m_b=b; }
void color(const IdxTy n) 
{
const IdxTy idx=n&7;
switch ( idx)
{
case 0: { m_r=1; m_g=1; m_b=1; break; }
case 1: { m_r=1; m_g=1; m_b=0; break; }
case 2: { m_r=1; m_g=0; m_b=1; break; }
case 3: { m_r=0; m_g=1; m_b=1; break; }
case 4: { m_r=1; m_g=0; m_b=0; break; }
case 5: { m_r=0; m_g=1; m_b=0; break; }
case 6: { m_r=0; m_g=0; m_b=1; break; }
case 7: { m_r=1; m_g=.5; m_b=.5; break; }
//default:
} // idx

} // color
StrTy save( const IdxTy flags=0) const { return Save_chart_info(flags); } 
StrTy dump( const IdxTy flags=0) const { return Dump_chart_info(flags); } 
private:
void Init_chart_info(const StrTy & s,  const IdxTy flags ) 
{ Init_chart_info(); 
BaseParams kvp(s);

}
void Init_chart_info(const Line & l,  const IdxTy first ) 
{ 
Init_chart_info();
const IdxTy len=l.size();
for(IdxTy i=first; i<len; ++i)
{


} // i 

} // Init_chart_info

void Init_chart_info(const Ragged & r, const IdxTy first,const IdxTy i0,const IdxTy flags ) 
{
Init_chart_info();
const IdxTy sz=r.size();
for(IdxTy i=i0; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();

} // i 

} // Init_chart_info

StrTy Save_chart_info( const IdxTy flags=0) const  
{
StrTy s;
//BaseParams kvp();
BaseParams kvp;
//kcp,encode(s,"",);
return s; 
} // Dump 



StrTy Dump_chart_info( const IdxTy flags=0) const  
{
Ss ss;
// ss<<MMPR4(); 
return ss.str(); 
} // Dump 


void Free_chart_info()
{

} // Free_chart_info

void Init_chart_info()
{
m_r=1;
m_g=1;
m_b=1;
} // Init_chart_info

// _chart_infoMEMBERS
D m_r,m_g,m_b;
 
}; // _chart_info

typedef _chart_info Info;
#endif

//typedef std::map<IdxTy, Info> InfoMap;




// API

public:
mjm_glut_decorations() {Init(); }
mjm_glut_decorations(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
mjm_glut_decorations(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}
const IdxTy size() const { return m_size; } 
void load(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
void load(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}
template <class ModelInfo, class ViewInfo, class DrawInfo>
IdxTy draw(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{
return DrawPoints(m,v,sdp); 
}
const D & xmin() const { return m_x0; } 
const D & xmax() const { return m_x1; } 
const D & ymin() const { return m_y0; } 
const D & ymax() const { return m_y1; } 



void append(const Ragged & r, const IdxTy flags) { Append(r,flags); } 
void append(const Myt & that, const IdxTy flags) { Append(that,flags); } 
void save(const StrTy & fn,const StrTy &s) {Save(fn,s); }

//void set_color(const IdxTy idx, const D & r, const D & g, const D & b,const IdxTy flags) { SetColor(idx, r, g,b, flags); } 


~mjm_glut_decorations() {}

mjm_glut_decorations(const mjm_glut_decorations & that ) { *this=that ; }  

void load_xny(const Ragged & r, const StrTy & sin, const IdxTy flags)
{ LoadXNY(r,sin,flags); } 

//bool operator<(const mjm_glut_decorations & that) const { return false;}
//bool operator==(const mjm_glut_decorations & that) const { return false;}
//bool operator>(const mjm_glut_decorations & that) const { return false;}
//mjm_glut_decorations & operator++() const { return *this;}
//mjm_glut_decorations & operator+=(const mjm_glut_decorations & that ) { return *this;}
//mjm_glut_decorations & operator=(const mjm_glut_decorations & that ) { return *this;}

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
#if 0 
void SetColor(const IdxTy idx, const D & r, const D & g, const D & b,const IdxTy flags)
{
auto ii=m_map.find(idx);
if (ii==m_map.end()) 
{
MM_ERR(" index not found "<<MMPR2(idx,m_map.size()))
return;
} // ii==end 
MM_LOOP(jj,(*ii).second)
{
PointEntry& pi=(*jj);
pi.color(r,g,b); 

} // ii 
} // SetColor
#endif


template <class ModelInfo, class ViewInfo, class DrawInfo>
void DrawLineCmd(const Line & l, ModelInfo & m, ViewInfo & v, DrawInfo * sdp ,
const IdxTy flags )
{
const D z=0;
const IdxTy len=l.size();
if (len<9) { MM_ERR(" too short "<<MMPR(len)) return ; }
// really this is 3 D should have z too 
const D x0= myatof(l[1]);
const D x1= myatof(l[2]);
const D y0= myatof(l[3]);
const D y1= myatof(l[4]);
const IdxTy cflag=myatoi(l[5]); 
const bool xscreen=Bit(cflag,0);
const bool yscreen=Bit(cflag,1);
const D r= myatof(l[6]);
const D g= myatof(l[7]);
const D b= myatof(l[8]);
const D w= myatof(l[9]);
MM_ERR(MMPR4(x0,y0,x1,y1)<<MMPR4(r,g,b,w))
glLineWidth(w);
 glBegin(GL_LINE_STRIP);
glColor3f(r,g,b );//
v.doglutpos(glVertex3f,x0,y0,z);
v.doglutpos(glVertex3f,x1,y1,z);
Bounds(x0,y0); ++m_size; // not really right but works unless "b" already called
Bounds(x1,y1); ++m_size; // not really right but works unless "b" already called
IdxTy i=10;
while ((i+1)<len)
{
const D x= myatof(l[i]);
const D y= myatof(l[i+1]);
Bounds(x,y); ++m_size; // not really right but works unless "b" already called
v.doglutpos(glVertex3f,x,y,z);
++i;
}
glEnd();

} //DrawLineCmd 

template <class ModelInfo, class ViewInfo, class DrawInfo>
void DrawTextCmd(const Line & l, ModelInfo & m, ViewInfo & v, DrawInfo * sdp ,
const IdxTy flags )
{
const D z=0;
const IdxTy len=l.size();
if (len<8) { MM_ERR(" too short "<<MMPR(len)) return ; }
// really this is 3 D should have z too 
const D x= myatof(l[1]);
const D y= myatof(l[2]);
const D r= myatof(l[3]);
const D g= myatof(l[4]);
const D b= myatof(l[5]);
const D sz= myatof(l[6]);
const char * p=l[7].c_str();
MM_ERR(MMPR4(p,x,y,z)<<MMPR4(r,g,b,sz))
//glLineWidth(w);
glColor3f(r,g,b );//
v.dogluttext(p,x,y,z,sz);
Bounds(x,y); ++m_size; // not really right but works unless "b" already called
#if 0
IdxTy i=10;
while ((i+1)<len)
{
const D x= myatof(l[i]);
const D y= myatof(l[i+1]);
Bounds(x,y); ++m_size; // not really right but works unless "b" already called
v.doglutpos(glVertex3f,x,y,z);
++i;
}
glEnd();
#endif

} //DrawTextCmd 



enum { DRAWLINE, DRAWTEXT };
void LoadCmdMap()
{
m_cmd_map["line"]= DRAWLINE;
m_cmd_map["text"]= DRAWTEXT;


}
//typedef void (Myt:: * CmdFunc)(const Line &, ModelInfo & , ViewInfo & , DrawInfo * , const IdxTy  ) ;
//typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::map<StrTy, IdxTy > CmdMap;
template <class ModelInfo, class ViewInfo, class DrawInfo>
IdxTy DrawPoints(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{
const IdxTy sz=m_r.size();
const int style=v.style();
MM_ERR(MMPR2(sz,style))
IdxTy flags=0;
// right now this is interpreted but want to compile later
IdxTy idx=01; // skpi headers TODO FIXME get number right 
while (idx<sz)
{
const Line & l=m_r[idx];
const IdxTy len=l.size();
//IdxTy i=
const StrTy cmd=l[0];
const auto ii=m_cmd_map.find(cmd);
//if ( ii!=m_cmd_map.end()) { (this->*m_cmd_map[cmd])(l,m,v,sdp,flags); }
if ( ii!=m_cmd_map.end()) {
switch ((*ii).second)
{
case DRAWLINE: {  DrawLineCmd(l,m,v,sdp,flags);  break; }
case DRAWTEXT: {  DrawTextCmd(l,m,v,sdp,flags);  break; }

default: MM_ERR(" map bad for "<<MMPR(cmd))
} // switch 
} // end()
else  { MM_ERR(" comment maybe "<<MMPR2(cmd,len))  } 
++idx;
} // ii 

#if 0 
const int style=v.style();
const bool as_points=Bit(style,0);
//MM_ERR(" drawing ornate ")
glPointSize(4.0);
glLineWidth(4.0);
//double xraw=0;
MM_LOOP(jj,m_map)
{
if (as_points) glBegin(GL_POINTS);
else glBegin(GL_LINE_STRIP);
auto& p=(*jj).second; // m.m_ornate_points;
//MM_ERR(MMPR(p.size()))
MM_LOOP(ii,p)
{
//MM_ERR(" point ")
// this is a tokenized_point
const PointEntry& pi=(*ii);
glColor3f(pi.r(),pi.g(),pi.b() );//
// these need to be translated internally.
const StrTy & shape=p(pi.shape());
Shape * pshape=(Shape*)pi.shapep();
// can have a retrace blanking problem in line mode 
v.doglutpos(glVertex3f,pi.x(),pi.y(),pi.z());
if (pshape==NULL)
{
//MM_ERR(" no pshapep")
//continue;
} // null 
//MM_ERR(MMPR4(shape,pi.x(),pi.y(),pshape))
//MM_ERR(MMPR(pi.dump()))
//DrawOrnateShape(pi,pshape,v,sdp);
if (false) v.draw_ornate_shape(pi,pshape,sdp);
} // ii 
glEnd();
} // jj 
#endif

return 0;
} // DrawPoints


int myatoi(const StrTy & s )const   { return mjm_canned_methods::myatoi(s.c_str()); }
D myatof(const StrTy & s )const   { return atof(s.c_str()); }
int myatoi(const char * c) const  { return mjm_canned_methods::myatoi(c); }
static bool Bit(const IdxTy f, const IdxTy b) { return  ((f>>b)&1)!=0; }
// should loop over map now 
static void Set(IdxTy& f, const IdxTy b,const bool x) //const  
    { if (x) f|=(1<<b); else f&=((~1)<<b); }
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


void Save(const StrTy & fn,const StrTy &s) {
// std::ofstream ofs(fn);

 } // Save
void Append(const Ragged & r, const IdxTy flags)
{
m_r=r; // LoadXNY(r,"",flags);
} 
// these all have different m_st values doh... 
void Append(const Myt & that, const IdxTy flags)
{
MM_LOOP(ii,that) { m_r.add(*ii); }
#if 0 
MM_LOOP(ii,that.m_map)
{
const IdxTy oldkey=(*ii).first;
const StrTy nm=that.m_st(oldkey);
// will want to chnage color... 
auto  old=(*ii).second;
const IdxTy chart=m_st(nm);
// want to update colors if default but no idea...
const auto ff=that.m_info.find(oldkey);
// better exist ... 
const auto & oldinfo=(*ff).second; // that.m_info[oldkey];

auto & tnew=m_map[chart];
if (m_info.find(chart)==m_info.end())
{ m_info[chart].color(chart); } 
const auto & ci=m_info[chart];

// f-es up color.. 
//tnew+=old;
MM_LOOP(jj,old)
{
//auto
tnew.load((*jj).x(),(*jj).y(),(*jj).z(),ci.r(),ci.g(),ci.b(),0);
} // jj 


} // ii 

#endif

}  // Append 
#if 0
void LoadXNY(const Ragged & r, const StrTy & sin, const IdxTy flags)
{ 
//LoadXNY(r,sin,flags); 
// load single points into named chart,
const IdxTy sz=r.size();
const IdxTy start=0;
D red=1;
D g=1;
D b=1;
for(IdxTy i=start; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();
if (len==0)  continue;
if (l[0].c_str()[0]=='#') continue;
if (len!=3) { MM_ERR(" ignoring line "<<MMPR2(i,l[0])) continue; }
const IdxTy chart=m_st(l[1]);
const D x=atof(l[0].c_str());
const D y=atof(l[2].c_str());
if (m_info.find(chart)==m_info.end())
{ m_info[chart].color(chart); } 
const auto & ci=m_info[chart];
m_map[chart].load(x,y,0,ci.r(),ci.g(),ci.b(),0);
Bounds(x,y);
++m_size;
}  // i 
}  // LoadXNY
#endif


void Bounds( const D& x, const D & y)
{
if (m_size==0) { m_x0=x; m_x1=x; m_y0=y; m_y1=y; return; } 
if (x>m_x1) m_x1=x; if (x<m_x0) m_x0=x;
if (y>m_y1) m_y1=y; if (y<m_y0) m_y0=y;

} // Bounds 

void Init(const Ragged & r, const IdxTy start=0, const IdxTy first=0, const IdxTy flags=0  )
{
Init();
const IdxTy sz=r.size();
for(IdxTy i=start; i<sz; ++i)
{
//const Line & l=r[i];
//const IdxTy len=l.size();


}  // i 

} // Init 
void Init(const StrTy  & sin,const IdxTy flags =0  )
{
Init();
BaseParams kvp(sin);
} // Init 

void Init()
{
m_size=0;
m_x0=0;
m_x1=0;
m_y0=0;
m_y1=0;
LoadCmdMap();
} // Init



// MEMBERS
CmdMap m_cmd_map;
Ragged m_r; // right now just interpret source later compile
//St m_st;

//ChartMap m_map;
//InfoMap m_info;
IdxTy m_size;
D m_x0,m_x1,m_y0,m_y1;
}; // mjm_glut_decorations

//////////////////////////////////////////////

template <class Tr>
class mjm_glut_decorations_map : public std::map<typename Tr::StrTy, mjm_glut_decorations< Tr > >  
{
 typedef mjm_glut_decorations_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_glut_decorations< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_glut_decorations_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{


}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_glut_decorations_map




////////////////////////////////////////////
#ifdef  TEST_MJM_GLUT_DECORATIONS
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_glut_decorations <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_GLUT_DECORATIONS "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_MSG(ss.str())

}
typedef mjm_ragged_table Ragged;
int main(int argc,char **args)
{
about();
typedef mjm_glut_decorations<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="loadragged") {
 	const IdxTy start=atoi(cip.wif(2).c_str()); 
	const IdxTy first=atoi(cip.wif(3).c_str()); 
	const IdxTy flags=atoi(cip.wif(4).c_str()); 
Ragged r; r.load(cip.p1); x.load(r,start,first,flags); }
if (cmd=="load") {x.load(cip.p1,atoi(cip.p2.c_str())); }
if (cmd=="save") {x.save(cip.p1,cip.p2); }
if (cmd=="quit") break;
// NB this does not work in gneral when errors are disabled
//if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="dump") { auto wtf=x.dump();  MM_ERR(wtf) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_GLUT_DECORATIONS_H__ 
