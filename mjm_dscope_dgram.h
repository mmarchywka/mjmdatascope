#ifndef MJM_DSCOPE_DGRAM_H__
#define MJM_DSCOPE_DGRAM_H__


#ifndef APP_VERSION
#define APP_VERSION 0
#endif

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_pthread_que.h"

#include "mjm_collections.h"
#include "mjm_canned_methods.h"
#include "mjm_string_kvp.h"
#include "mjm_so_loader.h"
#include "mjm_dscope_serial.h"
// no idea where to put this... 
#include "mjm_buffer_alloc.h"




#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>

#include <ctime>
#include <chrono>
#include <iostream>


// https://www.geeksforgeeks.org/udp-server-client-implementation-c/

#include <bits/stdc++.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
   
//#define PORT     8080
//#define MAXLINE 1024


// Client side implementation of UDP client-server model
#include <bits/stdc++.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
   
#define PORT     8080
#define MAXLINE 1024
   



// Wed Mar 15 17:28:50 EDT 2023
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_dscope_dgram   
// g++  -Wall -std=gnu++11 -DTEST_MJM_DSCOPE_DGRAM -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_dscope_dgram.h  -o mjm_dscope_dgram.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_dscope_dgram("mjm_dscope_dgram"
, "  ");

template <class Tr>
class mjm_dscope_dgram 
{
 typedef mjm_dscope_dgram Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
typedef mjm_thread_util<Tr> ThreadTy;
typedef pthread_t ThreadId; 

typedef mjm_string_kvp<Tr> StrKvp;
typedef mjm_so_loader<Tr> Loader;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line ;

typedef mjm_dscope_serial<Tr> Serializer;

typedef mjm_string_base_params<Tr> BaseParams;
enum {BAD=~0};

typedef unsigned char Data;

class _packet_time
{
typedef std::time_t Time;
typedef std::chrono::high_resolution_clock Hrc;
//static std::chrono::time_point<std::chrono::high_resolution_clock> now() noexcept;
typedef  std::chrono::time_point<Hrc> HRtime;

public:

_packet_time () 
{
    Time result = std::time(nullptr);
m_daze= result/86400;
m_sec=result=m_daze*86400;
m_raw=result;
m_hr=IdxTy(Hrc::now());
//return _packet_time(daze,sec,result);
//    std::cout << std::asctime(std::localtime(&result))
 //             << result << " seconds since the Epoch\n";
}

_packet_time(const IdxTy d, const IdxTy s, const std::time_t & r
) :m_daze(d),m_sec(s),m_raw(r) {}

_packet_time(Data * p, Serializer * sp, const IdxTy flags)
{

}
void serial(Data * p, Serializer * sp, const IdxTy flags) const
{

} // serial 

IdxTy m_daze, m_sec;
Time  m_raw;
IdxTy m_hr;
}; // _packet_time


// the packet needs a header and shoudl accomodate variable length 
// crap send and redeive
// also needs to optionally free its own packet memroy
class _dscope_dgram_payload
{
typedef  _dscope_dgram_payload Pkt;

// TODO FIXME needs time and serial 
//enum{FIELDSZ=8,COOKIE=0, VERSION=FIELDSZ, TYPE=(FIELDSZ*2), FRAG=(FIELDSZ*3),PAYSIZE=(FIELDSZ*4), PAYOFF=(FIELDSZ*5),PAYLOAD=(FIELDSZ*6)};
//enum{HDRSZ=PAYLOAD};
// THIS  SAILED BECAUSE THE  ints are only 32 
// bits K 
//enum{ FRAGBITS=16, FRAGBYTES=FRAGBITS>>3, FRAGMASK=(1<<(FRAGBITS)-1 };
struct _header_struct
{
typedef IdxTy Field;
typedef char By;
enum {FIELDSZ=sizeof(Field)} ;
Field m_cookie;
Field m_cookie_pad;
Field m_hdr_size; // implies payload location 
Field m_version;
Field m_type;
Field m_frag;
Field m_of;
Field m_serial;
Field m_time1;
Field m_time2;
void write(Field & f, const Field n)
{ By * p=(By*)&f; for(IdxTy i=0; i<FIELDSZ; ++i) p[i]=(n>>(i<<3)); }
//void read(Field & f, const Field&  n)const 
//{ By * p=(By*)&f; for(IdxTy i=0; i<FIELDSZ; ++i) p[i]=(n>>(i<<3)); }
Field read(const Field & _f)  const 
{ 
//if (true) return _f; 
//const Field * f= & _f; 
Field x=0;  const By * p=(const By*) &_f; 
 for(IdxTy i=0; i<FIELDSZ; ++i){ x<<=8; x|=(unsigned char) p[FIELDSZ-i-1]; } return x;  }


//StrTy cookie() const { return StrTy((By*)&m_cookie,FIELDSZ); }  
StrTy cookie() const { return StrTy((By*)&m_cookie,8); }  
//void cookie(const StrTy & s)  { memset(&m_cookie,s.c_str(),FIELDSZ); }  
void cookie(const StrTy & s)  { memcpy(&m_cookie,s.c_str(),8); }  
StrTy dump() const 
{
Ss ss;
ss<<MMPR4(cookie(),read(m_hdr_size), read(m_version),read(m_frag));
ss<<MMPR(read(m_type));
return ss.str();
} // dump 
}; // _header_struct
typedef _header_struct Header;
enum {HDRSZ=sizeof(_header_struct) };
struct _properties
{
_properties() : remote_ipv4(0) {}
IdxTy remote_ipv4;

}; // _properties
typedef _properties Properties;
public:

_dscope_dgram_payload() { Init(); }
_dscope_dgram_payload(Serializer * ps) { Init(); m_s=ps;  }
~_dscope_dgram_payload() { Free(); } 
IdxTy size() const { return m_size; } 
const void * data() const { return m_data; } 
void header(const IdxTy t,const IdxTy frag=0, const IdxTy of=1)
{
m_h.write(m_h.m_type,t);
m_h.write(m_h.m_frag,frag);
m_h.write(m_h.m_of,of);

} // header
template <class Tp > void payload( const Tp  * p, const IdxTy sz)
{
// ok if expanding... 
if (m_data&&!m_owner) {MM_ERR(" can not clear old data ") }
if (m_data) Free();
IdxTy offset= m_h.read(m_h.m_hdr_size);
//MM_ERR(MMPR4(__FUNCTION__,sz,offset,m_h.dump()))
m_data = new Data[sz+offset];
memcpy(m_data,&m_h,HDRSZ); // need to use existin header size here
// may leave an undefined gap... 
int diff=int(offset)-int(HDRSZ);
if (diff>0) memset(m_data+HDRSZ,0,diff); // need to use existin header size here
memcpy(m_data+offset,p,sz);
m_size=sz+offset;
m_pc=sz+offset;
m_pad=0;
} // payload
// for incoming payloads
void set(const void * p, const IdxTy sz)
{// ok if expanding... 
if (m_data&&!m_owner) {MM_ERR(" can not clear old data ") }
if (m_data) Free();
IdxTy offset=0; //  m_h.read(m_h.m_hdr_size);
m_data = new Data[sz+offset];
memcpy(m_data,p,sz); // need to use existin header size here
if (sz>=HDRSZ)  memcpy(&m_h,m_data,HDRSZ);
else  memcpy(&m_h,m_data,sz);
// may leave an undefined gap... 
//int diff=int(offset)-int(HDRSZ);
//if (diff>0) memset(m_data+HDRSZ,0,diff); // need to use existin header size here
//memcpy(m_data+offset,p,sz);
m_size=sz;
m_pc=sz;
m_pad=0;
} // set 
// for incoming payloads

StrTy cookie() const { return "mjmscope"; } 
operator StrTy() const
{
if (m_size==BAD) return StrTy();
//return StrTy(m_data+m_h.m_hdr_size,m_size-m_h.m_hdr_size);
IdxTy hsz=m_h.read(m_h.m_hdr_size);
return StrTy((char*)(m_data+hsz),m_pc-hsz);
}
 
StrTy dump() const { Ss ss; ss<< MMPR4(m_pc,m_size,m_pad,m_owner); 
ss<<MMPR(m_p.remote_ipv4);
ss<<m_h.dump();
return ss.str();
} 
private:

void Init()
{
m_data=0;
m_pc=BAD;
m_size=BAD;
m_pad=BAD;
m_owner=false;
memset(&m_h,0,HDRSZ);
//MM_ERR(MMPR2(HDRSZ,m_h.dump()))
m_h.write(m_h.m_hdr_size,HDRSZ);
m_h.cookie(cookie());
//MM_ERR(MMPR(m_h.dump()))
m_s=0;
} // Init
void Free()
{
if (m_owner ) { delete[] m_data; } 

} // Free
Serializer* m_ps;

Properties m_p;
Header m_h;
Data * m_data;
IdxTy m_pc, m_size,m_pad; 
bool m_owner;
Serializer * m_s;
}; // _dscope_dgram_payload

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////

typedef  _dscope_dgram_payload dscope_dgram_payload;
typedef  dscope_dgram_payload Payload;

typedef mjm_pthread_que<Tr,Payload> PktQue;

public:
typedef Data data_type;
mjm_dscope_dgram() {Init(); }
~mjm_dscope_dgram() {Free();}
IdxTy send(const Ragged & r, const IdxTy flags=0)
{return Send(r,flags); } 
IdxTy get( Ragged & r, const IdxTy flags=0)
{return Get(r,flags); } 
IdxTy launch(const StrTy& s, const IdxTy flags )
{ return  Launch( s,  flags ); } 
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
static bool Bit(const IdxTy f, const IdxTy b)  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;
enum{ASCII_RAG=267};
enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mux.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mux.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
// don't pass this, need to put it somewhere safe, 
class ThParam
{
public:
ThParam() :p(0),flags(0) {}
Myt * p;
StrTy s;
IdxTy flags;
typedef IdxTy (Myt:: * pFunc)(const StrTy & s,const IdxTy flags );
pFunc func;

}; // ThParam
IdxTy Launch(const StrTy& s, const IdxTy flags )
{ // the parameter here is a kluge anyway just ignore 
ThParam *  tp = new ThParam() ;
//StrTy * sp= new StrTy(s);
tp->s=s;
tp->p=this;
tp->flags=flags;
ThreadId * dest=0;
tp->func=&Myt::Start;
IdxTy sw=flags&15;
switch (sw)
{
case 0: { dest=&m_cc; tp->func=&Myt::StartControlClient; break; }
case 1: { dest=&m_cs; tp->func=&Myt::StartControlServer; break; }
case 2: { dest=&m_dc; tp->func=&Myt::StartDataClient; break; }
case 3: { dest=&m_ds; tp->func=&Myt::StartDataServer; break; }
default:
MM_ERR(" no function "<<MMPR4(flags,sw,s,__FUNCTION__))
}// switch 
// this needs to know what kind of thread it is,
// duplicate logic lateer.. 
ThreadId thread=ThreadTy::launch(& Myt::_Launch,tp);
*dest=thread;
// wait upto a second or two for display to draw 
//IdxTy cnt=0;
//while (!m_displayed )
//{ usleep(10000); ++cnt; if (cnt>200) { MM_ERR(" no display ") break; }  }
return 0;
}
static void *  _Launch( void * x) { ThParam * tp =(ThParam*)x; 
Myt * p = tp->p; StrTy s=tp->s; IdxTy flags=tp->flags;  
auto pFunc=tp->func;
delete tp;  
//p->Start(s,flags); 
(p->*pFunc)(s,flags); 

return 0; }
IdxTy StartControlClient(const StrTy & s,const IdxTy flags )
{
IdxTy rc=0;
MM_ERR(MMPR2(__FUNCTION__,flags))
BaseParams sk(s);

return rc;
} // StartControlClient

IdxTy StartControlServer(const StrTy & s,const IdxTy flags )
{
IdxTy rc=0;
MM_ERR(MMPR2(__FUNCTION__,flags))
BaseParams sk(s);

return rc;
} // StartControlServer
IdxTy Send(const Ragged & r, const IdxTy flags=0)
{
IdxTy rc=0;
Ss ss; ss<<r.dump_ssv(); 
if (false){  
MM_ERR(MMPR(ss.str())) }
Payload *  pload = new Payload(&m_s);
pload->header(ASCII_RAG,0,1);
pload->payload(ss.str().c_str(),ss.str().length());
m_sq.push(pload);
//MM_ERR(" queeded pkt to send "<<MMPR2(m_sq.size(),pload->size()))
return rc;
} // Send 
IdxTy Get( Ragged & r, const IdxTy flags=0)
{
IdxTy rc=0;
//Ss ss;
//ss<<r.dump_ssv();
//MM_ERR(MMPR2(__FUNCTION__,m_rq.size()))

Payload *  pload =m_rq.next(); //  new Payload(&m_s);
try { 
if (!pload) return BAD;
StrTy s=StrTy(*pload); // ->payload,pload.size());
//MM_ERR(MMPR2(pload->dump(),s))
//pload->header(ASCII_RAG,0,1);
//pload->payload(ss.str().c_str(),ss.str().length());
//m_sq.push(pload);
Ss ss(s);
//r.load(ss);
r.load_stop(ss,">FILE");
//MM_ERR(r.dump_ssv())
} catch (...) { MM_ERR(" error in Get ") } 
if (false) MM_ERR(MMPR2(__FUNCTION__,r.size()))
delete pload;
//MM_ERR(" queeded pkt to send "<<MMPR2(m_sq.size(),pload->size()))
return rc;
} // Send 


StrTy Myip(IdxTy n)
{
Ss ss;
// this  is the right  order  
std::vector<IdxTy> v;
IdxTy i=4; while (i) { ss<<(n&255); n>>=8; if (i) ss<<"."; --i; } 
//IdxTy i=4; while (i) { v.push_back(n&255); n>>=8;  --i; } 
//for(IdxTy i=0; i<4; ++i) {ss<<v[3-i]; if (i!=3) ss<<"."; }  
return ss.str();
} // Myip
IdxTy Sht(const StrTy fcker) 
{
MM_ERR(MMPR(__FUNCTION__))
const char * p =fcker.c_str();
IdxTy sht=0;
IdxTy sp=0;
IdxTy pc=0;
// instead of fixing this order fix it at the  end. 
while (p[pc]!=0)
{
if (p[pc]=='.') { sht<<=8; IdxTy ass=myatoi(p+sp); sht|=(ass&255);  ++pc; sp=pc; continue ; } 
++pc;
} // p 
if (sp!=pc) { sht<<=8; IdxTy ass=myatoi(p+sp); sht|=(ass&255); } 
MM_ERR(" return but first fix the sht "<<MMPR2(sht,__FUNCTION__))
unsigned char fck=sht&255;
unsigned char fck1=(sht>>8)&255;
unsigned char fck2=(sht>>16)&255;
unsigned char fck3=(sht>>24)&255;
sht=(fck<<24)|(fck1<<16)|(fck2<<8)|fck3;

MM_ERR(" return  "<<MMPR2(sht,__FUNCTION__))
return sht;
}
// FIXME doh put this somwhere lol 
typedef mjm_canned_methods SHTT;
int myatoi(const StrTy & s ) const { return SHTT::myatoi(s.c_str()); }
int myatoi(const char * c) const { return SHTT::myatoi(c); }

IdxTy StartDataClient(const StrTy & s,const IdxTy flags )
{
IdxTy rc=0;
MM_ERR(MMPR2(__FUNCTION__,flags))
BaseParams sk(s);
int port=31697;
//int ipv4= 0x07F000001;
// no error but nothing on tcp dump  
int ipv4= 0x0100007f;
sk.get(port,"port");
sk.get(ipv4,"ipv4");
StrTy fcker;
sk.get(fcker,"ipv4s");
if (fcker.length()) ipv4=Sht(fcker);
MM_ERR(MMPR2(port,Myip(ipv4)))


    int sockfd;
//    char buffer[MAXLINE];
 //   const char *hello = "Hello from client";
    struct sockaddr_in     servaddr;
   
    // Creating socket file descriptor
    if ( (sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }
   
    memset(&servaddr, 0, sizeof(servaddr));
      //int A=(127<<24)+1; 
//      int A=(1<<24)+127; 
    // Filling server information
    servaddr.sin_family = AF_INET;
    //servaddr.sin_port = htons(port);
    servaddr.sin_port = htons(port);
    //servaddr.sin_addr.s_addr = INADDR_ANY;
// this work s
//    servaddr.sin_addr.s_addr = A;
//servaddr.sin_addr.s_addr = htons(ipv4);
servaddr.sin_addr.s_addr = (ipv4);
while (true)
{       

//MM_ERR("  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA getting nex t");
Payload *  pload = m_sq.next();
//MM_ERR(" AAAAAAAAAAAAAAAAAAAAAAAAAAA have next "<<MMPR(pload));
if (pload==0) break; 

 //   int n;
 //   socklen_t len;
  // sending this will send back ICMP unreable packets  its
// not silent       
//    int rc=sendto(sockfd, (const char *)hello, strlen(hello),
int rc=    sendto(sockfd,( pload->data()), (pload->size()),
        MSG_CONFIRM, (const struct sockaddr *) &servaddr, 
            sizeof(servaddr));
if (false) MM_ERR(" sento "<<MMPR(rc));
//    std::cout<<"Hello message sent."<<std::endl;
    //MM_ERR(" acket sent "<< MMPR4(rc,errno,pload->size(),pload->dump())<<MMPR(perror()))      
//    MM_ERR(" acket sent "<< MMPR4(rc,errno,pload->size(),pload->dump()))      
 //   n = recvfrom(sockfd, (char *)buffer, MAXLINE, 
 //               MSG_WAITALL, (struct sockaddr *) &servaddr,
 //               &len);
 //   buffer[n] = '\0';
 //   std::cout<<"Server :"<<buffer<<std::endl;
 delete pload;
 
} // true
MM_ERR(" leaving "<<MMPR(__FUNCTION__))  
    close(sockfd);

return rc;
} // StartDataClient

IdxTy StartDataServer(const StrTy & s,const IdxTy flags )
{
IdxTy rc=0;
MM_ERR(MMPR2(__FUNCTION__,flags))
BaseParams sk(s);
int port=31697;
//int ipv4= 0x07F000001;
// no error but nothing on tcp dump  
int ipv4= 0x0100007f;
sk.get(port,"port");
sk.get(ipv4,"ipv4");
StrTy fcker;
sk.get(fcker,"ipv4s");
if (fcker.length()) ipv4=Sht(fcker);
MM_ERR(MMPR2(port,Myip(ipv4)))

    int sockfd;
// have memory blocks....   
  char buffer[1<<16];
//    const char *hello = "Hello from server";
    struct sockaddr_in servaddr, cliaddr;
       
    // Creating socket file descriptor
    if ( (sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }
       
    memset(&servaddr, 0, sizeof(servaddr));
    memset(&cliaddr, 0, sizeof(cliaddr));
       
    // Filling server information
    servaddr.sin_family    = AF_INET; // IPv4
    //servaddr.sin_addr.s_addr = INADDR_ANY;
    servaddr.sin_addr.s_addr = ipv4;
    //servaddr.sin_port = htons(PORT);
    servaddr.sin_port = htons(port);
       
    // Bind the socket with the server address
    if ( bind(sockfd, (const struct sockaddr *)&servaddr, 
            sizeof(servaddr)) < 0 )
    {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

     while (true) {   
    socklen_t len;
  int n;
 // MM_ERR(" SSSSSSSSSSSSSSSSSSS wait for pacet") 
    len = sizeof(cliaddr);  //len is value/result
  // 65k is not a lot to waste for a few buffers...  
    n = recvfrom(sockfd, (char *)buffer, 1<<16, 
                MSG_WAITALL, ( struct sockaddr *) &cliaddr,
                &len);
  //MM_ERR(" SSSSSSSSSSSSSSSSSSS have  pacet"<<MMPR2(n,m_rq.size()) ) 
//    buffer[n] = '\0';

Payload *  pload = new Payload(&m_s);
pload->set((Data*)buffer,n);
//pload->header(ASCII_RAG,0,1);
//pload->payload(ss.str().c_str(),ss.str().length());
m_rq.push(pload);
// need to prune m_rq from front ...


} // truel 

  //  printf("Client : %s\n", buffer);
   // sendto(sockfd, (const char *)hello, strlen(hello), 
   //     MSG_CONFIRM, (const struct sockaddr *) &cliaddr,
   //         len);
//    std::cout<<" Hello message sent."<<std::endl; 
 MM_ERR("SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSexit" << MMPR(__FUNCTION__))       

return rc;
} // StartDataServer







//static IdxTy _Start(const StrTy & s ) { return p()->Start(s); }
IdxTy Start(const StrTy & s,const IdxTy flags )
{
IdxTy rc=0;
MM_ERR(MMPR2(__FUNCTION__,flags))
BaseParams sk(s);

return rc;
} // Start


void Init()
{
m_mux=MutexVector(5);
m_cs=0;
m_ds=0;
m_cc=0;
m_dc=0;
m_sq.limit(20);
m_rq.limit(20);
} // Init
void Free()
{

} // Free

// MEMBERS
MutexVector m_mux;
ThreadId m_cs,m_cc,m_ds,m_dc;
Serializer m_s;
PktQue m_sq,m_rq;
}; // mjm_dscope_dgram

//////////////////////////////////////////////

template <class Tr>
class mjm_dscope_dgram_map : public std::map<typename Tr::StrTy, mjm_dscope_dgram< Tr > >  
{
 typedef mjm_dscope_dgram_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_dscope_dgram< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_dscope_dgram_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_dscope_dgram_map




////////////////////////////////////////////
#ifdef  TEST_MJM_DSCOPE_DGRAM
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_dscope_dgram <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_DSCOPE_DGRAM "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_dscope_dgram<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//if (cmd=="xxx") { MM_ERR(xxxmain()) }
//if (cmd=="yyy") { MM_ERR(yyymain()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_DSCOPE_DGRAM_H__ 
