#ifndef MJM_DSCOPE_INTERFACE_H__
#define MJM_DSCOPE_INTERFACE_H__

#define NO_DSCOPE_GRAPHICS


#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_block_matrix.h"
#include "mjm_instruments.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_worm_blob.h"
#include "mjm_collections.h"
//#include "mjm_tokenized_collections.h"
#include "mjm_canned_methods.h"
#include "mjm_dscope_sender.h"
#include "mjm_dohscope_buffer.h"

#include "mjm_pawnoff.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_generic_iterators.h"



#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


/*
<one line to give the program's name and a brief idea of what it does.>


Conceived and written by Mike Marchywka from 2023 to present.
See dates in individual code pieces as they were 
generated from my wizards. 
Copyright (C) <year> <name of author>


This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
@software{,
  author = {Michael J Marchywka},
  city = {Jasper GA 30143 USA},
  title = {},
abstract={},
institution={},
license={Knowledge sir should be free to all },
publisher={Mike Marchywka},
email={marchywka@hotmail.com},
authorid={orcid.org/0000-0001-9237-455X},
  filename={mjm_dscope_interface.h},
  url = {},
  version = {0.0.0},
  date-started={2023-07-30},
}
*/

// Sun 30 Jul 2023 03:54:17 PM EDT
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_dscope_interface   
// QUICKCOMPILE  g++  -Wall -Wno-misleading-indentation  -std=gnu++11 -DTEST_MJM_DSCOPE_INTERFACE -I../freefem -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_dscope_interface.h  -o mjm_dscope_interface.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_dscope_interface("mjm_dscope_interface" , "  ");

class Tr_dscope_defaults {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 





template <class Tr=Tr_dscope_defaults>
class mjm_dscope_interface 
{
 typedef mjm_dscope_interface Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

// TYPEDEF 
enum { BAD=~0};
//typedef mjm_canned_methods Canned;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map<StrTy, Ragged> RaggedMap;
typedef std::vector<StrTy> Words;
typedef mjm_string_base_params<Tr> BaseParams;
typedef mjm_block_matrix<D> Block;
typedef mjm_datascope Sender;
typedef std::vector<StrTy> ColTy;

typedef mjm_dohscope_buffer<Tr> Buffer;

class _point
{
public:
enum { WHITE=((1<<24)-1) };
_point(const D & a, const D & b, const D & c)
:m_x(a),m_y(b),m_z(c),m_sz(.01),m_rgb(WHITE),m_shape("circle") {}
_point(const D & a, const D & b, const D & c, const IdxTy rgb)
:m_x(a),m_y(b),m_z(c),m_sz(.01),m_rgb(rgb),m_shape("circle") {}
_point() : m_x(0),m_y(0),m_z(0),m_sz(.01),m_rgb(WHITE), m_shape("circle") {}
const D & theta() const { return 0; }
const D & x() const { return m_x; }
const D & y() const { return m_y; }
const D & z() const { return m_z; }
const D & sz() const { return m_sz; }
void  sz(const D & x)  {  m_sz=x; }
const IdxTy rgb() const { return m_rgb; }
void  rgb(const IdxTy x)  {  m_rgb=x; }
const StrTy & shape() const { return m_shape; }
//void Init_point() { } // Init_point
D m_x,m_y,m_z,m_sz;
IdxTy m_rgb;
// point type?
StrTy m_shape;

}; // _point




// API
enum {DROPWARN=0 };
public:
typedef _point simple_point_t;
typedef Tr traits_type;
mjm_dscope_interface() {Init(); }
mjm_dscope_interface(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
mjm_dscope_interface(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}
mjm_dscope_interface(const Myt & that ) {Init(); (*this)=that; }
Myt & operator=(const Myt & that)
{
// in essence this makes a member of Myt const lol.
// and is probably what is meant. 
//m_sender=that.m_sender;
//m_fast_drop=that.m_fast_drop;
//m_state=that.m_state;
MM_ERR(" assigning dscope_interface not define "<<MMPR(__FUNCTION__))
return *this;
}
void load_fifo() { load(m_default_load,0); } 
void load(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
void load(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}
void warn_fast_drop(const bool x ) { Set(m_state,DROPWARN,x); }
bool warn_fast_drop() const { return Bit(m_state,DROPWARN); }
void save(const StrTy & fn,const StrTy &s) {Save(fn,s); }
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
// may avoid a lot of wasted work on want to wait... 
// FIXME need to abstract channel not "rawfifo" 
bool que_full() const { return m_sender.m_rawfifo.full();  } 
bool que_empty() const { return m_sender.m_rawfifo.empty();  } 
// WTF tis should not need to wait wtf????
bool launch_default() {load("rawfifo launch  2",0); usleep(100000); return true;}
bool send( const Ragged & r, const Block & data, const IdxTy flags)
{ return Send(r,&data,flags); } 
bool send( const Ragged & r,  const IdxTy flags)
{ return Send(r,NULL,flags); } 
bool send_strip_chart( const Ragged & r,  const StrTy & src,const StrTy & params, const IdxTy flags)
{ return SendStripChart(r,src,params,flags); } 
// TODO this needs multiple instances now with tiggering and 
// buffering on the source side. In most cases a name is included
// to be sorted out by viewers. 
StrTy set_oscope_trigger(const StrTy & scope, const StrTy & sin, const IdxTy flags) { m_bufs[scope].set_trigger(sin,flags);  return StrTy(); }  

StrTy set_oscope_samples(const StrTy & scope, const StrTy & sin, const IdxTy flags) { m_bufs[scope].set_samples(sin,flags);  return StrTy(); }  

StrTy set_oscope(const StrTy & scope, const StrTy & sin, const IdxTy flags) { m_bufs[scope].set_params(sin,flags);  return StrTy(); }  

template <class Tp> 
bool send_oscope(const Tp & _x, const Tp & _y,  const StrTy& src, const IdxTy line, const StrTy & scope_name=StrTy(), const StrTy idn=StrTy(), const StrTy & etc=StrTy(),const StrTy & params=StrTy(), const StrTy & _ty="chunks", const IdxTy flags=0)
{return  SendOscope( _x,  _y,  src, line, idn, etc, params,  _ty,flags,scope_name); } 


bool send_decorations( const Ragged & r,  const StrTy & src,const StrTy & params, const IdxTy flags)
{ return SendDecorations(r,src,params,flags); } 
bool send_molecule( const Ragged & r,  const StrTy & src,const StrTy & params, const IdxTy flags)
{ return SendMolecule(r,src,params,flags); } 

IdxTy send_block( const Block & data, const StrTy & params, const ColTy & col_names,  const StrTy & src,const IdxTy flags)
{ return SendBlock(data,params,col_names,src,flags); } 
//  for initial use with mjm_coherent_rag in mjm_svg_writer
// and a ragged of form header followed by colors and taxonomy
// although better is a compact form with taxonomy table
// followed by rows of counts or colors and single tax entry
// this may be indicated in flags later. 
// for now, ntax is number of trailing taxonomy columns 
IdxTy send_heatmap( const Ragged & r, const IdxTy ntax, const StrTy & params, const StrTy & src,const IdxTy flags)
{ return SendHeatmap(r,ntax,params,src,flags); } 
// this paradigm avoids some copy of large ragged isues
// as there is no easy header pre-prend although may
// "send" with two raggeds is better 
IdxTy setup_heatmap(Ragged & r, const IdxTy ntax, const StrTy &etc, const StrTy & sid, const StrTy & ty,const StrTy & params)
{ return  SetupHeatmap(r, ntax, etc, sid,  ty,params);}

IdxTy send_stream( IsTy & is, const StrTy & ty, const StrTy & src,const IdxTy flags=0)
{ return SendStream(is,ty,src,flags); }
IdxTy send_file( const StrTy  & fn, const StrTy & ty, const StrTy & src,const IdxTy flags=0)
{ return SendFile(fn,ty,src,flags); }
IdxTy setup(Ragged & r, const StrTy & sid, const StrTy & ty,const StrTy & params ="")
{ return Setup(r, sid, ty,params); } 

StrTy angle_color(const D & t) const { return theta_color(t); } 
// TODO call back or notifier on exit?
bool wait_done(const IdxTy n, const IdxTy mu)
{ IdxTy i=0;
while (!que_empty()) { usleep(mu); ++i; if (i>=n) break; }
if (false) { MM_ERR(" cmd "<<MMPR3(__FUNCTION__,i,que_empty())) }
return que_empty();
} // WaitDone




~mjm_dscope_interface() {}


D dmod( const D & x, const D & m)
{return x-int(x/m)*m-.5*m; }
StrTy to_color(const IdxTy n)
{
Ss ss;
ss<<"#"<<std::hex<<n;
return ss.str();
} // to_color

StrTy  theta_color(const D & t)
{
const D m=2*M_PI;
IdxTy i=0;
D r=2.0*255*fabs(dmod(t,m)/m);
D g=2.0*255*fabs(dmod(t+m/3.0,m)/m);
D b=2.0*255*fabs(dmod(t+2.0*m/3.0,m)/m);
i=(int(r)&255);
i|=(int(g)&255)<<8;
i|=(int(b)&255)<<16;
Ss ss;
ss<<"#"<<std::hex<<i;

if (r<2) if (g<2) if (b<2)
MM_ERR(MMPR4(r,g,b,ss.str()))

//MM_ERR(MMPR(ss.str()))
return ss.str();
} // theta_color


private:



int myatoi(const StrTy & s )const   { return mjm_canned_methods::myatoi(s.c_str()); }
int myatoi(const char * c) const  { return mjm_canned_methods::myatoi(c); }
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
void Set(IdxTy& f, const IdxTy b,const bool x) //const  
	{ if (x) f|=(1<<b); else f&=((~1)<<b); }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


void Save(const StrTy & fn,const StrTy &s) {
// std::ofstream ofs(fn);

 } // Save

#if 0 

Ragged r;
{ Line l; l.push_back("#"); l.push_back("id"); l.push_back("test pattern chunks "); l.push_back(idn);  r.add(l); }
{ Line l; l.push_back("#"); l.push_back("oscilloscope"); l.push_back("chunks"); r.add(l); }

{ Line l; l.push_back("#"); l.push_back("trace"); Ss ss; ss<<line;  l.push_back(ss.str()); r.add(l); }
for(IdxTy i=0; i<200; ++i)
{
Line l;
D y=sin(time*.1);
{ Ss ss; ss<<time; l.push_back(ss.str()); }
{ Ss ss; ss<<y; l.push_back(ss.str()); }
r.add(l);
time=time+dt;
} // i 
MM_ERR(MMPR4(line,__FUNCTION__,rawf,r.size()))
if (rawf) m_rawfifo.send(r);
else m_dgrams.send(r);


#endif
IdxTy Setup(Ragged & r, const StrTy & sid, const StrTy & ty,const StrTy & params)
{
Ss ss;
ss<<"# id "<<sid<<CRLF;
ss<<"# "<<ty<<CRLF;
if (params.length()) { ss<<"# params "<<params<<CRLF; } 
r.load(ss,false);
return 0;
} // Setup
IdxTy SetupHeatmap(Ragged & r, const IdxTy ntax, const StrTy &etc, const StrTy & sid, const StrTy & ty,const StrTy & params)
{
Ss ss;
ss<<"# id "<<sid<<CRLF;
ss<<"# "<<ty<<CRLF;
ss<<"# etc ntax "<<ntax;
if (etc.length()) { ss<<" "<<etc; }
ss<<CRLF;
if (params.length()) { ss<<"# params "<<params<<CRLF; } 
r.load(ss,false);
return 0;
} // SetupHeatmap

IdxTy SendHeatmap( const Ragged & r, const IdxTy ntax, const StrTy & params, const StrTy & src,const IdxTy flags)
{
if (SendGuard(flags)) return false;
Ragged rh;
SetupHeatmap(rh,ntax,"",src,"heatmap",params);
m_sender.m_rawfifo.send(rh,r);
return 0; 
} //  SendHeatmap 


#if 0


Ragged r;
{ Line l; l.push_back("#"); l.push_back("id"); l.push_back("test pattern chunks "); l.push_back(idn);  r.add(l); }
{ Line l; l.push_back("#"); l.push_back("oscilloscope"); l.push_back("chunks"); r.add(l); }

{ Line l; l.push_back("#"); l.push_back("trace"); Ss ss; ss<<line;  l.push_back(ss.str()); r.add(l); }

for(IdxTy i=0; i<200; ++i)
{

#endif
//} // Setup


IdxTy SetupOscope(Ragged & r, const StrTy &  idn, const StrTy &sid, const IdxTy line, const StrTy & etc=StrTy(), const StrTy & _ty="chunks",const StrTy & params=StrTy())
{

/*
Ss ss;
ss<<"# id "<<sid<<CRLF;
ss<<"# "<<ty<<CRLF;
if (params.length()) { ss<<"# params "<<params<<CRLF; }
r.load(ss,false);

*/

//const StrTy ty="oscilloscope";
//const StrTy t2="chunks";
//const StrTy idn="1";
{ Line l; l.push_back("#"); l.push_back("id"); l.push_back(sid); if ( idn.length()) l.push_back(idn);  r.add(l); }
{ Line l; l.push_back("#"); l.push_back("oscilloscope"); if (_ty.length()) l.push_back(_ty); r.add(l); }
{ Line l; l.push_back("#"); l.push_back("trace"); Ss ss; ss<<line;  l.push_back(ss.str()); r.add(l); }
//Ss ss;
//ss<<"# id "<<sid<<" "<<idn<<CRLF;
//ss<<"# "<<ty<<" "<<t2<<CRLF;
//ss<<"# etc ntax "<<ntax;
if (etc.length()) {Ss ss;  ss<<"# "<<etc; r.load(ss,false); }
//ss<<CRLF;
if (params.length()) { Ss ss;  ss<<"# params "<<params<<CRLF; r.load(ss,false);  } 
//r.load(ss,false);
if (false) MM_ERR(MMPR(r.dump()))
return 0;
} // SetupOscope




IdxTy SendBlock( const Block & data, const StrTy & params, const ColTy & col_names,  const StrTy & src, const IdxTy flags)
{
Ss ss;
ss<<"# id "<<src<<CRLF;
ss<<"# time-snap 1D "<<CRLF;
ss<<"# trace "<<CRLF;
ss<<"# params "<<params<<CRLF;
// NB this depends on index order matching the species map...
ss<<"# names";
MM_LOOP(ii,col_names) {  ss<<" "<<(*ii).first; }
ss<<CRLF;
Ragged r;
r.load(ss,false);
send(r,data,0);
return 0;
} // SendBlock 
IdxTy SendFile( const StrTy & fn, const StrTy & ty, const StrTy & src,const IdxTy flags=0)
{
std::ifstream is(fn);
return SendStream(is,ty,src,flags); 
}
IdxTy SendStream( IsTy & is, const StrTy & ty, const StrTy & src,const IdxTy flags=0)
{
Ragged r;
Ss ss;
// must have len of at least 3 
ss<<"# id "<<src<<CRLF;
ss<<"# "<<ty<<CRLF;
ss<<">FILE"<<CRLF;
r.load(ss,false);
r.noparse_stop(is,"");
send(r,0);
return 0;
}// SendStream

IdxTy SendGuard(const IdxTy flags)
{

const bool send_if_full=Bit(flags,0);
if (!send_if_full) if (m_sender.m_rawfifo.full()){ ++m_fast_drop; 
if (warn_fast_drop())
	if ((m_fast_drop%100)==0)
	{  MM_ERR(" fast dropping dscope "<<MMPR(m_fast_drop)) }
 return BAD ;  }

return 0;
} // SendGuard

//void Send( const Ragged & r, const Block & data, const IdxTy flags)
bool  Send( const Ragged & r, const Block * pdata, const IdxTy flags)
{
/*
const bool send_if_full=Bit(flags,0);
if (!send_if_full) if (m_sender.m_rawfifo.full()){ ++m_fast_drop; 
if (warn_fast_drop())
	if ((m_fast_drop%100)==0)
	{  MM_ERR(" fast dropping dscope "<<MMPR(m_fast_drop)) }
 return ;  }
*/
if (SendGuard(flags)) return false;
//MM_ERR(MMPR3(data.nx(),data.ny(),pload.size()))
if (pdata)
{
Ragged pload =r; 
// TODO this is generating a _ on th svg send?
Line l;
pload.add(l);
const Block & data=*pdata;
pload.append_generic_block(data,data.nx(),data.ny(),0);

m_sender.m_rawfifo.send(pload);
}
else m_sender.m_rawfifo.send(r);
return true; 
}  // Send

bool  SendStripChart( const Ragged & r, const StrTy& src, const StrTy & params, const IdxTy flags)
{
if (SendGuard(flags)) return false;
//MM_ERR(MMPR3(data.nx(),data.ny(),pload.size()))
Ragged h;
setup(h, src, "strip-chart",params );
m_sender.m_rawfifo.send(h,r);
return true; 
}  // SendStripChart
template <class Tp>
bool  SendOscopeB(const Tp & _x, const Tp & _y,  const StrTy& src, const IdxTy line, const StrTy idn,  const StrTy & etc,const StrTy & params, const StrTy & _ty, const IdxTy flags,const StrTy & scope_name)
{
Buffer& _buf=m_bufs[scope_name];
_buf.samples(_x,_y,src,line,idn,etc,params,_ty,flags); 
if (SendGuard(flags)) return false;
while (_buf.traces())
{
Ragged h;
 SetupOscope(h, idn, src, line, etc,  _ty, params);
const Ragged & r=_buf.trace();
m_sender.m_rawfifo.send(h,r);
_buf.take();
} // traces

return true;
} // SendOscopeB
template <class Tp>
bool  SendOscope(const Tp & _x, const Tp & _y,  const StrTy& src, const IdxTy line, const StrTy idn,  const StrTy & etc,const StrTy & params, const StrTy & _ty, const IdxTy flags, const StrTy & scope_name)
{

//if (true) return SendOscopeB(_x,_y,src,line,idn,etc,params,_ty,flags,scope_name); 
if (scope_name.length()) 
	return SendOscopeB(_x,_y,src,line,idn,etc,params,_ty,flags,scope_name); 
if (SendGuard(flags)) return false;
//MM_ERR(MMPR3(data.nx(),data.ny(),pload.size()))
Ragged h;
 SetupOscope(h, idn, src, line, etc,  _ty, params);
//setup(h, src, "strip-chart",params );
//SetupOscope(h,ntax,etc,sid,ty,params);
Ragged r;
const IdxTy sz=_x.size();
for(IdxTy i=0; i<sz; ++i)
{
Line l;
D x=_x[i];
D y=_y[i];
{ Ss ss; ss<<x; l.push_back(ss.str()); }
{ Ss ss; ss<<y; l.push_back(ss.str()); }
r.add(l);
//++m_line;
} // i 
m_sender.m_rawfifo.send(h,r);
return true; 
}  // SendOscope



bool  SendDecorations( const Ragged & r, const StrTy& src, const StrTy & params, const IdxTy flags)
{
if (SendGuard(flags)) return false;
//MM_ERR(MMPR3(data.nx(),data.ny(),pload.size()))
Ragged h;
setup(h, src, "decorations",params );
MM_ERR(MMPR4(__FUNCTION__,h.size(),r.size(),flags))
m_sender.m_rawfifo.send(h,r,flags);
return true; 
}  // SendDecorations


bool  SendMolecule( const Ragged & r, const StrTy& src, const StrTy & params, const IdxTy flags)
{
if (SendGuard(flags)) return false;
//MM_ERR(MMPR3(data.nx(),data.ny(),pload.size()))
Ragged h;
setup(h, src, "molecule",params );
m_sender.m_rawfifo.send(h,r);
return true; 
}  // SendMolecule



void Init(const Ragged & r, const IdxTy start=0, const IdxTy first=0, const IdxTy flags=0  )
{
Init();
const IdxTy sz=r.size();
for(IdxTy i=start; i<sz; ++i)
{
//const Line & l=r[i];
//const IdxTy len=l.size();


}  // i 

} // Init 
void Init(const StrTy  & sin,const IdxTy flags =0  )
{
Init();
// TODO FIXME this needs to be fixed before becoming used in 
// all example interfaces doh.. 
BaseParams kvp(sin);
m_sender.command_mode(sin);

} // Init 

void Init()
{
m_fast_drop=0;
m_state=0;
m_default_load="rawfifo launch  2";
} // Init



// MEMBERS
Sender m_sender;
IdxTy m_fast_drop;
IdxTy m_state;
StrTy m_default_load;
typedef std::map<StrTy,Buffer> ScopeBuffers;
ScopeBuffers m_bufs;
//Buffer m_buf;
}; // mjm_dscope_interface

//////////////////////////////////////////////

template <class Tr>
class mjm_dscope_interface_map : public std::map<typename Tr::StrTy, mjm_dscope_interface< Tr > >  
{
 typedef mjm_dscope_interface_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_dscope_interface< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_dscope_interface_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{


}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_dscope_interface_map




////////////////////////////////////////////
#ifdef  TEST_MJM_DSCOPE_INTERFACE
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_dscope_interface <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_DSCOPE_INTERFACE "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}
typedef mjm_ragged_table Ragged;
int main(int argc,char **args)
{
about();
typedef mjm_dscope_interface<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="loadragged") {
 	const IdxTy start=atoi(cip.wif(2).c_str()); 
	const IdxTy first=atoi(cip.wif(3).c_str()); 
	const IdxTy flags=atoi(cip.wif(4).c_str()); 
Ragged r; r.load(cip.p1); x.load(r,start,first,flags); }
if (cmd=="load") {x.load(cip.p1,atoi(cip.p2.c_str())); }
if (cmd=="save") {x.save(cip.p1,cip.p2); }
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_DSCOPE_INTERFACE_H__ 
