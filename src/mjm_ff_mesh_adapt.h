#ifndef MJM_FF_MESH_ADAPT_H__
#define MJM_FF_MESH_ADAPT_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_ff_mesh.h"
#include "mjm_instruments.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_canned_methods.h"
#include "mjm_cli_ui.h"
#include "mjm_tokenized_collections.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Sun 28 May 2023 04:28:42 AM EDT
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_ff_mesh_adapt   
// g++  -Wall -std=gnu++11 -DTEST_MJM_FF_MESH_ADAPT -Wno-misleading-indentation  -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_ff_mesh_adapt.h  -o mjm_ff_mesh_adapt.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_ff_mesh_adapt("mjm_ff_mesh_adapt"
, "  ");

template <class Tr>
class mjm_ff_mesh_adapt 
{
 typedef mjm_ff_mesh_adapt Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
// TYPEDEF 
enum { BAD=~0};
typedef mjm_canned_methods Canned;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map<StrTy, Ragged> RaggedMap;
typedef std::vector<StrTy> Words;
typedef mjm_string_base_params<Tr> BaseParams;

typedef mjm_ff_mesh<Tr> FfMesh;
typedef std::map<StrTy, FfMesh> MeshMap;
typedef FfMesh M;
class _cp
{
public:
_cp(const IdxTy n ) { bn=n; }


IdxTy bn;
}; // _cp
typedef _cp ConformalParams;

typedef typename M::path_type Path;
// API 
public:
mjm_ff_mesh_adapt() {}
~mjm_ff_mesh_adapt() {}
typedef FfMesh mesh_type;
typedef Path path_type;
typedef typename M::trail_type trail_type;
typedef typename M::dof_type dof_type;
typedef ConformalParams conformal_params_type;
IdxTy  load( const StrTy  & nm, const StrTy & fn, const IdxTy  & flags )
{ return m_meshs[nm].read_ff_mesh(fn, StrTy(),flags); }
IdxTy  save( const StrTy  & nm, const StrTy & fn, const IdxTy  & flags )
{ return m_meshs[nm].write(fn, StrTy(),flags); }
IdxTy  read_dof( const StrTy  & dof, const StrTy & fn, const StrTy & nm, const IdxTy  & flags )
{ return m_meshs[nm].read_dof(dof,fn,flags); }
IdxTy  write_dof( const StrTy  & dof, const StrTy & fn, const StrTy & nm, const IdxTy  & flags )
{ return m_meshs[nm].write_dof(dof,fn,flags); }
// IdxTy isotrail(const StrTy  & trailn, const StrTy & dofn, const D & v, const IdxTy flags) const
 IdxTy isotrail(const StrTy &nm, const StrTy  & trailn, const StrTy & dofn, const D & v, const IdxTy flags) 
{ return m_meshs[nm].isotrail(trailn,dofn,v,flags); } 
//const FfMesh & get_mesh(const StrTy &nm) { return m_meshs[nm];}  
 FfMesh & get_mesh(const StrTy &nm) { return m_meshs[nm];}  
 FfMesh & operator[](const StrTy &nm) { return m_meshs[nm];}  
const trail_type & get_trail(const StrTy & nm , const StrTy & trail)
{ return m_meshs[nm].get_trail(trail); } 
const dof_type & get_dof(const StrTy & nm , const StrTy & dof)
{ return m_meshs[nm].get_dof(dof); } 

//IdxTy adopt_dof(const StrTy & dof, const StrTy & oldmesh, Myt & thold, const IdxTy flags)

IdxTy  adopt_dof(const StrTy & nm , const StrTy & from, const StrTy & dof)
{ return m_meshs[nm].adopt_dof(dof,from,m_meshs[from],0); } 
void  clear_adopt(const StrTy & nm ) { m_meshs[nm].clear_adopt(); } 

IdxTy  conformal_mesh( const StrTy  & d, const StrTy & s, const ConformalParams & cp=ConformalParams() )
{ return conformal_mesh(m_meshs[d],m_meshs[s],cp); }
IdxTy  conformal_mesh( M & d, const M & s, const ConformalParams & cp )
{ return  ConformalMesh(  d,  s, cp ); } 
StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

// dealing only with triangles, made want a new center
// point 1 -> 3 triangles or a new edge bisection
// splitting 1 -> 2 triangles although not sure this ie legal
// in opposing direction, need to get P1 interpolation eqns etc.   


// for a given curve, insure that a distance range between 
// nodes is enforced by adding and removing node and maybe moving.
// Generate either a new mesh or a node/vertex  list for later triangulation. 
IdxTy  ConformalMesh( M & d, const M & s, const ConformalParams & cp )
{
IdxTy rc=0;
// find the relevant curve
Path path;
s.get_path(path,cp.bn,0);
s.dump_path("xxx.path",path,0);
s.dump_edges("xxx.edges",0);
// check ds 

// check normal coverage

// fix or make an idealized coverage 

// return eiteher a vertex list or a new mesh 

return rc;
} // ConformalMEsh

// MEMBERS
MeshMap m_meshs;


}; // mjm_ff_mesh_adapt

//////////////////////////////////////////////

template <class Tr>
class mjm_ff_mesh_adapt_map : public std::map<typename Tr::StrTy, mjm_ff_mesh_adapt< Tr > >  
{
 typedef mjm_ff_mesh_adapt_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_ff_mesh_adapt< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_ff_mesh_adapt_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_ff_mesh_adapt_map




////////////////////////////////////////////
#ifdef  TEST_MJM_FF_MESH_ADAPT
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_ff_mesh_adapt <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_FF_MESH_ADAPT "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_ff_mesh_adapt<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
else if (cmd=="load") { x.load(cip.p1,cip.p2,0); }
else if (cmd=="save") { x.save(cip.p1,cip.p2,0); }
else if (cmd=="conform") { x.conformal_mesh(cip.p1,cip.p2,5); }
else if (cmd=="dof") { x.read_dof(cip.p1,cip.p2,cip.wif(3),0); }
else if (cmd=="iso") { x.isotrail(cip.p1,cip.p2,cip.wif(3),atof(cip.wif(4).c_str()),0); }
//IdxTy  read_dof( const StrTy  & dof, const StrTy & fn, const StrTy & nm, const IdxTy  & flags )
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_FF_MESH_ADAPT_H__ 
