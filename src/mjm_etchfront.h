#ifndef MJM_ETCHFRONT_H__
#define MJM_ETCHFRONT_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_data_model_error_log.h"
#include "mjm_block_matrix.h"
#include "mjm_instruments.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"

#include "mjm_canned_methods.h"
#include "mjm_dscope_dgram.h"
#include "mjm_ff_band.h"
#include "mjm_etch_point.h"
#include "mjm_etch_curve.h"

#include "mjm_cli_ui.h"

#include "mjm_tokenized_collections.h"

#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Wed Apr 26 15:56:09 EDT 2023
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_etchfront   

// QUICKCOMPILE g++  -Wall -Wno-misleading-indentation  -std=gnu++11 -DTEST_MJM_ETCHFRONT -I. -I../../mjm/hlib -I../../mjm/num  -I../datascope -gdwarf-3 -O0  -x c++ mjm_etchfront.h  -o mjm_etchfront.out -lpthread -lreadline
/*
This seems to flatten more or less stably,

 2717  ./mjm_etchfront.out  -cmd "run planar_edges=false;cull_overlaps=1;interpolate=1;add_inter_point=0;debug=1;max_dist=.06;dt=50000;first=0;e0=2e-3" 2>&1

This is unstable and curls up on the left e0 is too high, 
see discussion below about maybe better way,
 ./mjm_etchfront.out  -cmd "run planar_edges=false;cull_overlaps=1;interpolate=1;add_inter_point=0;debug=1;max_dist=.06;dt=50000;first=0;e0=5e-3" 2>&1



Increasing the etch rate to 5e-3 sort of works but thee are volcanoes and
finally the left side starts a scroll likely going on forever.
There may be a left-right assymetry. The volcanoes go to the
left in about 1/2 the distance until reaching zero staritng the
scroll. The cusps are not stable as it fools the radius of curvature
measure right now. TODO FIXME this needs to be fixed 


                           *
                        *     * 
                     *           *
The above is ambiguous, with infinite curvature except at the
apex where it is pointing downward. 
It should etch faster but need to look at expression and I guess 
the "etch rate" can go negative ,

D elocal=ep.e0*(1-ep.e0*rv[i]); // rv is reciprocal roc 

TODO FIXME "exposed angle" may be a batter etch factor and
linearirzed for FEM? dr=n f(theta), theta =acos(-s1 dot s2/|s1||x2|)
which may be used in matric equn although need to handle overlap
etc. 

*/


// g++  -Wall -std=gnu++11 -DTEST_MJM_ETCHFRONT -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_etchfront.h  -o mjm_etchfront.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_etchfront("mjm_etchfront"
, "  ");

template <class Tr>
class mjm_etchfront 
{
 typedef mjm_etchfront Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
typedef mjm_canned_methods Canned;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map<StrTy, Ragged> RaggedMap;

typedef std::vector<StrTy> Words;

//typedef string_tokenizer Tokenizer;
////////////////////////////////////////////////////

typedef mjm_string_base_params<Tr> BaseParams;
// traits? 
enum {BAD=~0};
typedef mjm_dscope_dgram<Tr> DgramID;
typedef typename DgramID::data_type Data;
typedef mjm_thread_util<Tr> ThreadTy;
typedef pthread_t ThreadId;
typedef typename ThreadTy::template ThParam<Myt> ThParam;

typedef mjm_etch_point<Tr>  point_type;

typedef mjm_etch_curve<Tr,point_type> _Curve;



class _CurveCollection  : public std::vector<_Curve>
{

public:



}; // _CurveCollection

class _EtchParam
{
public:
_EtchParam(const StrTy & s ) { Init(s); } 
_EtchParam(int n ) { set(9); } 
_EtchParam() { set(0); } 
void Init(const StrTy & s)
{
BaseParams sk(s);
 set(31) ; // default to all on..  
sk.get(planar_edges,"planar_edges");
sk.get(cull_overlaps,"cull_overlaps");
sk.get(interpolate,"interpolate");
sk.get(add_inter_point,"add_inter_point");
sk.get(debug,"debug");
sk.get(max_dist,"max_dist");
sk.get(_maxfwd,"_maxfwd");
sk.get(dt,"dt");
sk.get(first,"first");
sk.get( e0,"e0");
sk.get(arc,"arc");
sk.get(factor,"factor");
MM_ERR(MMPR(dump()))

} // Init 
void set(const IdxTy _flags)
{
 flags= _flags;
// probably bad idea... 
planar_edges=false; // Bit(flags,0);
cull_overlaps= Bit(flags,1);
interpolate= Bit(flags,2);
add_inter_point=Bit(flags,3);
debug=Bit(flags,10);
max_dist=.06;
_maxfwd=10;
dt=100000;
arc=true;
factor=1;
first=0; // this just makes undercutting... 
 e0=5e-3; // baseline etch amount 
if (debug)
{
MM_ERR(MMPR4(__FUNCTION__,flags,planar_edges,cull_overlaps)<<MMPR(interpolate))
} // debug
} // set 
StrTy dump() const
{
Ss ss; 
ss<<MMPR(planar_edges);
ss<<MMPR(cull_overlaps);
ss<<MMPR(interpolate);
ss<<MMPR(add_inter_point);
ss<<MMPR(debug);
ss<<MMPR(max_dist);
ss<<MMPR(_maxfwd);
ss<<MMPR(dt);
ss<<MMPR(first);
ss<<MMPR( e0);
ss<<MMPR( arc);
ss<<MMPR( factor);
return ss.str();
}// dump
IdxTy flags; // =31; // _flags;
 bool planar_edges; // Bit(flags,0);
 bool cull_overlaps; // =Bit(flags,1);
 bool interpolate;// =Bit(flags,2);
 bool add_inter_point; // =Bit(flags,3);
 bool debug; // =Bit(flags,10);
 bool arc; // =Bit(flags,10);
 D max_dist; // =.06;
D factor;
int _maxfwd;
IdxTy first;
D e0; // =5e-3; // baseline etch amount 
int  dt;
}; // _EtchParam 
typedef _EtchParam Ep;
// TODO FIXME needs some isotropic stuff
// integrals for c and x appear to be simple really. 
class _EtchLocalRate
{

public:
typedef D Amt;
typedef std::vector<Amt> AmtVector;
const Amt & operator[](const IdxTy n) const { return m_v[n]; } 
Amt & operator[](const IdxTy n){  return m_v[n]; } 
void push_back(const Amt & v) { m_v.push_back(v); } 
IdxTy size() const { return m_v.size(); } 
void clear() { m_v.clear(); } 
IdxTy save(const StrTy & fn, const IdxTy flags)
{
std::ofstream os(fn);
return save(os,flags);
} // save 
IdxTy save(OsTy & os, const IdxTy flags)
{
const bool ff_format=Bit(flags,0);
const bool write_coords=!ff_format&&!Bit(flags,1);
const bool write_size=ff_format||Bit(flags,2);
const bool write_i=Bit(flags,3);
MM_ERR(MMPR3(write_coords,write_size,ff_format)<<MMPR(flags))
//IdxTy nprec_coord=12;
IdxTy nprec_v=12;

if (write_size) os<<m_v.size()<<CRLF;
// Ss ss; ss<<std::setprecision(m_nprec); ss<<x;
os<<std::setprecision(nprec_v);
MM_SZ_LOOP(i,m_v,sz)
{
if (write_i) os<<i<<" ";
os<<m_v[i];
os<<CRLF;
} // i 

return 0;
} // save 

AmtVector m_v;

}; // _EtchLocalRate


// a set of moulators or factors and container for Ep
class _EtchCurve {
typedef D V;
typedef std::vector<V> Rates;
typedef std::vector<Rates> Ratess;
public:
_EtchCurve() : m_ep(StrTy()),m_stagger(0){} // ,m_factor(1) {}
_EtchCurve(const StrTy & s) : m_ep(s),m_stagger(0) {} // ,m_factor(1) {}
const V & operator[](const IdxTy n) const { return m_v[n]; } 
const V & operator()(const IdxTy i,const IdxTy j) const { return m_vs[i][j]; } 
const IdxTy size() const { return m_v.size(); } 
_EtchCurve&  push_back(const V &  x ) {  m_v.push_back(x); return * this; } 
const Ep & etch_params() const { return m_ep; } 
const D & factor() const { return m_ep.factor; } 
IdxTy stagger() const { return m_stagger; }
void next() { if (m_v.size()) {  m_vs.push_back(m_v); m_v.clear(); }}
Rates m_v;
Ratess m_vs;
Ep m_ep;
IdxTy m_stagger;
//D m_factor;
}; // _EtchCurve

typedef std::vector<D> EtchVec;
// API

public:
typedef _Curve curve_type;
typedef _CurveCollection curves_type;
typedef typename curve_type::PointVec Pv;
typedef _EtchLocalRate local_etch_type;
typedef mjm_ff_band<Tr> surface_band_type;
typedef IdxTy ( * p_etch_func_type ) ( EtchVec & d, const EtchVec & s, const curve_type & curve,const IdxTy flags) ; 

typedef _EtchCurve etch_type;
mjm_etchfront() {Init(); }
mjm_etchfront(const StrTy & s, const IdxTy flags ) {Init(s,flags); }
~mjm_etchfront() {}
// input curve not const due to possible fix of normals 

template <class Tc, class Tf > 
IdxTy etch(Tc & cv, const Tf & factors,  curve_type & curve, const etch_type & ec, const IdxTy flags)
{ return EtchAPI(cv,factors,curve,ec,flags); }  

template <class Tc, class Tf > 
IdxTy etch_disjoint(Tc & cvs, const Tf & factors,  curves_type & curves, const etch_type & ec, const IdxTy flags)
{ return EtchAPIDisjoint(cvs,factors,curves,ec,0,flags); }  

// only one contiguous surce maybe closed 
IdxTy find_band(surface_band_type & band,curve_type & curve, const D & f1, const D & f2,  const etch_type & ec, const IdxTy flags)
{ return FindBand(band,curve,f1,f2,ec,flags); }  



IdxTy run(const StrTy & s, const IdxTy flags) { return  Run( s,  flags); } 
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
static bool Bit(const IdxTy f, const IdxTy b)  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);




IdxTy Run(const StrTy & s, const IdxTy flags)
{
Ep ep(s);
curve_type c;
{curve_type corig;
corig.make();
//const IdxTy addrc=
FixNormals(corig,corig,ep);
c=corig;
}
IdxTy n=-1000;
//IdxTy dt=1000000;
int cnt=0; 
for(IdxTy i=0; i<n; ++i)
{
Etch(c,cnt,ep);
//c.recenter(0,1-.1*(i%20));
c.recenter(0,0);
//PositionCurve(c,0);
SendCurve(c,0);
usleep(ep.dt);
++cnt;
} // i 
return 0;
} // Run
IdxTy PositionCurve(curve_type & c, const IdxTy flags)
{
c.recenter(0,0);
return 0;
} // Etch
// move the curve along the local normal netative
// ( etch is in negative normal direction.
// due to this, starting with a well formed curve,
// intersections can be detected. 
// the resulting curve may be disjoint leaving
// free blocs.  
IdxTy Etch(curve_type & c, const IdxTy cnt, const Ep & ep=Ep())
{
curve_type cnew;
const auto & pv=c.m_points;
const auto & nv=c.m_normals;
const IdxTy npts=pv.size();
if (npts==0)
{
MM_ERR(__FUNCTION__<< " no points to etch ")
return 0;
}

// move each point in the normal direction by an etch
// amount that depends on local curvature. 
// points can cross or diverge. When points cross, say in a hairpin,
// that creates disjoiint segments. As they diverge, adding
// point and getting the normals righ may be useful.
MM_ERR(MMPR2(cnt,npts))
const auto & rv=c.m_radii; // actually 1/r 
const auto & av=c.m_arc; // actually 1/r 
for(IdxTy i=0; i<npts; ++i)
{
const bool masked_region=(i<ep.first)||(i>(npts-ep.first));
 point_type    pnew = pv[i];
 point_type   nn = nv[i];
D elocal=ep.e0*(1-ep.e0*rv[i]); // rv is reciprocal roc 
// TODO not really phusical just testing. maybe theta better... 
// 1 is fully occluded, -1  fully exposed note discontinuity 
// 0 to 2pi...  
D elocala=ep.e0*(1-av[i]); // rv is reciprocal roc 
if (ep.arc) elocal=elocala;
if (elocal<0)
{
MM_ERR(" elocal negativce CLIPP "<<MMPR4(i,elocal,rv[i],ep.e0))
elocal=0;
}
if (false) MM_ERR(MMPR2(i,cnt)<<MMPR4(nn.x,nn.y,nn.z,elocal))
if (!masked_region) pnew-= nn*elocal;
cnew.m_points.push_back(pnew);
//cnew.m_points.push_back(pnew);
//points are diverging or convreing, need to update
// normal and radii detect crossovers 
// add points or separate pieces.  
} // i 


// update n and 1/R

auto & npv=cnew.m_points;
IdxTy nnpts=npv.size();
if (nnpts!=npts)
{

MM_ERR(__FUNCTION__<< " should be same size  "<<MMPR2(npts,nnpts))
}
if (nnpts<2)
{
MM_ERR(__FUNCTION__<< " not enough  new  points to fix "<<MMPR2(npts,nnpts))
auto & nnv=cnew.m_normals;
nnv=npv;
auto & nrv=cnew.m_radii; // actually 1/r 
nrv=std::vector<D>(nnpts);
c=cnew;
return 0;
}

// do this before culling atlhough maybe later better
if (ep.planar_edges)
{
npv[npts-2].y=npv[npts-1].y= npv[1].y=npv[0].y;
} // planar_edges


// hopefully more precise for later culling 
if (ep.interpolate)
{
Interpolate(cnew,ep);
} // interpolate 
// may need to do twice for some radii fixes 
//if (false)  
FixNormals(cnew,c,ep);
// this needs the normals and the radii possible... 
// with some schemes but not this one... 
if (ep.cull_overlaps)
{
//IdxTy rc= CullOverlaps(cnew,10,ep);
//IdxTy rc= 
CullOverlaps(cnew,ep);
// may need to update npts etc 
} // cull_overlaps
const IdxTy rc= FixNormals(cnew,c,ep);
if (rc) return rc;


c=cnew;

return 0;
} // Etch
// curve not const due to normals fix 
template <class Tc, class Tf > 
IdxTy EtchAPI(Tc & cv, const Tf & factors,  curve_type & curve, const etch_type & ec, const IdxTy flags)
//{ return EtchAPI(cv,factors,curve,ec,flags); }  
//IdxTy EtchAPI(curve_type & cnew, curve_type & curve, const etch_type & ec, const IdxTy flags)
{
IdxTy rc=0;
const bool warn_deposit=Bit(flags,0);
const bool gate_deposit=Bit(flags,1);
const Ep & ep = ec.etch_params();
const auto & pv=curve.m_points;
const auto & nv=curve.m_normals;
const IdxTy npts=pv.size();
if (npts==0)
{
MM_ERR(__FUNCTION__<< " no points to etch ")
return 0;
}
// not sure if needed 
//const IdxTy addrc=
FixNormals(curve,curve,ep);

// move each point in the normal direction by an etch
// amount that depends on local curvature. 
// points can cross or diverge. When points cross, say in a hairpin,
// that creates disjoiint segments. As they diverge, adding
// point and getting the normals righ may be useful.
//MM_ERR(MMPR2(cnt,npts))
const auto & rv=curve.m_radii; // actually 1/r 
//const auto & av=curve.m_arc; // actually 1/r 
MM_LOOP(ii,factors)
{
cv.push_back(curve_type());
curve_type&  cnew = cv.back();
const D fac=(*ii);
for(IdxTy i=0; i<npts; ++i)
{
//const bool masked_region=(i<ep.first)||(i>(npts-ep.first));
 point_type    pnew = pv[i];
 point_type   nn = nv[i];
//D elocal=ep.e0*(1-ep.e0*rv[i]); // rv is reciprocal roc 
// TODO not really phusical just testing. maybe theta better... 
// 1 is fully occluded, -1  fully exposed note discontinuity 
// 0 to 2pi...  
//D elocala=ep.e0*(1-av[i]); // rv is reciprocal roc 
//if (ep.arc) elocal=elocala;
D elocal =  ec[i]*ec.factor()*fac;
if (warn_deposit||gate_deposit) if (elocal<0)
{
// TODO deposition rquires different collision handling.. 
if (warn_deposit)
MM_ERR(" elocal negativce CLIPP ALLOWED  "<<MMPR4(i,elocal,rv[i],ep.e0))
if (gate_deposit) elocal=0;
}
//if (false) MM_ERR(MMPR2(i,cnt)<<MMPR4(nn.x,nn.y,nn.z,elocal))
//if (!masked_region) 
pnew-= nn*elocal;
cnew.m_points.push_back(pnew);
//cnew.m_points.push_back(pnew);
//points are diverging or convreing, need to update
// normal and radii detect crossovers 
// add points or separate pieces.  
} // i 


// update n and 1/R

auto & npv=cnew.m_points;
IdxTy nnpts=npv.size();
if (nnpts!=npts)
{

MM_ERR(__FUNCTION__<< " should be same size  "<<MMPR2(npts,nnpts))
}
if (nnpts<2)
{
MM_ERR(__FUNCTION__<< " not enough  new  points to fix "<<MMPR2(npts,nnpts))
auto & nnv=cnew.m_normals;
nnv=npv;
auto & nrv=cnew.m_radii; // actually 1/r 
nrv=std::vector<D>(nnpts);
//curve=cnew;
return 0;
}

// do this before culling atlhough maybe later better
if (ep.planar_edges)
{
npv[npts-2].y=npv[npts-1].y= npv[1].y=npv[0].y;
} // planar_edges


// hopefully more precise for later culling 
if (ep.interpolate)
{
Interpolate(cnew,ep);
} // interpolate 
// may need to do twice for some radii fixes 
//if (false)  
FixNormals(cnew,curve,ep);
// this needs the normals and the radii possible... 
// with some schemes but not this one... 
if (ep.cull_overlaps)
{
//IdxTy rc= CullOverlaps(cnew,10,ep);
rc= CullOverlaps(cnew,ep);
// may need to update npts etc 
} // cull_overlaps
 rc+= FixNormals(cnew,curve,ep);
if (rc) return rc;
//curve=cnew;
// maybe just do onstack.. 
//cv.push_back(cnew);
} // factors

return rc; 
} // EtchAPI
IdxTy FindBand(surface_band_type & band,curve_type & curve, const D & f1, const D & f2,  const etch_type & ec, const IdxTy flags)
{
IdxTy rc=0;
const Ep & ep = ec.etch_params();
// TODO do this just once and pass const curve
FixNormals(curve,curve,ep);
const auto & pv=curve.m_points;
const auto & nv=curve.m_normals;
IdxTy npts=pv.size();
if (npts==0)
{
//MM_ERR(" no points drop cuve "<<MMPR2(icurves,ifac))
return 1;  //continue; 
}
// want to handle zed length case... 
//--npts;
const IdxTy npts2=npts-1;
for(IdxTy i=0; i<npts; ++i)
{
const IdxTy i2=(i<npts2)?(i+1):i;
 point_type    pnew = pv[i];
 point_type    pnew2 = pv[i2];
// originally this was going to derive an etch direction perp
// to the two points but I guess it really needs to use these.
 point_type   nn = nv[i];
 point_type   nn2 = nv[i2];
// wtf? 
D elocal =  ec(0,i)*f1; // ec.factor()*fac;
D elocal2 =  ec(0,i2)*f2; // ec.factor()*fac;
point_type p11=pnew-nn*elocal;
point_type p12=pnew-nn*elocal2;
point_type p21=pnew2-nn2*elocal;
point_type p22=pnew2-nn2*elocal2;
// reorder depending on elocal signs. This need not be a 
// trapezoid or even convex. Original ideas was 2 sides
// perpendicular to segment between them aka a rapezoid
// but that fails to get the etch and even worse with
// isotropic etch. 
band.add_element(p11,p12,p21,p22,elocal,elocal2,0);

//pnew-= nn*elocal;
//if (((i+1)<npts)) ; // &&(ec.stagger()&ifac))
//pnew+=(p2-pv[i])*.5;

} // i 

return rc;
} // FindBand

//typedef IdxTy ( * p_etch_func_type ) ( EtchVec & d, const EtchVec & s, const curve_type & curve) ; 
IdxTy IsotropicPEF( EtchVec & d, const EtchVec & s, const curve_type & curve, const IdxTy flags)  
{

return 0; 
} // IsotropicPEF

// curve not const due to normals fix 
// curves_type is a vector of contiguous curves
// cvs is a vector of curves_type one entry per factor entry... 
// TODO add isotropic and better interpolation 
template <class Tc, class Tf > 
IdxTy EtchAPIDisjoint(Tc & cvs, const Tf & _factors,  curves_type & curves, const etch_type & ec, p_etch_func_type * pef=0, const IdxTy flags=0)
//{ return EtchAPI(cv,factors,curve,ec,flags); }  
//IdxTy EtchAPI(curve_type & cnew, curve_type & curve, const etch_type & ec, const IdxTy flags)
{
IdxTy rc=0;
const bool note_stagger=false;
const bool warn_deposit=Bit(flags,0);
const bool gate_deposit=Bit(flags,1);
const bool post_stagger=true;
const Ep & ep = ec.etch_params();
MM_ERR(MMPR(ec.stagger())) 
const IdxTy _nfactors=_factors.size();
Tf altfactors; 
if (_nfactors==0)
{
MM_ERR(" no etchf factors provided using one ")
 altfactors.push_back(1);
}
const Tf & factors=(altfactors.size())?altfactors:_factors;
const IdxTy nfactors=factors.size(); // ?factors.size();
cvs.resize(nfactors); 
MM_LOOP(ii,curves)
{
curve_type & curve=(*ii);
MM_ERR(" curve pieces "<<MMPR((*ii).size()))
FixNormals(curve,curve,ep);
} // ii 
// move each point in the normal direction by an etch
// amount that depends on local curvature. 
// points can cross or diverge. When points cross, say in a hairpin,
// that creates disjoiint segments. As they diverge, adding
// point and getting the normals righ may be useful.
//MM_ERR(MMPR2(cnt,npts))
//const auto & rv=curve.m_radii; // actually 1/r 
//const auto & av=curve.m_arc; // actually 1/r 
MM_SZ_LOOP(ifac,factors,factorssz)
{
const D fac=factors[ifac];;
curves_type & cv=cvs[ifac];
// can not push until we know if any remain 
//cv.push_back(curves_type());
// a single source of curves_type type contains 1 or more 
// disjoint possible closed interfaces. 
MM_SZ_LOOP(icurves,curves,curvressz)
{ 
//  curves is a set of disjoint curves presumably of same attribute
curve_type&   curve=curves[icurves] ; // = cv.back();
const auto & pv=curve.m_points;
const auto & nv=curve.m_normals;
const IdxTy npts=pv.size();
if (npts==0)
{
MM_ERR(" no points drop cuve "<<MMPR2(icurves,ifac))
continue; 
}
curve_type  cnew ; // = cv.back();
EtchVec  eff(npts),_eff(npts);
const D efc=ec.factor()*fac;
for(IdxTy i=0; i<npts; ++i) { _eff[i]=ec(icurves,i)*efc; } 
// TODO introduce various etchants here, notably
// isotropic smoothing of spherical etch pits. 
if (pef) (*pef)(eff,_eff,curve,0); 
else eff=_eff;

for(IdxTy i=0; i<npts; ++i)
{
const bool masked_region=(i<ep.first)||(i>(npts-ep.first));
 point_type    pnew = pv[i];
 point_type   nn = nv[i];
//D elocal=ep.e0*(1-ep.e0*rv[i]); // rv is reciprocal roc 
// TODO not really phusical just testing. maybe theta better... 
// 1 is fully occluded, -1  fully exposed note discontinuity 
// 0 to 2pi...  
//D elocala=ep.e0*(1-av[i]); // rv is reciprocal roc 
//if (ep.arc) elocal=elocala;
//D elocal =  ec[i]*ec.factor()*fac;
// TODO extra multiplies doh 
D elocal = eff[i]; //  ec(icurves,i)*ec.factor()*fac;


if (warn_deposit||gate_deposit) if (elocal<0)
{
// TODO deposition rquires different collision handling.. 
if (warn_deposit)
MM_ERR(" elocal negativce CLIPP ALLOWED  "<<MMPR4(i,elocal,pv[i].dump(),ep.e0))
if (gate_deposit) elocal=0;
}
if (masked_region) elocal=0;
// moved stagger to post_stagger}
//if (false) MM_ERR(MMPR2(i,cnt)<<MMPR4(nn.x,nn.y,nn.z,elocal))
//if (!masked_region) 
pnew-= nn*elocal;
cnew.m_points.push_back(pnew);
//cnew.m_points.push_back(pnew);
//points are diverging or convreing, need to update
// normal and radii detect crossovers 
// add points or separate pieces.  
} // i 
// update n and 1/R
auto & npv=cnew.m_points;
IdxTy nnpts=npv.size();
if (nnpts!=npts)
{
MM_ERR(__FUNCTION__<< " should be same size  "<<MMPR2(npts,nnpts))
}
if (nnpts<2)
{
MM_ERR(__FUNCTION__<< " curve etched away  "<<MMPR4(icurves,ifac,npts,nnpts))
continue; // next curve
}
// do this before culling atlhough maybe later better
if (ep.planar_edges)
{ npv[npts-2].y=npv[npts-1].y= npv[1].y=npv[0].y; } // planar_edges
// hopefully more precise for later culling 
if (ep.interpolate) { Interpolate(cnew,ep); } // interpolate 
// may need to do twice for some radii fixes 
//if (false)  
// TODO this needs to be only done when needed or
// do something sane here.. 
MM_ERR(" fixing norms "<<MMPR2(cnew.size(),curve.size()))
FixNormals(cnew,curve,ep);


if ((post_stagger) &&(ec.stagger()&ifac))
{
 auto & pv=cnew.m_points;
//const auto & nv=cnew.m_normals;
if (note_stagger){ MM_ERR(" staggering "<<MMPR2(ec.stagger(),ifac)) }
// TODO not sure this really belongs here as its not physical
const IdxTy npts=pv.size();
for(IdxTy i=0; i<(npts-1); ++i)
{
//const bool masked_region=(i<ep.first)||(i>(npts-ep.first));
 point_type&    pnew = pv[i];
 //const point_type&   nn = nv[i];
 const point_type    p2 = pv[i+1];
point_type pnewd=(p2-pv[i]) *0.5;
//MM_ERR("post stagger"<<MMPR4(ifac,ec.stagger(),pnewd.dump(),pnew.dump()))
pnew+=pnewd; // (p2-pv[i])*.5;
} // i 
FixNormals(cnew,curve,ep);
} // post_stagger

// this needs the normals and the radii possible... 
// with some schemes but not this one... 
if (ep.cull_overlaps)
{
//IdxTy rc= CullOverlaps(cnew,10,ep);
rc= CullOverlaps(cnew,ep);
//IdxTy SplitOverlaps(curves_type & curves, const   curve_type & cnew, const Ep & ep ) const
SplitOverlaps(cv,  cnew, ep ); //  const
// may need to update npts etc 
} // cull_overlaps
else cv.push_back(cnew);
curve_type xxxc;
MM_LOOP(ii,cv) { 
MM_ERR(" making curves "<<MMPR((*ii).size()))
rc+= FixNormals(*ii,xxxc,ep); } 
} // icurves curve(s) 
} // ifac

return rc; 
} // EtchAPIDisjoint




IdxTy Interpolate( curve_type & cnew, const Ep & ep ) const
{
auto & npv=cnew.m_points;
IdxTy nnpts=npv.size();
Pv np;
IdxTy added=0;
if (nnpts) np.push_back(npv[0]);
// the ribbon expands as the end point etch and erode
// but it looked like adding points at the tails.. 
//if (nnpts) { MM_ERR(" first "<<MMPR(np.back().dump())) }
for(IdxTy i=1; i<nnpts; ++i)
{
const point_type & p =npv[i];
const D d = p.r(npv[i-1]);
// insert at most 1
if (d>ep.max_dist)
{
// TODO better schemes with all the info 
const D ppx=.5*(p.x+npv[i-1].x);
const D ppy= .5*(p.y+npv[i-1].y);
if (false) { MM_ERR(" adding point "<<MMPR4(i,d,ppx,ppy)) } 
//np.push_back(point_type(.5*(p.x+npv[i-1].x), .5*(p.y+npv[i-1].y)));
np.push_back(point_type(ppx,ppy));
++added;
}
np.push_back(p);
} // i
if ((npv.size()+added)!=np.size())
{
MM_ERR(" point sizes wrong "<<MMPR3(added,npv.size(),np.size()))
}
npv=np;
//nnpts=npv.size();
// these need to be recompuited and genereae obvious errors if not 
auto & nrv=cnew.m_radii; // actually 1/r 
auto & nnv=cnew.m_normals;
auto & nav=cnew.m_arc;
nnv.clear();
nrv.clear();
nav.clear();
//if (np.size()) { MM_ERR(" last  "<<MMPR(np.back().dump())) }

return 0;
} // Interpolate

IdxTy CheckOverlap(int  & dropped, Pv & ok, const Pv & p,  IdxTy& i, IdxTy& j, const Ep & ep  ) const 
{
IdxTy rc=0;
const bool print_del=false;  
point_type ij=point_type::cross(p[i],p[i+1],p[j],p[j+1]);
const bool pts_cross= point_type::do_cross(ij);
if (pts_cross)
{ // TODO need to find disjoint detaching blobs
if ( print_del) { MM_ERR("deleting"<<MMPR4(ij.x,ij.y,i,j)) } 
ok.push_back(p[i]);
if (ep.add_inter_point)
{
// ij are the fractions between the first and second set
// so ij.x is right here
const D xnew=p[i].x+(p[i+1].x-p[i].x)*(ij.x);
const D ynew=p[i].y+(p[i+1].y-p[i].y)*(ij.x);
const D xnew2=p[j].x+(p[j+1].x-p[j].x)*(ij.y);
const D ynew2=p[j].y+(p[j+1].y-p[j].y)*(ij.y);
const bool xok=(((xnew-p[i].x)*(xnew-p[i+1].x))<=0);
const bool yok=(((ynew-p[i].y)*(ynew-p[i+1].y))<=0);
const bool xok2=(((xnew2-p[i].x)*(xnew2-p[i+1].x))<=0);
const bool yok2=(((ynew2-p[i].y)*(ynew2-p[i+1].y))<=0);
if(xok&&yok&&xok2&&yok2)
{
//if (print_del) MM_ERR(" intersetion add "<<MMPR4(i,j,xnew,ynew))
}
else
{
MM_ERR(" bad inter polate "<<MMPR2(ij.x,ij.y))
MM_ERR(MMPR4(xok,yok,xok2,yok2))
MM_ERR(MMPR4(xnew,ynew,xnew2,ynew2))
MM_ERR(MMPR4(p[i].x,p[i].y,p[i+1].x,p[i+1].y))
MM_ERR(MMPR4(p[j].x,p[j].y,p[j+1].x,p[j+1].y))
MM_WAIT
}
point_type inter(xnew,ynew);
 ok.push_back(inter);
--dropped;
} // add_inter_point
// TODO FIXME some assymetry noted may be a bug here 
dropped+=j-i; //already pushed i above.. 
i=j+1; // this eliminates all points between the two segment
rc=1; //    break; // advance past this. 
// ok.push_back(p[i]);
} // pts_Cross 
return rc;
} // CheckOverlap

IdxTy SplitOverlaps(curves_type & curves, const   curve_type & cnew, const Ep & ep ) const
{
IdxTy rc=0;
IdxTy deleted=0;
const bool warn_snipped=false;;
const Pv & npv=cnew.m_points;
IdxTy nnpts=npv.size();
std::vector<Pv> okv;
Pv ok;
const IdxTy maxfwd=ep._maxfwd; // 10;
IdxTy lim=nnpts-3;
if (nnpts<4) lim=0;
const auto & p =npv;
IdxTy i=0;
int  dropped=0;
//for(IdxTy i=0; i<lim; ++i)
for(; i<lim; ++i)
{
IdxTy itop=i+maxfwd;
if (itop>=nnpts) itop=nnpts-1;
// TODO FIXME need to check whole surface but
// only test those that may overlap such as
// normals pointing towards each other or maybe R etc
// this will require that n and R have been updated.. 
const IdxTy i0=i;
for(IdxTy j=i+2; j<(itop-1); ++j)
{
const IdxTy j0=j;
IdxTy rcco= CheckOverlap(dropped, ok, npv, i, j,ep );
if (rcco==1)
{ // i and j have been advanced, need to save the snipped sequence
// if it has positive area. 
++deleted;
if (warn_snipped)
{MM_ERR(" deleted sequence may gae positive area "<<MMPR4(i,j,i0,j0)) }
 break; // points were deleted 
}//rcco==1 or points intersected 
} // j 
ok.push_back(p[i]);
} // i 
// don't check just keep. lthough these could have
// overlapped TODO FIXME resulintg in incoinsistent output
//for(IdxTy i=lim; i<nnpts; ++i) ok.push_back(p[i]);
for(; i<nnpts; ++i) ok.push_back(p[i]);
if (ok.size()+dropped!=npv.size())
{
MM_ERR("sized no add up "<<MMPR3(ok.size(),dropped,npv.size()))
}
okv.push_back(ok);
//npv=ok;
MM_LOOP(ii,okv)
{
curve_type curve;
curve.m_points=(*ii);
curves.push_back(curve);
} // ii 
if (deleted)
{ MM_ERR(" dropped points may be new blobs "<<MMPR(deleted)) } 
return rc;
} // SplitOverlaps

//IdxTy CullOverlaps( curve_type & cnew, const IdxTy _maxfwd, const bool  add_inter_point) const
IdxTy CullOverlaps( curve_type & cnew, const Ep & ep ) const
{
const bool warn_overlaps=false;
IdxTy noverlaps=0;
auto & npv=cnew.m_points;
//auto & nnv=cnew.m_normals;
//auto & nrv=cnew.m_radii; // actually 1/r 
IdxTy nnpts=npv.size();
int  dropped=0;
// there is probably a way using s, dr, and n dot products
// but I can't find a robust way. The intersection approach
// is much more tedious but may be more useful if intersections
// are only nearby. 
//static P cross(const P & p0, const P & p1, const P & p2, const P & p3) //const
Pv ok;
const IdxTy maxfwd=ep._maxfwd; // 10;
IdxTy lim=nnpts-3;
if (nnpts<4) lim=0;
const auto & p =npv;
IdxTy i=0;
//for(IdxTy i=0; i<lim; ++i)
for(; i<lim; ++i)
{
IdxTy itop=i+maxfwd;
if (itop>=nnpts) itop=nnpts-1;
// TODO FIXME need to check whole surface but
// only test those that may overlap such as
// normals pointing towards each other or maybe R etc
// this will require that n and R have been updated.. 
for(IdxTy j=i+2; j<(itop-1); ++j)
{
point_type ij=point_type::cross(p[i],p[i+1],p[j],p[j+1]);
// move to a method to pick up nan etc. 
const bool pts_cross= point_type::do_cross(ij);
//(ij.x>=0) &&(ij.x<=1) &&(ij.y>=0)&& (ij.x<=1);
if (pts_cross)
{ // TODO need to find disjoint detaching blobs
if (warn_overlaps) { MM_ERR("deleting"<<MMPR4(ij.x,ij.y,i,j)) } 
++noverlaps;
// this is ok but the other ends is out.
ok.push_back(p[i]);
// add a new point at thie intersection. 
if (ep.add_inter_point)
{
// ij are the fractions between the first and second set
// so ij.x is right here
//const D xnew=p[i].x+(p[i+1].x-p[i].x)*(1.0-ij.x);
//const D ynew=p[i].y+(p[i+1].y-p[i].y)*(1.0-ij.x);
//const D xnew2=p[j].x+(p[j+1].x-p[j].x)*(1.0-ij.y);
//const D ynew2=p[j].y+(p[j+1].y-p[j].y)*(1.0-ij.y);
const D xnew=p[i].x+(p[i+1].x-p[i].x)*(ij.x);
const D ynew=p[i].y+(p[i+1].y-p[i].y)*(ij.x);
const D xnew2=p[j].x+(p[j+1].x-p[j].x)*(ij.y);
const D ynew2=p[j].y+(p[j+1].y-p[j].y)*(ij.y);

const bool xok=(((xnew-p[i].x)*(xnew-p[i+1].x))<=0);
const bool yok=(((ynew-p[i].y)*(ynew-p[i+1].y))<=0);
const bool xok2=(((xnew2-p[i].x)*(xnew2-p[i+1].x))<=0);
const bool yok2=(((ynew2-p[i].y)*(ynew2-p[i+1].y))<=0);

if(xok&&yok&&xok2&&yok2)
{
if (warn_overlaps) MM_ERR(" intersetion add "<<MMPR4(i,j,xnew,ynew))
}
else
{
MM_ERR(" bad inter polate "<<MMPR2(ij.x,ij.y))
MM_ERR(MMPR4(xok,yok,xok2,yok2))
MM_ERR(MMPR4(xnew,ynew,xnew2,ynew2))
MM_ERR(MMPR4(p[i].x,p[i].y,p[i+1].x,p[i+1].y))
MM_ERR(MMPR4(p[j].x,p[j].y,p[j+1].x,p[j+1].y))
MM_WAIT
//StrTy x; std::cin >> x;
}
//point_type inter(p[i].x+(p[i+1].x-p[i].x)*ij.x,p[i].y+(p[i+1].y-p[i].y)*ij.x);
point_type inter(xnew,ynew);
 ok.push_back(inter);
--dropped;
} // add_inter_point
// TODO FIXME some assymetry noted may be a bug here 
dropped+=j-i; //already pushed i above.. 
i=j+1; // this eliminates all points between the two segment
break; // advance past this. 
// ok.push_back(p[i]);
} // if 
} // j  

ok.push_back(p[i]);
} // i 
// don't check just keep. lthough these could have
// overlapped TODO FIXME resulintg in incoinsistent output
//for(IdxTy i=lim; i<nnpts; ++i) ok.push_back(p[i]);
for(; i<nnpts; ++i) ok.push_back(p[i]);
if (ok.size()+dropped!=npv.size())
{
MM_ERR("sized no add up "<<MMPR3(ok.size(),dropped,npv.size()))
}

if (nnpts>=4) npv=ok;

// this should not be needed but wth
//const IdxTy rc= FixNormals(cnew,c,flags);
//if (rc) return rc;
//nnpts=npv.size();
if (noverlaps) MM_ERR(MMPR2(noverlaps, warn_overlaps))
return 0; 
} // CullOverlaps



// calculate the normals and raqdii from the points
// TODO make a member of _Curve
// "c" is not const as it is assigned to cnew? 
IdxTy FixNormals(curve_type & cnew, curve_type & xxxc,  const Ep  & ep )
{
auto & npv=cnew.m_points;
auto & nnv=cnew.m_normals;
auto & nrv=cnew.m_radii; // actually 1/r 
auto & nav=cnew.m_arc; // actually 1/r 
nnv.clear();
nrv.clear();
nav.clear();
IdxTy nnpts=npv.size();
// TODO eliminate "C" from sig and move the error code out. 
if (nnpts<2)
{
MM_ERR(__FUNCTION__<< " not enough  new  points after proc  "<<MMPR2(xxxc.m_points.size(),nnpts))
MM_FAULT
nnv=npv;
nrv=std::vector<D>(nnpts);
//c=cnew;
return 1;
}
// havce at least 2 points... 
// get te first point... 
//point_type nn=nv[0]; // take the old one.. 
//const D s  = (npv[0]-npv[1]).r();
nnv.push_back(npv[0].n(npv[1]));
const IdxTy nnptso=nnpts-1;
for(IdxTy i=1; i<nnptso; ++i)
{
//point_type nn=nv[i]; // take the old one.. 
// the normal n = z* ds  
nnv.push_back(npv[i-1].n(npv[i+1]));
} // ii 
nnv.push_back(npv[nnptso-1].n(npv[nnptso]));

D rinv=cnew.invrad(0,1); // rv[0];
//cnew.m_radii.push_back(rv[0]);
nrv.push_back(rinv);
for(IdxTy i=1; i<nnptso; ++i)
{
D rinvf=cnew.invrad(i,i+1); // rv[i];
D rinvb=cnew.invrad(i-1,i); // rv[i];
nrv.push_back(.5*(rinvf+rinvb));
}

rinv=cnew.invrad(nnptso-1,nnptso); // rv[0];
nrv.push_back(rinv);
// do arcs, may not need radii
nav.push_back(0);
for(IdxTy i=1; i<nnptso; ++i)
{
point_type pprior=npv[i-1]-npv[i]; // from same origin, p[i]
point_type pnext=npv[i+1]-npv[i];
D arc=pprior.arc(pnext,nnv[i]);
nav.push_back(arc);
} // i arc loop 

nav.push_back(0);

return 0; 
} // FixNormals 

 
// TODO FIXME this has a 64k char limit so even 1k points
// may be close... 
IdxTy SendCurve(const curve_type & c, const IdxTy flags  )
{
Ragged r;
{ Line l; l.push_back("#"); l.push_back("id"); l.push_back("test pattern chunks "); l.push_back(m_idn);  r.add(l); }
{ Line l; l.push_back("#"); l.push_back("oscilloscope"); l.push_back("chunks"); r.add(l); }

{ Line l; l.push_back("#"); l.push_back("trace"); Ss ss; ss<<m_line;  l.push_back(ss.str()); r.add(l); }
const auto & points= c.m_points;
const IdxTy sz=points.size();
for(IdxTy i=0; i<sz; ++i)
{
Line l;
D x=points[i].x;
D y=points[i].y;
{ Ss ss; ss<<x; l.push_back(ss.str()); }
{ Ss ss; ss<<y; l.push_back(ss.str()); }
r.add(l);
//++m_line;
} // i 
m_dgrams.send(r);
return 0; 
} // SendCurve;

void Init(const StrTy & s, const IdxTy flags ) 
{
m_dgrams_str=s;
m_idn="curves";
m_line=0;

}
void Init()
{
// launch clinet 
//m_dgrams_str="ipv4s=192.168.4.1";
m_dgrams_str="ipv4s=127.0.0.1";
m_dgrams.launch(m_dgrams_str,2);
m_idn="curves";
m_line=0;
} // Init 

// MEMBERS
StrTy m_dgrams_str;
StrTy m_idn;
IdxTy m_line;
DgramID m_dgrams;


}; // mjm_etchfront

//////////////////////////////////////////////

template <class Tr>
class mjm_etchfront_map : public std::map<typename Tr::StrTy, mjm_etchfront< Tr > >  
{
 typedef mjm_etchfront_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_etchfront< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_etchfront_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_etchfront_map




////////////////////////////////////////////
#ifdef  TEST_MJM_ETCHFRONT
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_etchfront <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_ETCHFRONT "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_etchfront<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="run") { MM_ERR(x.run(cip.p1,atoi(cip.p2.c_str()))) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_ETCHFRONT_H__ 
