#ifndef MJM_FF_PHASE_BOUND_H__
#define MJM_FF_PHASE_BOUND_H__

#include "mjm_globals.h"
#include "mjm_etch_info.h"
#include "mjm_thread_util.h"
#include "mjm_string_kvp.h"
#include "mjm_dscope_rawfifo.h"
#include "mjm_ff_mesh_adapt.h"
#include "mjm_etchfront.h"
#include "mjm_pawnoff.h"
#include "mjm_blob.h"
#include "mjm_affine_mesh_hood.h"
#include "mjm_collections.h"
#include "mjm_mesh_tape.h"
#include "mjm_ff_band.h"
#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>

/*
@software{,
  author = {Michael J Marchywka},
  title = {},
abstract=(),
institution={},
license={Knowledge sir should be free to all },
publisher={Mike Marchywka},
email={marchywka@hotmail.com},
authorid={orcid.org/0000-0001-9237-455X},
  filename = {},
  url = {},
  version = {0.0.0},
  date-started = {}
}
*/
/*

2023-07-12 stagginer complicated by filling etc, this works, 
./mjm_ff_phase_bound.out "runalt fifo_name=/tmp/dsfifo;base=crap;mesh_fn=crap.msh;space=.001;gspace=.001;max_dist=1000;stagger=1;tapefn=tapefile.txt;test_calculate=1;min_dist=1"  quit 2>&1  | grep pn


2023-07-06 updated mesa drivers to get medit to work better
and now making backup copy of this and take out junk code
to test the dof modifications. 
2023-06-26 Fixed IsIn to get stragglers and just reversed
fnew or fni with fwd flag depending on gradient although 
hard coded reversed for now. 
Now need to get boundary numbers for triangulated mesh.

2023-06-26 missing some triangles, etch curves not orented
so etching could be in wrong dir. Want to start with gradient 
to the right ( liquid to the left ). 

*/
// Sun 11 Jun 2023 08:52:22 AM EDT
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_ff_phase_bound   
//  ./mjm_ff_phase_bound.out "run fifo_name=/tmp/dsfifo;base=crap;mesh_fn=crap.msh" 2>&1 | more

// QUICKCOMPILE  g++  -Wall -std=gnu++11 -DTEST_MJM_FF_PHASE_BOUND -I. -I../datascope  -I../../mjm/hlib -I../../mjm/num -Wno-misleading-indentation  -gdwarf-3 -O0  -x c++ mjm_ff_phase_bound.h  -o mjm_ff_phase_bound.out -lpthread -lreadline


// g++  -Wall -std=gnu++11 -DTEST_MJM_FF_PHASE_BOUND -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_ff_phase_bound.h  -o mjm_ff_phase_bound.out -lpthread -lreadline

// testing , need to run 2 procs to test, 

//ff-mpirun -np 1 extmesh.edp -itermax 200 -dt 2e-11 -nx 50 -ny 50 -wg -load crap -vzed .2

// ./mjm_ff_phase_bound.out "run fifo_name=/tmp/dsfifo;base=crap;mesh_fn=crap.msh" 2>&1  

/*
one_and_done avoids running the electrop script.

 2502  ./mjm_ff_phase_bound.out "run fifo_name=/tmp/dsfifo;base=crap;mesh_fn=crap.msh"  quit 2>&1 
 2512  FreeFem++ ./play/maketrimesh.edp  -dof ./play/newmeshCl.txt -load ./play/xxx.msh

*/




mjm_global_credits::credit __credit__mjm_ff_phase_bound("mjm_ff_phase_bound" , "  ");

template <class Tr>
class mjm_ff_phase_bound 
{
 typedef mjm_ff_phase_bound Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
// pass control info to ff
// TYPEDEF 
typedef mjm_string_base_params<Tr> BaseParams;
typedef mjm_dscope_rawfifo<Tr> Fifo;
typedef mjm_ff_mesh_adapt<Tr> Meshes;
typedef mjm_etchfront<Tr> EtchFront;
typedef mjm_ragged_table Ragged;
typedef typename Ragged::Line Line ;

typedef typename Meshes::trail_type trail_type;
typedef typename Meshes::mesh_type mesh_type;
typedef typename trail_type::value_type seg_type;
typedef typename Meshes::dof_type dof_type;
typedef typename dof_type::value_type dof_value_type;
typedef typename mesh_type::adopt_matrix_type Aam;

typedef typename EtchFront::curve_type curve_type;
typedef typename EtchFront::curves_type curves_type;
typedef typename EtchFront::etch_type etch_type;
typedef typename EtchFront::local_etch_type local_etch_type;

typedef mjm_pawnoff<Tr>  Hand;
typedef mjm_blob<Tr>  Blob;

typedef mjm_affine_mesh_hood<Tr> MeshHood;
typedef typename MeshHood::delete_que_type Dq;
typedef mjm_tape_set<Tr> TapeSet;
typedef mjm_tape_vector<Tr> TapeVector;
typedef mjm_etch_info<Tr,Myt> EtchInfo;
typedef mjm_ff_band<Tr> SurfaceBand;
typedef typename SurfaceBand::tri_type SbTri;
friend EtchInfo;
// API

public:
typedef SurfaceBand surface_band_type;
mjm_ff_phase_bound() {}
~mjm_ff_phase_bound() {}
// This doesn't work well beyond the fixed .1 etch condition
// and the varying etch rate code is not right 
IdxTy run(const StrTy & sin, const IdxTy flags) {
MM_DIE(" use runalt unless this is intended rec omplie ")
 return  RunDisjoint(sin, flags) ;

} 
// this one is closer to working should rename as "run"
// in next garbage removal 
IdxTy runalt(const StrTy & sin, const IdxTy flags) { return  RunDisjointAlt(sin, flags) ;} 
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
static bool Bit(const IdxTy f, const IdxTy b)  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;
enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);

StrTy WaitForFreeFEM()
{
MM_ERR(" wiating for ff ")
// TODO locking etc still a hzard but just used for statue line etc. 
m_running=true;
// wait for message from  freefem
StrTy * sp=m_fifo.next();
if (sp==0)
{
MM_ERR(" queue returns null ")
return StrTy(); // break;
}
const StrTy msg=*sp;
MM_ERR(" have msg "<<MMPR(msg))
if (msg=="")
{
MM_ERR(" blank message from ff so stop ")
} 
delete sp;
return msg;
} // WaitForFreeFEM

// description of "point tape" or line of points conformal
// to surface or anticipated surface 

class _run_variables
{
public:
_run_variables(const StrTy & sin, const IdxTy flags)
{
Init();
BaseParams sk(sin);
sk.get(tapefn,"tapefn");
sk.get(ptsfil,"ptffile");
sk.get(space,"space");
D gspace=.1*space;
sk.get(gspace,"gspace");
sk.get(one_and_done,"one_and_done");
sk.get(test_calculate,"test_calculate");
sk.get(min_dist,"min_dist");
MM_ERR(dump())
} // ctor
void Init()
{
test_calculate=false;
//const StrTy newmesh="newmeshfil.msh";
write_back_out=false;
space=3;
gspace=.1*space;
one_and_done=true;
new_mesh_name="newmesh";
etched_mesh_name="etchedmesh";
ptsfil="xxx_ptsfil.txt";
tapefn="";
min_dist=0;

} // Init;
StrTy dump()  const
{
Ss ss;
ss<<MMPR4(space,gspace,one_and_done,test_calculate)<<MMPR3(min_dist,ptsfil,tapefn);
return ss.str();
}

bool test_calculate; // =false;
bool write_back_out; // =false;
D space; // =3;
bool one_and_done; // =true;
StrTy new_mesh_name; // ="newmesh";
StrTy etched_mesh_name; // ="etchedmesh";
StrTy ptsfil; // ="xxx_ptsfil.txt";
StrTy tapefn; // ="";
D gspace; // =.1*space;
D min_dist;

}; // _run_variables
typedef _run_variables RunVariables;

IdxTy RunDisjointAlt(const StrTy & sin, const IdxTy flags) 
{
IdxTy rc=0;
RunVariables rv(sin,0);
EtchFront ef(sin,0);
TapeVector tv(rv.space,rv.gspace); 
if (rv.tapefn!="")
{
tv.clear();
Ragged r;
r.load(rv.tapefn);
tv.load(r);
}
// "sin" is the etchfront initi string with things like max_dist
EtchInfo ei(this,sin);

rc=RunDisjoint(sin,rv,ef,tv,ei,flags);

return rc;
} // RunDisjointAlt
// on each iteration, load mesh and dofs for mesh_name
// find the etch surface and etch rates
// retape the areas possibly to be etched
// create a new mesh
// update dofs 
IdxTy RunDisjoint(const StrTy & sin, const RunVariables & rv,  EtchFront & ef, TapeVector & tv, EtchInfo & ei, const IdxTy flags) 
{
IdxTy rc=0;
m_fifo.launch(sin,2);
usleep(100000); // avoid overlapping mesages 
m_fifo.launch(sin,3);
while (true)
{
m_running=!false;
if (!rv.one_and_done)
{
StrTy msg=WaitForFreeFEM();
if (msg=="") break;
} // one_and_done
// TODO needs to be cleared on each iter 
ei.read(0);
MM_ERR(" read etch in  ")
//m_meshes.isotrail(ei.mesh_name,StrTy("surf"), StrTy("c"),.99,0);
local_etch_type let;
//CalculateActualEtch2(let,ei.mesh_name,rv.new_mesh_name,"c",.99,0);
// TODO needed to index mesh for lookup, could be member of mesh 
MeshHood mh;
mesh_type & m=m_meshes[ei.mesh_name];
//const auto & pts=m_meshes.get_mesh(ei.mesh_name).get_verticies(); 
const auto & pts=m.get_verticies(); 
mh.infer(pts, 0); 
mh.add(pts,0,0); // src and flags 

CalculateActualEtch2(let,m,mh,"c",1.0-.99,rv.min_dist,0);
// so now let is setup we can paint the tape 
// and make new mesh 
//MM_SZ_LOOP(i,tr,trsz) { let.push_back(.1); } 
MM_ERR(" made .99 trail  ")

// now add to existing mesh index 
//IdxTy base_src=tv.srcmin(); // 4+1; // ff uses thse for boundary on verticies? 
//const trail_type &  tr= m_meshes.get_trail(ei.mesh_name,"surf");
// non-const for contraint
const trail_type &  tr= m.get_trail("surf");

//EtchOrGrowDisjoint(cvs,ts.efactors(),curves,ef,ei,tr,let,0);
// this is merely class conversion. curves reflect the disjoint
// trail components put into a different form. They should not
// split or join etc. 
etch_type ec(ei.eps());
curves_type curves;
EcFromLet( ec, curves, tr, let, flags);

// first check the bands since we now have the curves
// in the right format 
const bool skip_bands=!true;
if (!skip_bands) {
for(IdxTy  i=0; i<tv.bands(); ++i)
{
// TODO resolve descriptor and actual thing names
// for surface band... doh 
const typename TapeVector::surface_band_type & sbd=tv.band(i);
MM_SZ_LOOP(j,curves, szc)
{
// TODO non-const due to maybe fix normals wtf 
auto & curve=curves[j];
surface_band_type sb;
ef.find_band(sb,curve,sbd.m_f1,sbd.m_f2,ec,0);
//mh.delete_band(sb);
// sb now should contain a list of triangles to delete
Dq dq;
MM_SZ_LOOP(k,sb,sbsz)
{
const SbTri & t=sb[k];
mh.delete_tri(dq,t.p[0],t.p[1],t.p[2],0);
} // k 
mh.delete_que(dq,0);
dq.clear(); // not really needed unless move stuff around.. 
} // j curves
// etchfront does this... 
// IdxTy find_band(surface_band_type & band,curve_type & curve, const D & f1, const D & f2,  const etch_type & ec, const IdxTy flags)

} // i bands 

} // skip_bands

// each tape set element of the tape vector has 
// several factors but with differnet actions or parameter
IdxTy base_src=tv.srcmin(); // 4+1; // ff uses thse for boundary on verticies? 
MM_LOOP(jj,tv)
{
const TapeSet & ts=(*jj);
//curves_type curves;
typedef std::vector<curves_type>  Curvess;
// these are the etched curves which may split or even
// join. 
Curvess cvs;
ei.stagger(ts.stagger(ei.stagger()));
MM_ERR(MMPR2(ei.stagger(),ts.stagger()))
//EtchOrGrowDisjoint(cvs,ts.efactors(),curves,ef,ei,tr,let,0);
ec.m_stagger=ei.stagger();
ef.etch_disjoint(cvs, ts.efactors(), curves,  ec, 0);
//ef.etch_disjoint(cvs, factors, curves,  ec, 0);
MM_ERR(" done etching  ")
mh.add_priority_curves(cvs,ts.space,ts.gspace,base_src,2);
base_src+=cvs.size(); // TODO verify nulls disjoint etc ok 
// make the new mesh 
} // jj
mh.save_points(rv.ptsfil,0);
// this now invokes maketrimesh.edp using Hand in mesh not here... 
// don't load old src info bit 0 set 
mesh_type & metch=m_meshes[rv.new_mesh_name];
metch.make_mesh(rv.ptsfil,sin,0);

// modify the dofs to reflect etchi 
metch.adopt_dofs(ei.mesh_name,m,0);
const auto & aamcl=metch.get_adopt_matrix(ei.mesh_name,&m,0);
CustomAdopt(metch, m, aamcl,  tv, 0);
metch.write_dof("src","foofoo",16);
ei.write(rv.new_mesh_name,"eee",6); 
//m_meshes[etched_mesh_name].adopt_dofs(rv.new_mesh_name,m_meshes[rv.new_mesh_name],0);
//m_meshes[rv.new_mesh_name].adopt_dofs(ei.mesh_name,m_meshes[ei.mesh_name],0);
// the ions depend exponentially on v with no 
// current flow and want to conserve them.
// so this is more involved than interpolatin. 

// should have alrady been done... 
//ei.adopt(rv.new_mesh_name,0); 

// insure normals and ds are right
// no locations but lead with length 
ei.write(rv.new_mesh_name,"xxx",6); 
// write everything back out
if (rv.write_back_out) ei.write(0);
else MM_ERR(" skipping write back "); 

MM_ERR(" done writing  ")
if (rv.one_and_done) break; 
// signal ff... 
m_fifo.send("ready\n");
MM_ERR(" read queueed  ")
} // while true
//} catch (...) { MM_ERR(" someone threw ") } 
m_running=false;

return rc;
} // RunDisjoint

IdxTy CustomAdopt(mesh_type & metch, mesh_type & m, const Aam & aamcl,  TapeVector & tv, const IdxTy flags)
{
const auto & vv=metch.get_verticies(); 
//const auto & vm=m.get_verticies(); 
dof_type & c=metch.get_dof_rw("c");
//dof_type & Clnewer=metch.get_dof_rw("Clnewer");
dof_type & Clnewer=metch.get_dof_rw("Cl");
const dof_type & vnew=metch.get_dof("v");
dof_type & esrc=metch.get_dof_rw("src");
const dof_type & vold=m.get_dof("v");
const dof_type & Cl=m.get_dof("Cl");
//auto & aamcl=metch.get_adopt_matrix(ei.mesh_name,&m,0);
Clnewer.resize(aamcl.m_d_sz);
esrc.resize(aamcl.m_d_sz);
MM_SZ_LOOP(i,c,szc)
{
const IdxTy src=vv[i].b;
esrc.m_vals[i]=src;
//if (src!=0) tv.dof_val(c[i],src-1);
if (src>=tv.srcmin()) tv.dof_val(c[i],src-tv.srcmin());
// only new pts need iterpolation
//if (src!=0)
{
const auto kk=aamcl.m_sparse.find(i);
if ( kk==aamcl.m_sparse.end())
{
MM_ERR(" no entry in Aaam for "<<MMPR(i))
continue; 
}// end
const auto & row=(*kk).second; // aamcl.m_sparse[i];
D vx=0;
MM_LOOP(jj,row)
{
const IdxTy iold=(*jj).first;
vx+=(*jj).second*Cl[iold]*exp(40.0*(vnew[i]-vold[iold])); 
} // jj 
//Clnewer.m_vals[i]=vx;
Clnewer.m_vals[i]=vx;
} // src
//else Clnewer[i]=(Cl[i]); 
//if (src!=0) MM_ERR(MMPR3(i,src,c[i]))
} //  i

return 0;

} // CustomAdopt




///////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
IdxTy RunDisjoint(const StrTy & sin, const IdxTy flags) 
{ return 0; } 

//IdxTy CalculateActualEtch2(local_etch_type & let,const StrTy  & oldmesh, const StrTy  & new_mesh_name,const StrTy & dof, const D & lvl,const IdxTy flags)
IdxTy CalculateActualEtch2(local_etch_type & let,mesh_type & mold, MeshHood & mh,  const StrTy & dof, const D & lvl,const D & min_dist, const IdxTy flags)
{
IdxTy rc=0;
// m should be virgin 
//mesh_type & m=m_meshes.get_mesh(new_mesh_name);
//m.clear();
//mesh_type & mold=m_meshes.get_mesh(oldmesh); 
mold.isotrail(StrTy("surf"), dof,lvl,0);
trail_type &  tr= mold.get_trail_rw("surf");
if (min_dist!=0) tr.constrain_dists(min_dist,0,0);
// make a matrix to find dofs on etchfront
Aam aam;
const_vector_iterator<typename trail_type::value_type ,Tr>  begin(tr),end(tr,tr.size());
// TODO 
mold.make_aam(aam,begin,end,mh, 0);
// make trail dofmap
typename mesh_type::dofmap_type  df;
mold.adopt(df,aam,0); // get all dof values on the etchfront ... 
const dof_type & Cl=df["Cl"];
const bool index_let=(let.size());
//MM_ERR(MMPR(__FUNCTION__)<<MMPR4(c.size(),v.size(),Cl.size(),tr.size()));
//MM_DIE(" did it work ")
// the index for tr is not the dof index 
MM_SZ_LOOP(i,tr,trsz) { 
D dn=.1;
// need to interpolate for all path points. 
dn=3.0*Cl[i];
if (index_let) let[i]=dn; else let.push_back(dn); 
} // i tr 
let.save("etch_let.txt",8);
return rc;
} // CalculateActualEtch2



///////////////////////////////////////////////

// TODO FIXME local_etch_type is now just another crud layer slowing
// things down.. 

IdxTy EcFromLet( etch_type & ec, curves_type & curves, const trail_type& tr, const local_etch_type & let, const IdxTy flags)
{
IdxTy rc=0;

MM_ERR(MMPR2(tr.size(),tr.m_trail_heads.size()))
curve_type curve;
MM_SZ_LOOP(i,tr,trsz)
{
const seg_type & seg=tr[i]; // (*ii);
const D er=let[i]; // 3e-1; // *ec.factor();
ec.push_back(er);
curve.push_back(seg.x,seg.y);
const bool next=seg.terminal();
if (next) { MM_ERR(MMPR4(i,seg.closed(),curve.size(),curves.size()))} 
if (seg.closed()) curve.closed(true);
if( next) {
MM_ERR(" partial curve "<<MMPR(curve.size()))
if (curve.size())  curves.push_back(curve); curve=curve_type();
ec.next();
 }
} // i 
if ( curve.size())
{
MM_ERR(" residual curve "<<MMPR(curve.size()))
 curves.push_back(curve);
ec.next();
}


return rc;
} // EcFromLet

#if 0 
template <class Tc, class Tf> 
IdxTy EtchOrGrowDisjoint(Tc & cvs, const Tf & factors, curves_type & curves,  EtchFront & ef, const EtchInfo & ei, const trail_type & tr, const local_etch_type & let, const IdxTy flags)
{
IdxTy rc=0;
etch_type ec(ei.eps());
ec.m_stagger=ei.stagger();
MM_ERR(MMPR(ec.m_stagger))

//IdxTy EcFromLet( etch_type & ec, curves_type & curves, const trail_type& tr, const local_etch_type & let, const IdxTy flags)
EcFromLet( ec, curves, tr, let, flags);

//IdxTy erc=
//curve_type cnew;
//ef.etch(cnew, curve,  ec, 0);
ef.etch_disjoint(cvs, factors, curves,  ec, 0);

//IdxTy find_band(surface_band_type & band,curve_type & curve, const D & f1, const D & f2,  const etch_type & ec, const IdxTy flags)
return rc; 
} // EtchOrGrowDisjoint

#endif




// MEMBERS

Fifo m_fifo;
Meshes m_meshes;
bool m_running;

}; // mjm_ff_phase_bound

//////////////////////////////////////////////

template <class Tr>
class mjm_ff_phase_bound_map : public std::map<typename Tr::StrTy, mjm_ff_phase_bound< Tr > >  
{
 typedef mjm_ff_phase_bound_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_ff_phase_bound< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_ff_phase_bound_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_ff_phase_bound_map




////////////////////////////////////////////
#ifdef  TEST_MJM_FF_PHASE_BOUND
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_ff_phase_bound <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_FF_PHASE_BOUND "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_ff_phase_bound<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
else if (cmd=="run") { 
MM_ERR(" removed, find old copy of phase code ")
x.run(cip.p1,atoi(cip.p1.c_str())); }
else if (cmd=="runalt") { x.runalt(cip.p1,atoi(cip.p1.c_str())); }
else if (cmd=="run") { x.runalt(cip.p1,atoi(cip.p1.c_str())); }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_FF_PHASE_BOUND_H__ 
