#ifndef MJM_GLUT_RAGS_H__
#define MJM_GLUT_RAGS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_collections.h"
#include "mjm_string_kvp.h"
#include "mjm_so_loader.h"
#include "mjm_glut_elements.h"
#include "mjm_glut_helpers.h"
#include "mjm_ff_mesh.h"
#include "mjm_worm_blob.h"

#include <freeglut.h>
#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Wed Mar 22 13:35:49 EDT 2023
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_glut_rags   
// g++  -Wall -std=gnu++11 -DTEST_MJM_GLUT_RAGS -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_glut_rags.h  -o mjm_glut_rags.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_glut_rags("mjm_glut_rags"
, "  ");

/*
Base class for display types probably should be virtual but
decent defaults can be made. 


*/

template <class Tr>
class mjm_glut_rags 
{
 typedef mjm_glut_rags Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef pthread_t ThreadId;
typedef mjm_thread_util<Tr> ThreadTy;

typedef GLfloat Gf;

typedef mjm_glut_helpers<Tr> GlutUtil;

typedef typename  GlutUtil::draw_info_t DrawInfo;
typedef typename  GlutUtil::key_info_t KeyInfo;
typedef typename  GlutUtil::ptr_info_t PtrInfo;
typedef typename  GlutUtil::view_info_t ViewInfo;
typedef typename  GlutUtil::junk_bin_t ModelInfo;
typedef typename  GlutUtil::color_t color_type;

typedef std::vector<color_type> ColorVec;




typedef mjm_string_kvp<Tr> StrKvp;
typedef mjm_string_base_params<Tr> BaseParams;
typedef mjm_so_loader<Tr> Loader;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line ;
// this should be in traits... 
enum {BAD=~0};

// TYPEDEFS

typedef std::vector<ModelInfo>  Models;
typedef mjm_ff_mesh<Tr> FFmesh;
typedef mjm_worm_blob<Tr,D> WORMBlob;

typedef Ragged InputType;
typedef IdxTy (Myt:: * p_add_fun_type ) (const InputType & r, const IdxTy flags) ; 
typedef std::map<StrTy, p_add_fun_type> AddMap;



public:
#define HAPIRC virtual IdxTy 
typedef InputType input_type;
// too long doh 
typedef typename  GlutUtil::draw_info_t scope_draw_param_type;
//typedef typename  GlutUtil::draw_info_t DrawInfo;
typedef typename  GlutUtil::key_info_t scope_key_param_type;
typedef typename  GlutUtil::ptr_info_t scope_ptr_param_type;
enum { UNHANDLED=BAD, IGNORED=0 };
// API 
mjm_glut_rags() {Init();}
mjm_glut_rags(const StrTy & src) {Init(src);}
const StrTy srcname() const { return m_src; } 
void  srcname(const StrTy & s ) { m_src=s; } 
~mjm_glut_rags() {}
ViewInfo& view() { return m_view; } 
// add a rag to the contents
IdxTy add(const input_type & r, const IdxTy flags) 
{ return Add(r,flags); } 
void clear() {}
void event(const IdxTy e)
{
MM_ERR(MMPR2(__FUNCTION__,e))


} // event 
// view- really internal a response to input and used in draw. 

// draw 0 uses vew to render 
HAPIRC draw(scope_draw_param_type * sdp , const IdxTy flags) 
{
return Draw(sdp,flags); 

} 
// keys - modifies view usually 

// need to unify keys and "special keys or inputs "

// mouse - modifices view usually. 

HAPIRC reshape(GLint width, GLint height) { return IGNORED; }
//HAPIRC mouse_button(int button, int state, int x, int y) { return 0; }
//HAPIRC mouse_motion(int x, int y) { return 0; }
HAPIRC mouse_event(scope_ptr_param_type * spt, const IdxTy flags) 
{ return IGNORED; }
//HAPIRC animate_scene(void) {return 0;  
HAPIRC animate(const scope_draw_param_type * sdp , const IdxTy flags) 
{ return IGNORED; } 
//HAPIRC SelectFromMenu(int idCommand) { return 0; }
HAPIRC key_event(scope_key_param_type * skt, const IdxTy flags) 
{

return UNHANDLED;
} 
//HAPIRC special_input(int key, int x, int y) { return 0; } 
//HAPIRC keyboard(unsigned char key, int x, int y) {return 0; }





// save 

// load 

// short human readable info 
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
protected:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;
ss<<m_view.dump();
ss<<MMPR(m_data.size());
  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
// this is supposed to be a base class... doh 
// maybe a delegate? 
IdxTy Add(const input_type & r, const IdxTy flags) 
{
const IdxTy sz=r.size();
if (sz<3)
{
MM_ERR(" received ragged too small "<<MMPR(r.size()))
 return 0;
}
// line zero is a comment 
// id on line 1 
const StrTy ty=r[1][1];
//if (ty=="oscilloscope") return AddOscilloscope(r,flags);
//if (ty=="ffmesh") return AddFFmesh(r,flags);
const auto ii=m_add_map.find(ty);
p_add_fun_type p=0;
if (ii!=m_add_map.end())  p=(*ii).second;
if (p) (this->*p)(r,flags); 
else {
MM_ERR(" danger ignoring ragged "<<MMPR(r.dump()))
MM_ERR(" ignoring ragged "<<MMPR(ty))
if (true) return ExplainReject(r,flags);
}

return 0;
} // Add
void MakeAddMap()
{
m_add_map["oscilloscope"]=&Myt::AddOscilloscope;
m_add_map["ffmesh"]=&Myt::AddFFmesh;
m_add_map["time-snap"]=&Myt::AddTimeSnap;


} // MakeAddMap

IdxTy ExplainReject(const input_type & r, const IdxTy flags) 
{
for(IdxTy i=0; i<r.size(); ++i)
{
const Line & l = r[i];
if (l.size()<1) continue;
if (l[0]!="#" ) continue;
Ss ss;
for(int j=1; j<l.size(); ++j)  ss<<l[j]<<" ";
MM_ERR(ss.str())
} // i 
return BAD;
} // ExplainReject


/*
{ Line l; l.push_back("#"); l.push_back("id"); l.push_back("test pattern chunks "); l.push_back(idn);  r.add(l); }
{ Line l; l.push_back("#"); l.push_back("oscilloscope"); l.push_back("chunks"); r.add(l); }

{ Line l; l.push_back("#"); l.push_back("trace"); Ss ss; ss<<line;  l.push_back(ss.str()); r.add(l); }
*/

#define ADDITOR  const IdxTy sz=r.size(); for(IdxTy i=0; i<sz; ++i) { const Line & l=r[i]; const IdxTy len=l.size(); if (len<1) continue; if (l[0]=="#") continue;  

#define ADDITORC  const IdxTy sz=r.size(); for(IdxTy i=0; i<sz; ++i) { const Line & l=r[i]; const IdxTy len=l.size(); if (len<1) continue;   

#define ADDBLOBITOR  const IdxTy sz=wb.size(); for(IdxTy i=0; i<sz; i+=wb.pitch()) {     

D atof(const StrTy & s) const { return ::atof(s.c_str()); } 
IdxTy AddFFmesh(const input_type & r, const IdxTy flags) 
{
MM_ERR(" adding ffmesh" )
IdxTy rc=0;
FFmesh fmesh;
fmesh.read_ff_mesh(r,StrTy(),2,0);
// now make the model...
// TODO the source is recurring, need to save this thing... 
WORMBlob wb;
fmesh.get_mesh(wb,1);
IdxTy elsz=wb.pitch();
// assert that the size is 0 mod 6 lol.
const IdxTy szwb=wb.size();
const IdxTy leftover=szwb%elsz;
const IdxTy ntri=szwb/elsz;
MM_ERR(MMPR4(elsz,szwb,leftover,ntri));
ModelInfo mi;
mi.clear();
D xbase=0;
bool setx=false;
bool segs=true;
if (segs)
{
const IdxTy sz=wb.size(); 
for(IdxTy i=0; i<sz; i+=wb.pitch()) {     
mi.add_point(wb[i],wb[i+1],0);
mi.add_point(wb[i+2],wb[i+3],0);
mi.add_point(wb[i+2],wb[i+3],0);
mi.add_point(wb[i+4],wb[i+5],0);
mi.add_point(wb[i+4],wb[i+5],0);
mi.add_point(wb[i],wb[i+1],0);
} // ADDBLOBITOR 
mi.m_code=2;
}
else 
{
//  This needs to be locked if used.. 
//ViewInfo & v=m_view;
const IdxTy sz=wb.size(); for(IdxTy i=0; i<sz; i+=wb.pitch()) {     
mi.add_point(wb[i],wb[i+1],0);
mi.add_point(wb[i+2],wb[i+3],0);
mi.add_point(wb[i+4],wb[i+5],0);
} // ADDBLOBITOR 
mi.m_code=1;
mi.m_szlim=1;
} // not segs

MM_ERR(" done making mi for  adding ffmesh" )
AddNewModel(mi);
MM_ERR(" done adding new model   adding ffmesh" )

return rc;
} // AddFFmesh
void AddNames(ModelInfo & mi, const Line & l, const IdxTy len )
{
mi.add_names(l,2,len);

} // AddNames
void AddParams(ModelInfo & mi, const Line & l, const IdxTy len )
{
mi.add_params(l,2,len);

}// AddParams

void Rainbow(ColorVec & ct, const IdxTy flags)
{
//std::vector<color_type> ct;
ct.push_back(color_type(1,1,1));
ct.push_back(color_type(1,0,0));
ct.push_back(color_type(0,1,0));
ct.push_back(color_type(0,0,1));
ct.push_back(color_type(1,0,1));
ct.push_back(color_type(0,1,1));
} // Rainbow

IdxTy AddTimeSnap(const input_type & r, const IdxTy flags) 
{
IdxTy rc=0;
ModelInfo mi;
D xbase=0;
bool setx=false;

ColorVec ct;
Rainbow(ct,0);

//  This needs to be locked if used.. 
//ViewInfo & v=m_view;
//reject blank linkes but let comment through
ADDITORC
// params etc. 
if (l[0]=="#")
{
if (len<2) continue;
const StrTy & cmd=l[1];
if (cmd=="params"){   AddParams(mi,l,len); continue; } 
if (cmd=="names") {  AddNames(mi,l,len); continue; } 
MM_ONCE(" silently ignoring future comments like  "<<MMPR(cmd),)
continue;
}  // # 
// "x" is now in the last line entry doh 
 D x=atof(l[len-1]);
//if ( !setx){  xbase=x; setx=true; } 
x=x-xbase;
for(IdxTy j=0; j<(len-1) ; ++j)
{
const IdxTy seg=j;
const D y=atof(l[j]);
if (false) if (y>2) { MM_ERR("ydanger" << MMPR4(seg,i,y,x))
Ss ss; MM_LOOP(ii,l) { ss<<(*ii)<<" "; }
MM_ERR(" ydanger "<<MMPR(ss.str())) 
 } 
const D z=0; // (len>2)?atof(l[2]):0;
//MM_ERR(MMPR4(j,x,y,z))
//mi.add_seg(
mi.add_seg(seg,x,y,z,ct[j%ct.size()]);
} // j 

} // ADDITOR 

AddNewModel(mi);




return rc;
} // AddTimeSnap

IdxTy AddOscilloscope(const input_type & r, const IdxTy flags) 
{
ModelInfo mi;
D xbase=0;
bool setx=false;
//  This needs to be locked if used.. 
//ViewInfo & v=m_view;
ADDITOR
 D x=atof(l[0]);
//if ( !setx){  xbase=x; setx=true; } 
x=x-xbase;
const D y=atof(l[1]);
const D z=(len>2)?atof(l[2]):0;
//MM_ERR(MMPR3(x,y,z))
mi.add_point(x,y,z);
} // ADDITOR 

AddNewModel(mi);

return 0;
} // AddOscilloscope

IdxTy AddNewModel(ModelInfo & mi, const IdxTy flags=0)
{

EnterSerial(0);
m_data.push_back(mi);
IdxTy mdsz=m_data.size();
const IdxTy szlim=mi.m_szlim; // 10;
if (mdsz>szlim)
{ // TODO need a different data struct of make a circular buffer
// FIXME this is dum 
Models  _data;
if (m_debug) { MM_ERR(" trimming data stack "<<MMPR2(mdsz,szlim)) } 
IdxTy sz=szlim;
while (sz) { _data.push_back(m_data[mdsz-sz]); --sz; } 
m_data=_data;
} // size
ExitSerial(0);




return 0;
} // AddNewModel
// https://www.ece.lsu.edu/koppel/gpup/code/gpup/demo-4-simple-ogl.cc.html
void wtfmisc()
{
  glClearColor(0, 0, 0, 0);    // Red, Green, Blue, Alpha
glClear( GL_COLOR_BUFFER_BIT );

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();

  glTranslatef(-1,-0.5,-3);
  glMatrixMode(GL_PROJECTION);

  glLoadIdentity();



  // Multiply projection matrix by a frustum transformation.
  //
  // Left, Right, Top, Bottom, Front, Back
  glFrustum( -0.8, +0.8, -0.8, 0.8, 1, 5000 );


} // wtfmisc 

IdxTy DrawTri(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{
#if 0 

    glClearColor( 0, 0, 0, 1 );  // (In fact, this is the default.)
    glClear( GL_COLOR_BUFFER_BIT );
    
    glBegin(GL_TRIANGLES);
    glColor3f( 1, 0, 0 ); // red
    glVertex3f( -0.8, -0.8,0 );
    

glEnd(); 
#endif
//glEnd();
 glBegin(GL_TRIANGLES);
if (false) { 
wtfmisc(); 
 glColor3ub( 0x58, 0x0d, 0xa6); // Red, Green, Blue

  glVertex3f( 1.5, 0, -3.2 );
  glVertex3f( 0,   5, -5 );
  glVertex3f( 9,   6, -9 );


Gf fu=(Gf)v.distance;
  glColor3f(1,1,1);     // Green
  glVertex3f(0,0,0);//upper-right corner
  glVertex3f(-fu,0,0);//upper-right corner
  glVertex3f(-fu,-fu,0);//upper-right corner
  glColor3f(1,1,0);     // Green
  
  glVertex3f(2.0,2.0,2.0);//upper-right corner
  glVertex3f(-10.0*fu,-10.0*fu,0);//upper-right corner
  glVertex3f(0,10.0*fu,0);//upper-right corner

  glColor3f(0,1,0);     // Green
  glVertex3f(0,fu,0);//upper-right corner
  glVertex3f(5.0*fu,-5.0*fu,0);//upper-right corner
  glVertex3f(0,-5.0*fu,0);//upper-right corner



    glEnd();//end drawing of points
if ( true ) return 0;
} 
auto p=m.m_points;
for(IdxTy j=0; j<p.size(); ++j)
{
const auto & pj=p[j];

//Gf gb= v[vidx]*rna-c1; Gf r= gb; Gf g=1.0-4.0*(r-.5)*(r-.5) ;
//Gf b=1.0-r ;
//MM_ERR(MMPR4(lo[0],lo[1],gb,r)<<MMPR2(g,b))
Gf r=1.0;
Gf g=1.0;
Gf b=1.0;
D fu=v.distance;
int cx=j%3;
  glColor3f(r,g,b);     // Green
if (cx==0)  glColor3f(1.0,0,0);     // Green
else if (cx==1)   glColor3f(0,1.0,0);     // Green
else   glColor3f(0,0,1.0);     // Green
// distance doesn't work with line assf cuk 
Gf fukx=(pj.x-v.m_c[0])*fu;
Gf fuky=(pj.y-v.m_c[1])*fu;
Gf fukz=(pj.z-v.m_c[2])*fu;
      //MM_ERR(MMPR(i)<<MMPR4(j,Gf(fu*pj.x),Gf(fu*pj.y),Gf(fu*pj.z)))
      glVertex3f(fukx,fuky,fukz);//upper-right corner
      //glVertex3f(Gf(fu*pj.x),Gf(fu*pj.y),Gf(fu*pj.z));//upper-right corner
      //MM_ERR(MMPR3(Gf(pj.x),Gf(pj.y),Gf(pj.z)));//upper-right corner
//      glVertex3f(-1.0f,-1.0f,0.0f);//lower-left corner
//if (j==600) break; 
} // j 
    glEnd();//end drawing of points

return 0;
} // DrawTri 

IdxTy DrawSeg(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{
 glBegin(GL_LINES);
auto p=m.m_points;
for(IdxTy j=0; j<p.size(); ++j)
{
const auto & pj=p[j];

//Gf gb= v[vidx]*rna-c1; Gf r= gb; Gf g=1.0-4.0*(r-.5)*(r-.5) ;
//Gf b=1.0-r ;
//MM_ERR(MMPR4(lo[0],lo[1],gb,r)<<MMPR2(g,b))
Gf r=1.0;
Gf g=1.0;
Gf b=1.0;
D fu=v.distance;
  glColor3f(r,g,b);     // Green

int cx=j%3;
if (cx==0)  glColor3f(1.0,0,0);     // Green
else if (cx==1)   glColor3f(0,1.0,0);     // Green
else   glColor3f(0,0,1.0);     // Green


if (false) {
//distance doesn't work with  line 
Gf fukx=(pj.x-v.m_c[0])*fu;
Gf fuky=(pj.y-v.m_c[1])*fu;
Gf fukz=(pj.z-v.m_c[2])*fu;
      //MM_ERR(MMPR(i)<<MMPR4(j,Gf(fu*pj.x),Gf(fu*pj.y),Gf(fu*pj.z)))
      glVertex3f(fukx,fuky,fukz);//upper-right corner
} else { glVertex3f(Gf(pj.x),Gf(pj.y),Gf(pj.z)); } 
      //glVertex3f(Gf(fu*pj.x),Gf(fu*pj.y),Gf(fu*pj.z));//upper-right corner
      //MM_ERR(MMPR3(Gf(pj.x),Gf(pj.y),Gf(pj.z)));//upper-right corner
//      glVertex3f(-1.0f,-1.0f,0.0f);//lower-left corner
//if (j==600) break; 
} // j 
    glEnd();//end drawing of points

return 0;
} // DrawSeg


IdxTy DrawRealSeg(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{
// glBegin(GL_LINES);
// ref may not be prudcent until threading worked out lol 
const auto & _p=m.m_segs;
for(IdxTy segs=0; segs<_p.size(); ++segs)
{
const auto&  p=m.m_segs[segs];

    glBegin(GL_LINE_STRIP); //starts drawing of points
for(IdxTy j=0; j<p.size(); ++j)
{
const auto & pj=p[j];

//Gf gb= v[vidx]*rna-c1; Gf r= gb; Gf g=1.0-4.0*(r-.5)*(r-.5) ;
//Gf b=1.0-r ;
//MM_ERR(MMPR4(lo[0],lo[1],gb,r)<<MMPR2(g,b))
const color_type & ct=pj.rgb;
Gf r=ct.r;
Gf g=ct.g;
Gf b=ct.b;
D fu=v.distance;
  glColor3f(r,g,b);    
if (false) if (pj.y>2) { MM_ERR("xxdanger "<< MMPR4(segs,j,pj.x,pj.y)<<MMPR(pj.z)) } 

if (!false) 
{
//distance doesn't work with  line 
Gf fukx=(pj.x-v.m_c[0])*fu;
Gf fuky=(pj.y-v.m_c[1])*fu;
Gf fukz=(pj.z-v.m_c[2])*fu;
      //MM_ERR(MMPR(i)<<MMPR4(j,Gf(fu*pj.x),Gf(fu*pj.y),Gf(fu*pj.z)))
      glVertex3f(fukx,fuky,fukz);//upper-right corner
} else { glVertex3f(Gf(pj.x),Gf(pj.y),Gf(pj.z)); } 
      //glVertex3f(Gf(fu*pj.x),Gf(fu*pj.y),Gf(fu*pj.z));//upper-right corner
      //MM_ERR(MMPR3(Gf(pj.x),Gf(pj.y),Gf(pj.z)));//upper-right corner
//      glVertex3f(-1.0f,-1.0f,0.0f);//lower-left corner
//if (j==600) break; 
} // j 
    glEnd();//end drawing of points
} // segs
return 0;
} // DrawRealSeg




virtual IdxTy Draw(scope_draw_param_type * sdp , const IdxTy flags) 
{
//MM_ERR(__FUNCTION__)
EnterSerial(0);
ViewInfo & v=m_view;
GlutUtil::start_view(v);
const IdxTy szd=m_data.size();
for(IdxTy i=0; i<szd; ++i)
{
// TODO FIXME copy for threading issue... 
// bno help ... 
// this is organized by source so name collisions
// or different type from one source not handled right
// 
ModelInfo&  m=m_data[i];
// TOFO fix this... 
if (m.m_segs.size()) DrawRealSeg(m,v,sdp); 
 DrawLine(m,v,sdp); 
 DrawTri(m,v,sdp); 
DrawSeg(m,v,sdp); 
//ExitSerial(0);
} // i 
if (szd)
{
ModelInfo&  m=m_data[szd-1];
DrawParams(m,v,sdp);
}  // szd

ExitSerial(0);
return 0; 
} // Draw

IdxTy DrawOnCurve(ModelInfo & m, ViewInfo & v, const IdxTy seg,const char * string )
{
const auto & _p=m.m_segs;
const IdxTy segs=_p.size();
//MM_ERR(MMPR2(seg,segs))
const auto&  p=m.m_segs[seg];
const IdxTy points=p.size();
const IdxTy j=points>>1;
const auto & pj=p[j];
const color_type & ct=pj.rgb;
Gf r=ct.r;
Gf g=ct.g;
Gf b=ct.b;
D fu=v.distance;
Gf fukx=(pj.x-v.m_c[0])*fu;
Gf fuky=(pj.y-v.m_c[1])*fu;
Gf fukz=(pj.z-v.m_c[2])*fu;
//MM_ERR(MMPR4(fukx,fuky,fukz,string))
      //glVertex3f(fukx,fuky,fukz);//upper-right corner
glPushMatrix();
      glTranslatef(fukx,fuky,fukz);//upper-right corner

  glutBitmapString(GLUT_BITMAP_TIMES_ROMAN_24, (const unsigned char *)string);
  glutStrokeString(GLUT_STROKE_MONO_ROMAN, (const unsigned char *)string);
glPopMatrix();

return 0;
} 

/*
// x and y will be resolved to avoid overlap ... hopefully ... lol 
void add_text(const D & x, const D & y, const D & sz, const StrTy & s, const Tc& col,
// code==BAD not hot 
p_handler_type ptr, const IdxTy code)

*/
IdxTy DrawTextToSdp(ModelInfo & m, ViewInfo & vv, DrawInfo * sdp )
{
// TODO FIXME  this needs to match repeated code in the display
// of the curves doh 
ColorVec ctv;
Rainbow(ctv,0);
IdxTy code=0;
const IdxTy sz=12;
D x=0;
D y=0;
const IdxTy np=m.m_params.size();
const IdxTy nl=2;
D dy=1.0/(nl+np);
//sdp->m_hz.add_text(x,y,sz,"MJMDatascope 1",ctv[0],this,code);
y+=dy; // 1.0/(nl+np);
MM_LOOP(ii,m.m_params)
{
++code; // k v start at 1 with src at zero 
const StrTy & k=(*ii).first;
const StrTy & v=(*ii).second;
// draw on trace
const char * pk=k.c_str();
const char * pv=v.c_str();
if (strncmp(pk,"name",4)==0)
{
const IdxTy trace=atoi(pk+4);
const IdxTy tc=trace%ctv.size();
const color_type & ct=ctv[tc]; // pj.rgb;
sdp->m_hz.add_text(x,y,sz,v,ct,this,code);
} // name 
else
{
sdp->m_hz.add_text(x,y,sz,pk,ctv[0],this,code);
sdp->m_hz.add_text(x+.5,y,sz,pv,ctv[0],this,code);
} // param 
y+=dy; // 1.0/(nl+np);
} // ii 
y+=dy; // 1.0/(nl+np);
//GlutUtil::render_string(0.0, 0.0,0, "MJMDatascope",ctv[0]);
code=0;
sdp->m_hz.add_text(x,y,sz,StrTy("Src:") + srcname(),ctv[0],this,code);
//srcname();
return 0;
} // DrawTextToSdp


IdxTy DrawParams(ModelInfo & m, ViewInfo & vv, DrawInfo * sdp )
{
if (sdp) return DrawTextToSdp(m,vv,sdp);
int w,h;
float ff=10;
w=glutGet(GLUT_WINDOW_WIDTH);
h=glutGet(GLUT_WINDOW_HEIGHT);
if (false) MM_ERR(MMPR2(w,h))
float pi=.05*h*ff;
float c2=.2*w*ff;
ColorVec ctv;
Rainbow(ctv,0);
// TODO FIXME pass 0 should draw the trace names in model
// coords over the respective traces but it doesn't f-ing work
// f 
for (int pass=1; pass<2; ++pass)
{

if (pass==1) GlutUtil::begin_screen_coords(vv);
// glClear(GL_COLOR_BUFFER_BIT);
IdxTy n=0;
glColor3f(1,1,1);
MM_LOOP(ii,m.m_params)
{

glColor3f(1,1,1);
const StrTy & k=(*ii).first;
const StrTy & v=(*ii).second;
// draw on trace
const char * pk=k.c_str();
const char * pv=v.c_str();
if (strncmp(pk,"name",4)==0)
{
const IdxTy trace=atoi(pk+4);
const IdxTy tc=trace%ctv.size();
const color_type & ct=ctv[tc]; // pj.rgb;
Gf r=ct.r;
Gf g=ct.g;
Gf b=ct.b;
  glColor3f(r,g,b);    
if (pass==1) { 
GlutUtil::render_string(0, (n+2)*pi, pk,ctv[tc]);
GlutUtil::render_string(c2, (n+2)*pi, pv,ctv[tc]);
}
//GlutUtil::end_screen_coords(vv);
// this clears crap doh 
//GlutUtil::start_view(vv);
if (pass==0) DrawOnCurve(m, vv, trace,pv);
//GlutUtil::begin_screen_coords(vv);

}
else
{ // draw in cursor 
if (pass==1) {
GlutUtil::render_string(0, (n+2)*pi, pk,ctv[0]);
GlutUtil::render_string(c2, (n+2)*pi, pv,ctv[0]);
}


}

//void render_tring(float x, float y, void *font, const char* string, const color_t & rgb)
if (pass==1){
//GlutUtil::draw_string(0.0, (n+1)*pi,0.0, pk);
//GlutUtil::draw_string(c2, (n+1)*pi,0.0, pv);
GlutUtil::render_string(0, (n+2)*pi,0, pk,ctv[0]);
GlutUtil::render_string(c2, (n+2)*pi,0, pv,ctv[0]);
} 


++n;
} // ii 
if (pass==1) { 
//GlutUtil::draw_string(0.0, 0.0,0.0, "MJMDatascope");
GlutUtil::render_string(0.0, 0.0,0, "MJMDatascope",ctv[0]);
GlutUtil::end_screen_coords(vv);
} // pass

// glFlush();
} // pass 

return 0; 
} // DrawParams
IdxTy DrawLine(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{


    glBegin(GL_LINE_STRIP); //starts drawing of points
auto p=m.m_points;
for(IdxTy j=0; j<p.size(); ++j)
{
const auto & pj=p[j];

//Gf gb= v[vidx]*rna-c1; Gf r= gb; Gf g=1.0-4.0*(r-.5)*(r-.5) ;
//Gf b=1.0-r ;
//MM_ERR(MMPR4(lo[0],lo[1],gb,r)<<MMPR2(g,b))
Gf r=1.0;
Gf g=1.0;
Gf b=1.0;
D fu=v.distance;
  glColor3f(r,g,b);     // Green
// fng distance doesn't fing work with fug line
Gf fukx=(pj.x-v.m_c[0])*fu;
Gf fuky=(pj.y-v.m_c[1])*fu;
Gf fukz=(pj.z-v.m_c[2])*fu;
      //MM_ERR(MMPR(i)<<MMPR4(j,Gf(fu*pj.x),Gf(fu*pj.y),Gf(fu*pj.z)))
      glVertex3f(fukx,fuky,fukz);//upper-right corner
      //glVertex3f(Gf(fu*pj.x),Gf(fu*pj.y),Gf(fu*pj.z));//upper-right corner
      //MM_ERR(MMPR3(Gf(pj.x),Gf(pj.y),Gf(pj.z)));//upper-right corner
//      glVertex3f(-1.0f,-1.0f,0.0f);//lower-left corner
} // j 
    glEnd();//end drawing of points


return 0;
} // DrawLine




void Init()
{
m_debug=0;
  m_mutex_vector= MutexVector(3);;
 MakeAddMap();

} // Init

void Init(const StrTy & s)
{
m_src=s;
Init();
//m_debug=0;
//  m_mutex_vector= MutexVector(3);;
// MakeAddMap();

} // Init


// MEMBERS
StrTy m_src;
ViewInfo m_view;
ModelInfo m_background;
Models  m_data;
AddMap m_add_map;
IdxTy m_debug;
}; // mjm_glut_rags

//////////////////////////////////////////////

template <class Tr,class KeyTy >
class mjm_glut_rags_map : public std::map< KeyTy, mjm_glut_rags< Tr > * >  
{
 typedef mjm_glut_rags_map Myt;

typedef   mjm_glut_rags< Tr> ObTy;
//typedef typename  mjm_glut_rags< Tr> * ValTy;
typedef  ObTy * ValTy;
//typedef typename std::map<KeyTy, mjm_glut_rags< Tr> * >   Super;
typedef typename std::map<KeyTy, ValTy >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
typedef mjm_ragged_table Ragged;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_glut_rags_map() {Init(); }
void debug(const IdxTy d) { m_debug=d; } 
// changed to use format of first line "# id ... srcname"
// this is a map with a key type right now as Line
// which hopefully gets the first line as the index. 
// this is the source 
StrTy src_name(const Ragged & r)
{
IdxTy sz=r.size();
if (m_debug) MM_ERR(" operator [] "<<MMPR2(sz,Super::size()))
if (sz==0) return StrTy();
const Ragged::Line & l =r[0];
const IdxTy len=l.size();
if (len<3) return StrTy();
if (l[0]=="#" ) if (l[1]=="id") return l[len-1];
MM_ERR(" bad id line "<<MMPR4(r.size(),l[0],l[1],l[len-1])<<MMPR(len))
return StrTy();
} // srcname 

ValTy operator[](const Ragged & r)
{
ValTy p=0;
StrTy src=src_name(r);
if (src.length()==0)
{
MM_ERR(" no src in ragged "<<MMPR(r.size()))
src="XXXMissing";
} // nothing;
auto ii=Super::find(src);
if (ii==Super::end()) { 
MM_ERR(" noew p "<<MMPR(src))
p=new ObTy(src);  Super::operator[](src)= p; } 
else p=(*ii).second;
p->srcname(src); 
/*
IdxTy sz=r.size();
if (m_debug) MM_ERR(" operator [] "<<MMPR2(sz,Super::size()))
if (sz==0) return p;
const Line & idline=r[0];
auto ii=Super::find(r[0]);
//if (ii==Super::end()) (*this)[r[0]]= p=new ObTy();
if (ii==Super::end()) { 
MM_ERR(" noew p ")
p=new ObTy();  Super::operator[](r[0])= p; } 
else p=(*ii).second;
*/

return p;
} // operator 

void remove(const KeyTy  & src )
{
auto ii=Super::find(src);
if (ii!=Super::end()) { 
ValTy p=(*ii).second;
Super::erase(ii);
delete p;
} // end 

} // remove

StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
m_debug=0; 
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:
IdxTy m_debug;
}; // mjm_glut_rags_map




////////////////////////////////////////////
#ifdef  TEST_MJM_GLUT_RAGS
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_glut_rags <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_GLUT_RAGS "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_glut_rags<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_GLUT_RAGS_H__ 
