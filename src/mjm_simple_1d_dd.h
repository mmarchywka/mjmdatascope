#ifndef MJM_SIMPLE_1D_DD_H__
#define MJM_SIMPLE_1D_DD_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

#include "mjm_dscope_interface.h"
#include "mjm_block_matrix.h"
#include "mjm_instruments.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_worm_blob.h"
#include "mjm_collections.h"
//#include "mjm_tokenized_collections.h"
#include "mjm_canned_methods.h"

#include "mjm_pawnoff.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_generic_iterators.h"



#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


/*
<one line to give the program's name and a brief idea of what it does.>


Conceived and written by Mike Marchywka from 2023 to present.
See dates in individual code pieces as they were 
generated from my wizards. 
Copyright (C) <year> <name of author>


This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
@software{,
  author = {Michael J Marchywka},
  city = {Jasper GA 30143 USA},
  title = {},
abstract={},
institution={},
license={Knowledge sir should be free to all },
publisher={Mike Marchywka},
email={marchywka@hotmail.com},
authorid={orcid.org/0000-0001-9237-455X},
  filename={mjm_simple_1d_dd.h},
  url = {},
  version = {0.0.0},
  date-started={2023-07-31},
}
*/

// Mon 31 Jul 2023 05:12:33 PM EDT
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_simple_1d_dd   

// my script quickg++ can find this to compile a test version
// although even "apps" can be build with a similar cmnd line
// almost all of this is header files.

// QUICKCOMPILE  g++  -Wall -Wno-misleading-indentation  -MMD -MF mjm_simple_1d_dd.deps -std=gnu++11 -DTEST_MJM_SIMPLE_1D_DD -I. -I../datascope -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_simple_1d_dd.h  -o mjm_simple_1d_dd.out -lpthread -lreadline

// typical usage example 
//  2288  ./mjm_simple_1d_dd.out "source sime1d.txt"  quit 2>&1


mjm_global_credits::credit __credit__mjm_simple_1d_dd("mjm_simple_1d_dd" , "  ");

template <class Tr>
class mjm_simple_1d_dd 
{
 typedef mjm_simple_1d_dd Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

// TYPEDEF 
enum { BAD=~0};
//typedef mjm_canned_methods Canned;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map<StrTy, Ragged> RaggedMap;
typedef std::vector<StrTy> Words;
typedef mjm_string_base_params<Tr> BaseParams;

typedef mjm_dscope_interface<Tr> Dscope;



// dof values, could be ints, rats or even strings... 
typedef D ValTy;
typedef mjm_block_matrix<ValTy> Block;

typedef D LocTy;

class _points
{

class _point_cache
{
public:
_point_cache(): 
 dplus(0),dzed(0),dminus(0), d2plus(0),d2zed(0),d2minus(0) {}
_point_cache(const LocTy &plus, const LocTy & minus, const LocTy & zed)
{
const LocTy delm=zed-minus;
const LocTy delp=plus-zed;
const LocTy davg=2.0/(plus-minus);
d2plus=1.0/delp;
d2minus=1.0/delm;
d2zed=-d2plus-d2minus;
const LocTy dsum=1.0/(plus-minus);
const LocTy drat=delm*d2plus; // minus/plus
dplus=drat*dsum;
dminus=dsum/drat;
dzed=dminus-dplus;
d2plus*=davg;
d2minus*=davg;
d2zed*=davg;


}
LocTy dplus,dzed,dminus; LocTy d2plus,d2zed,d2minus;

}; // _point_cache

public:
typedef LocTy location_type;
typedef _point_cache point_cache_type;
typedef std::vector<location_type> PointVec;
typedef std::vector<point_cache_type> PointCache;



typedef  typename PointVec::const_iterator const_iterator;
_points() {Init_points(); } 

_points(const StrTy & s,  const IdxTy flags ) { Init_points(s,flags); }
_points(const Ragged & r, const IdxTy first,const IdxTy i0, const IdxTy flags ) 
{Init_points(r,first,i0,flags); } 
IdxTy add(const StrTy & s) { return Add(s); } 
IdxTy check() { return Check(); } 
IdxTy size() const  { return m_p.size(); } 
const LocTy operator[](const IdxTy i ) const { return m_p[i]; } 
const_iterator begin() const { return m_p.begin(); } 
const_iterator end() const { return m_p.end(); } 
const point_cache_type& cache(const IdxTy i) const { return m_cache[i]; } 
StrTy dump(const IdxTy flags=0)
{
Ss ss;
if (m_p.size())
ss<<MMPR3(size(),m_p[0],m_p[m_p.size()-1]);
else ss<<" _points is empty";
return ss.str();
} // dump 

private:
IdxTy Check()
{
typedef typename  std::map<LocTy,IdxTy> Wm;
Wm  f ;
MM_LOOP(ii,m_p){  ++f[(*ii)]; } 
m_p.clear(); 
MM_LOOP(jj,f) { m_p.push_back((*jj).first); } 
// make point cache...
m_cache.clear();
const IdxTy sz=m_p.size()-1;
if (sz==IdxTy(BAD)) return 0;
m_cache.push_back(point_cache_type());
for(IdxTy i=1; i<sz; ++i)
{
m_cache.push_back(point_cache_type(m_p[i+1],m_p[i-1],m_p[i]));
} // i 
m_cache.push_back(point_cache_type());

return 0; 
} // Check 
IdxTy Add(const StrTy & s) { 

BaseParams kvp(s);
D b=0,d=0;
IdxTy n=0;
kvp.get(n,"n");
kvp.get(d,"d");
kvp.get(b,"b");
MM_ERR(MMPR4(s,n,d,b))
for(IdxTy i=0; i<n; ++i) { m_p.push_back(b+i*d); } // i 
MM_ERR(MMPR(m_p.size()))
return 0; //  Add(s); 
}  // Add

void Init_points()
{

} // Init_points

void Init_points(const StrTy & s,  const IdxTy flags ) 
{ Init_points(); 
BaseParams kvp(s);

}
void Init_points(const Ragged & r, const IdxTy first,const IdxTy i0,const IdxTy flags ) 
{
Init();
const IdxTy sz=r.size();
for(IdxTy i=i0; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();

} // i 

} // Init_points

// _pointsMEMBERS
PointVec m_p;

PointCache m_cache;

 
}; // _points

typedef _points points_type;




class _species
{
typedef D ValTy;
typedef std::map<LocTy,ValTy> InitBrMap;
public:
_species() {Init_species(); } 

_species(const StrTy & s,  const IdxTy flags ) { Init_species(s,flags); }
_species(const Ragged & r, const IdxTy first,const IdxTy i0, const IdxTy flags ) 
{Init_species(r,first,i0,flags); } 
const ValTy& Dz() const { return m_dz; }
const ValTy& mu() const { return m_mu; }
const ValTy& nz() const { return m_nz; }
const ValTy& n0() const { return m_ii; }
const ValTy& nf() const { return m_if; }
const ValTy& q() const { return m_q; }
const ValTy init(const LocTy & x) const {
if (m_breaks.size()==0)  return m_nz; 
// not less than 
auto lb=m_breaks.lower_bound(x);
bool have_lb=(lb!=m_breaks.end());
const auto ub=lb; // m_breaks.upper_bound(x);
if (have_lb){ if (lb!=m_breaks.begin())  --lb; else  have_lb=false ;   } 
// ub=lb;
// strictly greater than 
const bool have_ub=(ub!=m_breaks.end());
//MM_ERR(MMPR3(x,have_lb,have_ub))
if (!have_lb&&!have_ub) return m_nz;
if (have_lb&&have_ub)
{
const LocTy ll=(*lb).first;
const LocTy ul=(*ub).first;
const ValTy lv=(*lb).second;
const ValTy uv=(*ub).second;
//MM_ERR(MMPR4(ll,ul,lv,uv))
if (lv==uv) return lv;
const D f=(x-ll)/(ul-ll); 
MM_ERR(MMPR2(f,x)<<MMPR4(ll,ul,lv,uv))
return (lv+f*(uv-lv));  
} // have both 
if ( have_lb) return (*lb).second;
if ( have_ub) return (*ub).second;
return 0; // DIE ? lol. 
} // init
StrTy dump(const IdxTy flags=0) const
{
Ss ss;
ss<<MMPR3(m_nz,m_dz,m_ii);
ss<<MMPR3(m_if,m_q,m_mu); 
MM_LOOP(ii,m_breaks) { ss<<","<<MMPR2((*ii).first,(*ii).second); } 
return ss.str();
} // dump
private:
void Init_species(const StrTy & s,  const IdxTy flags ) 
{ Init_species(); 
BaseParams kvp(s);
kvp.get(m_nz,"nz");
kvp.get(m_ii,"nzed");
kvp.get(m_if,"nend");
kvp.get(m_dz,"dz");
kvp.get(m_q,"q");
kvp.get(m_mu,"mu");
IdxTy i=0;
while (kvp.has(Br(i))&&kvp.has(Bv(i)))
{
const StrTy fckb=kvp.get(Br(i));
const StrTy shtb= kvp.get(Bv(i));
m_breaks[atof(fckb.c_str())]= atof(shtb.c_str());
MM_ERR(MMPR4(m_breaks.size(),i,fckb,shtb))
++i;
} // i 

}
StrTy Br(const IdxTy i ) const { Ss ss; ss<<"br"<<i; return ss.str(); }
StrTy Bv(const IdxTy i ) const { Ss ss; ss<<"bv"<<i; return ss.str(); }

void Init_species(const Ragged & r, const IdxTy first,const IdxTy i0,const IdxTy flags ) 
{
Init();
const IdxTy sz=r.size();
for(IdxTy i=i0; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();

} // i 

} // Init_species
void Init_species()
{
m_nz=0;
m_dz=0;
m_ii=m_nz;
m_if=m_nz;
m_q=0;
m_mu=0;
} // Init_species

// _speciesMEMBERS
ValTy  m_nz,m_dz,m_ii,m_if,m_q,m_mu; 
InitBrMap m_breaks;
}; // _species

class _react
{
public:
_react() {Init_react(); } 

_react(const Line & l,  const IdxTy first ) { Init_react(l,first); }
_react(const StrTy & s,  const IdxTy flags ) { Init_react(s,flags); }
_react(const Ragged & r, const IdxTy first,const IdxTy i0, const IdxTy flags ) 
{Init_react(r,first,i0,flags); } 
const StrTy & r(const IdxTy i ) const { return m_in[i];}
const IdxTy  nr() const { return m_in.size();}
const StrTy & p(const IdxTy i ) const { return m_out[i];}
const IdxTy  np() const { return m_out.size();}
const StrTy & c(const IdxTy i ) const { return m_cat[i];}
const IdxTy  nc() const { return m_cat.size();}
const ValTy & coef(const IdxTy i ) const { return m_consts[i];}
const IdxTy  nconsts() const { return m_consts.size();}
const bool simple_1st_cat() const 
{ return (nr()==1) &&(np()==1)&&(nc()==1)&&(nconsts()==1); }

StrTy dump( const IdxTy flags=0) const { return Dump(flags); } 
private:

StrTy Dump( const IdxTy flags=0) const  
{

Ss ss;
ss<<" about "<<MMPR4(nr(),np(),nc(),nconsts())<<MMPR(simple_1st_cat());
ss<<" from :"; MM_LOOP(ii,m_in) { ss<<" "<<(*ii); } 
ss<<" to :"; MM_LOOP(ii,m_out) { ss<<" "<<(*ii); } 
ss<<" cat :"; MM_LOOP(ii,m_cat) { ss<<" "<<(*ii); } 
ss<<" conts :"; MM_LOOP(ii,m_consts) { ss<<" "<<(*ii); } 
return ss.str(); 
} // Dump 

void Init_react()
{

} // Init_react
void Init_react(const StrTy & s,  const IdxTy flags ) 
{ Init_react(); 
BaseParams kvp(s);

}
void Init_react(const Line & l,  const IdxTy first ) 
{ 
Init_react();
IdxTy state=0;
const IdxTy len=l.size();
for(IdxTy i=first; i<len; ++i)
{
const StrTy & s=l[i];
MM_ERR(MMPR4(__FUNCTION__,s,i,m_in.size())<<MMPR(state))
if (s==";") {state=2; continue; }
if (s=="->"){ state=1; continue; }
if (s==","){ state=3; continue; }
switch (state)
{
case 0: {m_in.push_back(s); break; }  
case 1: {m_out.push_back(s); break; }  
case 2: {m_cat.push_back(s); break; }  
case 3: {m_consts.push_back(atof(s.c_str())); break; }  
default:
MM_ERR(" bad state "<<MMPR2(i,state))
}; // switch

} // i 

} // Init_react

void Init_react(const Ragged & r, const IdxTy first,const IdxTy i0,const IdxTy flags ) 
{
Init_react();
const IdxTy sz=r.size();
for(IdxTy i=i0; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();

} // i 

} // Init_react

// _reactMEMBERS
typedef std::vector<StrTy> Names;
typedef std::vector<ValTy> Coefs;
Names m_in,m_out,m_cat; 
Coefs m_consts;

}; // _react

class _mat_plus
{
typedef D V;
class _term
{
public:
_term(const IdxTy _i, const IdxTy _j, const V & _v)
:i(_i),j(_j),c(_v) {}
_term()
:i(BAD),j(BAD),c(0) {}
bool operator<(const _term & x) const
{ if (i!=x.i) return j<x.j; return i<x.i; } 

IdxTy i,j;
V c;
}; // _term 
class _term2
{
public:
_term2(const IdxTy _i, const IdxTy _j, const IdxTy _ii, const IdxTy _jj, 
const V & _v)
:i(_i),j(_j),ii(_ii),jj(_jj),c(_v) {}
_term2()
:i(BAD),j(BAD),ii(BAD),jj(BAD),c(0) {}
// TODO for the maps first test can be removed .. 
bool operator<(const _term2 & x) const
{ 
if (i!=x.i) return i<x.i; 
if (j!=x.j) return j<x.j; 
if (ii!=x.ii) return ii<x.ii; 
 return jj<x.jj; 

}  // < 

IdxTy i,j,ii,jj;
V c;
}; // _term2



typedef std::vector<_term> TermVec;
typedef std::vector<_term2> Term2Vec;
typedef std::vector<Term2Vec> Term2VecVec;
typedef std::vector<TermVec> TermVecVec;
public:
_mat_plus() {Init_mat_plus(); } 

_mat_plus(const Line & l,  const IdxTy first ) { Init_mat_plus(l,first); }
_mat_plus(const StrTy & s,  const IdxTy flags ) { Init_mat_plus(s,flags); }
_mat_plus(const Ragged & r, const IdxTy first,const IdxTy i0, const IdxTy flags ) 
{Init_mat_plus(r,first,i0,flags); } 
void clear() {m_v.clear(); m_v2.clear(); }  

// linearized by caller  
void add(const IdxTy eqn, const IdxTy var, const V & v)
{ 
if (m_v.size()<=eqn) m_v.resize(eqn+1); 
m_v[eqn].push_back(_term(eqn,var,v)); }
// an amount of conversion from a-> b depending on c purely local
// this term modifies amoount of si which includes two terms
// to conserve moles. 
void add_local(const IdxTy eqn, const IdxTy var, const IdxTy var2, const V & v)
{
if (m_v2.size()<=eqn) m_v2.resize(eqn+1); 
m_v2[eqn].push_back(_term2(eqn,var,var2,0,v));
}
void compile() { Compile(); } 
IdxTy dt(Block & dn, const Block & dofs, const ValTy & _dt) const 
{ return Dt(dn,dofs,_dt); } // dt


V operator()(const IdxTy i, const Block & b) const
{
V dn=0;
const TermVec & v=m_v[i];
const Term2Vec & v2=m_v2[i];
// this is pt, species for locality... 
MM_LOOP(ii,v) { const _term & t=(*ii); dn+=t.c*b(t.i,t.j); } // i
// this will always be local don't need ii 
MM_LOOP(ii,v2) { const _term2 & t=(*ii); dn+=t.c*b(t.i,t.j)*b(t.ii,t.jj); } 
return dn;
} // operator()

StrTy dump( const IdxTy flags=0) const { return Dump(flags); } 
private:

StrTy Dump( const IdxTy flags=0) const  
{

Ss ss;

return ss.str(); 
} // Dump 
template <class Tv> 
void CompileVector(Tv & v, const IdxTy flags=0)
{
typedef typename Tv::value_type Tvv;
const bool print_sz=Bit(flags,0);
std::map<Tvv,ValTy >  vm;
MM_LOOP(ii,v) 
{ auto jj=vm.find((*ii)); 
if (jj!=vm.end())  (*jj).second+=(*ii).c;
else  vm[(*ii)]=(*ii).c;

} // ii 
v.clear();
//v.resize(vm.size());
IdxTy i=0;
MM_LOOP(ii,vm) 
	{if ((*ii).second!=0) {  v.push_back((*ii).first); v.back().c=(*ii).second; ++i; }  } 
//v.resize(i);
if (print_sz) { MM_ERR(MMPR2(i,v.size())) } 
} // CompileVector
void Compile(const IdxTy flags=0)
{
// FIXME this is dumb
//MM_LOOP(ii,m_v) { CompileVector((*ii),1); } 
//MM_LOOP(ii,m_v2) { CompileVector((*ii),flags); } 

} // Compile 
// could have put dt in mat elements but want to iterate
// this is called with dn==dofs and actually dn is upated
// but should be the member or perm variable
IdxTy Dt(Block & dn, const Block & dofs, const ValTy & _dt) const 
{ 
MM_LOOP(ii,m_v){ 
MM_LOOP(jj,(*ii)) 
// array is accessed 1D
{const _term &t=(*jj); dn(t.i)+=_dt*t.c*dofs(t.j);}}
MM_LOOP(ii,m_v2) {  
MM_LOOP(jj,(*ii)) 
{const _term2 & t=(*jj); dn(t.i)+=_dt*t.c*dofs(t.j)* dofs(t.ii);}
}
return 0; 
} // Dt

void Init_mat_plus()
{

} // Init_mat_plus
void Init_mat_plus(const StrTy & s,  const IdxTy flags ) 
{ Init_mat_plus(); 
BaseParams kvp(s);

}
void Init_mat_plus(const Line & l,  const IdxTy first ) 
{ 
Init_mat_plus();
const IdxTy len=l.size();
for(IdxTy i=first; i<len; ++i)
{


} // i 

} // Init_mat_plus

void Init_mat_plus(const Ragged & r, const IdxTy first,const IdxTy i0,const IdxTy flags ) 
{
Init_mat_plus();
const IdxTy sz=r.size();
for(IdxTy i=i0; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();

} // i 

} // Init_mat_plus

// _mat_plusMEMBERS
TermVecVec m_v; 
Term2VecVec m_v2; 
}; // _mat_plus
typedef _mat_plus MatPlus;

class _stats
{

public:
_stats() : n(0) {}
void zpoint(const ValTy & p )
{
min=p;
max=p;
tot=p;
n=1;
} // zpoint
void point(const ValTy & p )
{
tot+=p;
if (p>max) max=p;
if (p<min) min=p;
++n;
} //point
StrTy dump(const IdxTy flags=0) const
{
Ss ss;
ss<<MMPR4(tot,min,max,n);
return ss.str();
} // dump
ValTy tot,min,max;

IdxTy n;
}; // _stats
typedef _stats stats_type;

class _runvars
{
public:
_runvars() {Init_runvars(); } 

_runvars(const Line & l,  const IdxTy first ) { Init_runvars(l,first); }
_runvars(const StrTy & s,  const IdxTy flags=0 ) { Init_runvars(s,flags); }
_runvars(const Ragged & r, const IdxTy first,const IdxTy i0, const IdxTy flags ) 
{Init_runvars(r,first,i0,flags); } 
StrTy dump( const IdxTy flags=0) const { return Dump_runvars(flags); } 
const bool send_dscope() const { return ((iter%itermod)==itersend); }  
const bool print_stats() const { return ((iter%itermod)==iterstats); }  
const bool status() const { return ((iter%itermod)==iterstatus); }  
private:

void Init_runvars(const StrTy & s,  const IdxTy flags ) 
{ Init_runvars(); 
BaseParams kvp(s);
kvp.get(dt,"dt");
kvp.get(n,"n");
kvp.get(sleep,"sleep");
kvp.get(itermod,"itermod");
kvp.get(itersend,"itersend");
kvp.get(iterstats,"iterstats");
kvp.get(iterstatus,"iterstatus");
kvp.get(geldof,"geldof");
kvp.get(ef,"ef");
//kvp.get(t,"t");

}
void Init_runvars(const Line & l,  const IdxTy first ) 
{ 
Init_runvars();
const IdxTy len=l.size();
for(IdxTy i=first; i<len; ++i)
{


} // i 

} // Init_runvars

void Init_runvars(const Ragged & r, const IdxTy first,const IdxTy i0,const IdxTy flags ) 
{
Init_runvars();
const IdxTy sz=r.size();
for(IdxTy i=i0; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();

} // i 

} // Init_runvars


StrTy Dump_runvars( const IdxTy flags=0) const  
{
Ss ss;
// ss<<MMPR4(); 
 ss<<MMPR4(dt,n,t,iter); 
 ss<<MMPR2(itermod,itersend); 
 ss<<MMPR4(iterstats,iterstatus,geldof,ef); 
return ss.str(); 
} // Dump 

void Init_runvars()
{
dt=1;
n=0;
t=0;
iter=0;
itermod=1;
itersend=0;
iterstats=0;
iterstatus=0;
sleep=0;
geldof="";
ef=0;
} // Init_runvars



// _runvarsMEMBERS
public:
ValTy dt;
IdxTy n;
ValTy t;
IdxTy iter,itermod,itersend,iterstats,iterstatus;
D sleep;
StrTy geldof; 
D ef;
}; // _runvars
typedef _runvars runvars_type;






// API

public:
typedef _species species_type;
typedef _react reaction_type;
mjm_simple_1d_dd() {Init(); }
mjm_simple_1d_dd(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
mjm_simple_1d_dd(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}

void load(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
void load(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}

void add_point(const StrTy sin) { Line l; l.push_back(sin); AddPoints(l,0); } 
IdxTy  add_species(const StrTy & nm, const StrTy sin) 
{ Line l;l.push_back(nm), l.push_back(sin); return AddSpecies(l,0); } 

IdxTy add_reaction(const Line & l,const IdxTy first) 
{return  AddReaction(l,first); } 


void check() {Check();} //   m_points.check(); } 
StrTy list( const IdxTy flags) { return List(flags); } 
void run(const StrTy & fn,const StrTy &s) {Run(fn,s); }
IdxTy setup(const Line & l, const IdxTy first)
{ return  Setup( l,  first); } 

IdxTy dscope(const StrTy & cmd, const StrTy & s) { m_dscope.load(cmd,0); return 0;  } 

void save(const StrTy & fn,const StrTy &s) {Save(fn,s); }

~mjm_simple_1d_dd() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
//typedef std::vector<species_type> Species;
typedef std::map<StrTy,species_type> Species;
typedef std::map<StrTy,IdxTy> SpeciesIdx;
typedef std::map<StrTy,reaction_type> Reactions;
int myatoi(const StrTy & s )const   { return mjm_canned_methods::myatoi(s.c_str()); }
int myatoi(const char * c) const  { return mjm_canned_methods::myatoi(c); }
static bool Bit(const IdxTy f, const IdxTy b)  { return  ((f>>b)&1)!=0; }


void Check() { 
m_points.check(); 
// cache denominaators  for derivatives

}  // Check 


// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


void Save(const StrTy & fn,const StrTy &s) {
// std::ofstream ofs(fn);

 } // Save


IdxTy Step( )
{

return 0;
} // Step
//typedef std::vector<D> Dn;

IdxTy Pause(runvars_type & rv)
{
//MM_ERR(MMPR(rv.sleep))
if (rv.sleep>0) usleep(1e6*rv.sleep);
else if (rv.sleep<0) { MM_WAIT } 
return 0; 
} // Pause

IdxTy PublishDscope(runvars_type & rv)
{
if (!rv.send_dscope()) return 0; 
Ss ss;
ss<<"# params t "<<rv.t<<" iter "<<rv.iter<<CRLF;
// NB this depends on index order matching the species map...
ss<<"# names";
MM_LOOP(ii,m_species) {  ss<<" "<<(*ii).first; } 
ss<<CRLF;
Ragged raghead=m_dscope_header;
raghead.load(ss,false);
m_dscope.send(raghead,m_dofs,0);
return 1;
} // PublishDscope

typedef Block  Dn;
void Run(const StrTy & sin,const StrTy &s) {
MM_ERR(MMPR(__FUNCTION__))
runvars_type rv(sin);
MM_ERR(MMPR(rv.dump()))
InitDofs();
SetupMat(rv);
PrintStats();
PublishDscope(rv);
//if (rv.send_dscope()) { Ragged raghead=m_dscope_header;
//m_dscope.send(raghead,m_dofs,0); } 
Pause(rv);
//MM_ERR(MMPR(rv.sleep))
//if (rv.sleep>0) usleep(1e6*rv.sleep);
//else if (rv.sleep<0) { MM_WAIT } 

while ((rv.iter<rv.n) ||(rv.n==0))
{
rv.t=rv.dt*rv.iter;
//if (rv.status()) { MM_STATUS(MMPR3(rv.sleep,rv.t,rv.iter)) } 
if (rv.status()) { MM_ERR(MMPR3(rv.sleep,rv.t,rv.iter)) } 
//IdxTy rcs=Step();
Dn dn=m_dofs; // dn(m_points.size());
const IdxTy cc=ComputeDn(dn,rv.dt,0);
PublishDscope(rv);

// adapt or exit 
if (rv.print_stats()) PrintStats();
Pause(rv);

++rv.iter;
SetupMat(rv);
} // true
// Save?


} // Run
void PrintStats()
{
const IdxTy sz=m_points.size();
if (sz==0){
MM_ERR(" no points ")
 return; 
}
//m_dofs=  Block(m_points.size(),m_species.size());
std::vector<stats_type> stats(m_species.size());
MM_LOOP(ii,m_spicies_idx)
{
const IdxTy si=(*ii).second;
const StrTy & nm=(*ii).first;
stats_type & st=stats[si];
//const species_type & sp=m_species[nm];
st.zpoint(m_dofs(0,si));
for(IdxTy i=1; i<sz; ++i) { st.point(m_dofs(i,si)); } // i 
MM_ERR(MMPR2(nm,st.dump()))

} // ii 



} // PrintStats

void InitDofs()
{
//m_dofs=  Block(m_points.size(),m_species.size());
m_dofs.zero();
const IdxTy ms=m_species.size();
MM_LOOP(ii,m_species)
{
MM_ERR(" INIT DOF "<<MMPR2((*ii).first,(*ii).second.dump()))
const IdxTy si=m_spicies_idx[(*ii).first];
IdxTy i=0; 
MM_LOOP(jj,m_points)
{
m_dofs(i,si)=(*ii).second.init((*jj));
++i;
} // jj 
} // ii 
IdxTy i=0; 
MM_LOOP(ii,m_points)
{
m_dofs(i,ms)=(*ii);
++i;
} // ii 


} // InitDofs
IdxTy ComputeDn(Dn & dn, const ValTy & dt, const IdxTy flags) //const
{
IdxTy rc=0;
// could define a smart multiply? 
m_mat_plus.dt(m_dofs,dn,dt);
//MM_SZ_LOOP(i,m_points,szp) { dn[i]=m_mat_plus(i,m_dofs); } // i 

return rc;
} // ComputeDn
// needs to preserve or change based on dofs or point location 
IdxTy SetupMat(runvars_type & rv)
{
const bool have_geldof=(rv.geldof!="");
const IdxTy geldofi=have_geldof?m_spicies_idx[rv.geldof]:BAD;
m_mat_plus.clear();
const IdxTy pi=1;
const IdxTy pf=m_points.size()-1;
MM_LOOP(ii,m_species)
{
const auto & sp =(*ii).second;
const IdxTy si=m_spicies_idx[(*ii).first];
//const auto & e=(*ii).second;
// setup diffusion - depends on points but also D(n) 
const ValTy _dif=sp.Dz();
if (_dif!=0)
{
for(IdxTy i=pi; i<pf; ++i)
{
ValTy dif=_dif;
if (have_geldof) dif=dif/(1.0+exp(rv.ef*m_dofs(i,geldofi)));
const auto ci=m_points.cache(i);
const IdxTy iz=m_dofs.idx(i,si); 
const IdxTy ip=m_dofs.idx(i+1,si); 
const IdxTy im=m_dofs.idx(i-1,si); 
m_mat_plus.add(iz,iz,dif*ci.d2zed);
m_mat_plus.add(iz,ip,dif*ci.d2plus);
m_mat_plus.add(iz,im,dif*ci.d2minus);

} // i 

} // zero 

} // ii species
// depends on dofs.... 
MM_LOOP(ii,m_reactions)
{
const reaction_type  & e=(*ii).second;
const bool ok=e.simple_1st_cat();
if (!ok) 
{
MM_ERR(" bad reaction "<<MMPR2((*ii).first,e.dump()))
}
const IdxTy ri=m_spicies_idx[e.r(0)];
const IdxTy pi=m_spicies_idx[e.p(0)];
const IdxTy ci=m_spicies_idx[e.c(0)];
const ValTy c=e.coef(0);

// needs reactant, product, catalyst
// appears in r and p eqns including a catalyst factor
// I guess really these are always local so  no point
// offset needed 
for(IdxTy i=pi; i<pf; ++i)
{
//void add_local( eqn,  var,  var2, v)
const IdxTy rii=m_dofs.idx(i,ri); 
const IdxTy pii=m_dofs.idx(i,pi); 
const IdxTy cii=m_dofs.idx(i,ci); 
m_mat_plus.add_local(rii,rii,cii,-c);
m_mat_plus.add_local(pii,rii,cii,c);

} // i 


} // ii reactions 
m_mat_plus.compile();


return 0; 
} // SetupMat

IdxTy AddPoints(const Line & l, const IdxTy first)
{
m_points.add(l[first]);
return 0; 
} // AddPoints
IdxTy  AddReaction(const Line & l,const IdxTy first) 
{
if ( l.size()>(first+1))
{ m_reactions[l[first]]=reaction_type(l,first+1); 
MM_ERR(MMPR(m_reactions[l[first]].dump()));
}
return 0; 
} // AddReaction
IdxTy AddSpecies(const Line & l, const IdxTy first)
{
if (l.size()<(first+2) ) return 1 ;
m_species[l[first]]=species_type(l[first+1],0);
return 0; 
} // AddPoints

IdxTy Setup(const Line & l, const IdxTy first)
{
MM_ERR(MMPR(__FUNCTION__))
// setup points
check();
// make block right size
// keep this order so dofs are adjacent 
// add "x" into species +1
m_dofs=  Block(m_points.size(),1+m_species.size());
IdxTy i=0;
MM_LOOP(ii,m_species)
{
m_spicies_idx[(*ii).first]=i;
++i;
} // ii 
return 0; 
} //Setup 
void Init(const Ragged & r, const IdxTy start=0, const IdxTy first=0, const IdxTy flags=0  )
{
Init();
const IdxTy sz=r.size();
for(IdxTy i=start; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();
// species and points
switch (len)
{
case 0: { continue; } 
case 1: { continue; } 
default:

if (l[0]=="point"){  AddPoints(l,1); continue; } 
if (l[0]=="points"){  AddPoints(l,1); continue; } 
if (l[0]=="species"){  AddSpecies(l,1); continue; } 
if (l[0]=="setup"){  Setup(l,1); continue; } 
if (l[0]=="dscope"){  m_dscope.load(l[1],0); continue; } 

} // switch len 

}  // i 

} // Init 
void Init(const StrTy  & sin,const IdxTy flags =0  )
{
Init();
BaseParams kvp(sin);
StrTy single=kvp.get("");
if (single.length()) { 
Ragged r;
r.load(single);
Init(r,0,0,flags); 
return ;
} 

} // Init 
 
void Init()
{
Ss ss;
ss<<"# id test pattern chunks simple1d"<<CRLF;
ss<<"# time-snap 1D "<<CRLF;
ss<<"# trace "<<CRLF;
//ss<<""<<CRLF;
m_dscope_header.load(ss,false);

} // Init

StrTy List( const IdxTy flags) 
{ 
Ss ss;
ss<<MMPR(m_points.dump())<<CRLF;
MM_LOOP(ii,m_species) { ss<<(*ii).first<<" "<<(*ii).second.dump()<<CRLF; }
MM_LOOP(ii,m_reactions) { ss<<(*ii).first<<" "<<(*ii).second.dump()<<CRLF; }
return ss.str(); 
} // List 


// MEMBERS

Dscope m_dscope;
Ragged m_dscope_header;
points_type m_points;
Species m_species;
SpeciesIdx m_spicies_idx;
Reactions m_reactions;
Block m_dofs;
MatPlus m_mat_plus;
}; // mjm_simple_1d_dd

//////////////////////////////////////////////

template <class Tr>
class mjm_simple_1d_dd_map : public std::map<typename Tr::StrTy, mjm_simple_1d_dd< Tr > >  
{
 typedef mjm_simple_1d_dd_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_simple_1d_dd< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_simple_1d_dd_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{


}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_simple_1d_dd_map




////////////////////////////////////////////
#ifdef  TEST_MJM_SIMPLE_1D_DD
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_simple_1d_dd <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_SIMPLE_1D_DD "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}
typedef mjm_ragged_table Ragged;
int main(int argc,char **args)
{
about();
typedef mjm_simple_1d_dd<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="loadragged") {
 	const IdxTy start=atoi(cip.wif(2).c_str()); 
	const IdxTy first=atoi(cip.wif(3).c_str()); 
	const IdxTy flags=atoi(cip.wif(4).c_str()); 
Ragged r; r.load(cip.p1); x.load(r,start,first,flags); }
if (cmd=="load") {x.load(cip.p1,atoi(cip.p2.c_str())); }
if (cmd=="save") {x.save(cip.p1,cip.p2); }
if (cmd=="add_point") {x.add_point(cip.p1); }
if (cmd=="add_species") {x.add_species(cip.p1,cip.p2); }
if (cmd=="add_reaction") {x.add_reaction(li.words(),1); }
if (cmd=="list") {MM_ERR(MMPR(x.list(atoi(cip.p1.c_str())))); }
if (cmd=="check") {x.check(); }
if (cmd=="setup") {x.setup(li.words(),1); }
if (cmd=="run") {x.run(cip.p1,cip.p2); }
if (cmd=="dscope"){  x.dscope(cip.p1,cip.p2); continue; } 
if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="source") {li.source(cip.p1); }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_SIMPLE_1D_DD_H__ 
