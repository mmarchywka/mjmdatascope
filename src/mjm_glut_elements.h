#ifndef MJM_GLUT_ELEMENTS_H__
#define MJM_GLUT_ELEMENTS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_collections.h"
#include "mjm_string_kvp.h"
#include "mjm_so_loader.h"



#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Thu Mar  2 05:39:36 EST 2023
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_glut_elements   
// g++  -Wall -std=gnu++11 -DTEST_MJM_GLUT_ELEMENTS -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_glut_elements.h  -o mjm_glut_elements.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_glut_elements("mjm_glut_elements"
, "  ");

template <class Tr>
class mjm_glut_elements 
{
 typedef mjm_glut_elements Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef pthread_t ThreadId;
typedef mjm_thread_util<Tr> ThreadTy;

//typedef GLfloat Gf;
typedef D Loc;
typedef D V;

typedef mjm_string_kvp<Tr> StrKvp;
typedef mjm_string_base_params<Tr> BaseParams;
typedef mjm_so_loader<Tr> Loader;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line ;
// this should be in traits... 
enum {BAD=~0};


class _element
{
typedef std::vector<V> Vals;
typedef std::vector<Loc> Point;
typedef std::pair<Point,Vals> Pv;
typedef std::vector<Pv> Vx;
public:
IdxTy size() const { return m_vx.size(); } 
void add(const Line & l , const IdxTy flags)
{
const IdxTy sz=l.size();
if (sz<8)
{
MM_ERR(" line too short to add "<<MMPR(sz))
MM_LOOP(ii,l){ MM_ERR(MMPR((*ii))) }
return;
}
Loc x=atof(l[1].c_str());
Loc y=atof(l[2].c_str());
Point loc;
loc.push_back(x);
loc.push_back(y);
Vals v;
for(IdxTy i=3; i<(sz-4); ++i) v.push_back(atof(l[i].c_str()));
m_vx.push_back(Pv(loc,v));
} // add

Vx m_vx;
}; // _element
public:
typedef _element Element;
typedef std::vector<Element> Elements;
private:
typedef std::vector<IdxTy> FukTy;

typedef std::map<IdxTy, FukTy> ElNodes;
typedef std::map<StrTy, StrTy> Properties;

// each node line now also defines an element number based on 4 trailing
// node numbers if these are not BAD 
IdxTy MakeElements(Elements & el, const Ragged & r, const IdxTy flags)
{
// made of element numbers with 4 nodes in vector 
ElNodes en;
// this seems to have fixed flakey failure mode TODO FIXME WHY?? 
// it really did not, was trying to display half assed thing. 
std::map<IdxTy,IdxTy> ntol;
// first get the node defs
MM_SZ_LOOP(i,r,szr)
{
const Line & l = r[i];
IdxTy lsz=l.size();
const bool is_kvp=((lsz==3)?(l[1]=="="):false);
if (is_kvp) { m_kvp[l[0]]=l[2]; continue; } 
IdxTy n=atof(l[0].c_str());
ntol[n]=i;
std::vector<IdxTy> ne; // each entry in en contains a vctor of nodes that make theleemnt 
for(IdxTy j=lsz-4; j<lsz; ++j)
{
if (l[j]!="-1")
{
IdxTy e=atoi(l[j].c_str());
ne.push_back(e);
} // if 
} // j 
// this uses the node number for the element number 
if (ne.size()) en[n]=ne;
} // ii
el.resize(en.size());
MM_LOOP(ii,en)
{
const IdxTy eln=(*ii).first; // element number
// for each node that makes up the element get the info 
MM_LOOP(jj,(*ii).second)
{ // nodes were assumed to be on the same line number 
el[eln].add(r[ntol[(*jj)]],0); // hopefullyu the lines match the number lll 
} // jj 
}  // ii 

return 0;
} // MakeElements 

class _stats
{
public:
_stats(): n(0),mmin(0),mmax(0),sum(0) {}
void add(const V & p)
{
if (n==0) {mmin=p; mmax=p;}
else { if (p>mmax) mmax=p ; if (p<mmin) mmin=p; } 
sum+=p;
++n;
}
IdxTy n;
V mmin,mmax,sum;

}; // _stats

typedef _stats Stats;
typedef std::vector<Stats> StatsVec;


public:
mjm_glut_elements() {}
IdxTy make_elements( const Ragged & r, const IdxTy flags)
{  
//MM_ERR(" makig elements f ")
MakeElements(m_el, r, flags); 
//MM_ERR(" shoudl now make stats   ")
//std::cerr.flush();
return MakeStats(m_el,flags);  
//return 0;
}
~mjm_glut_elements() {}
const IdxTy size() const { return m_el.size(); } 
const IdxTy nvalues() const { return m_stats.size(); } 
void text(Ss & ss, const IdxTy flags)const  { Text(ss,flags); }
const Element & operator[](const IdxTy n ) const { return m_el[n]; }
const Stats& operator()(const IdxTy n ) const { return m_stats[n]; }
typename Elements::const_iterator begin() const { return m_el.begin(); } 
typename Elements::const_iterator end() const { return m_el.end(); } 
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
void Text(Ss & ss, const IdxTy flags)  const
{ 
MM_LOOP(ii,m_kvp)
{
const StrTy &k=(*ii).first;
const StrTy &v=(*ii).second;
ss<<" "<<k<<"="<<v;
} // ii 
} // Text

IdxTy MakeStats(Elements & el, const IdxTy flags)
{
//MM_ERR(MMPR(__FUNCTION__))
MM_LOOP(ii,el)
{
const Element & e=(*ii); // vector for now
//_element/
//m_vx.push_back(Pv(loc,v));
IdxTy i=0;
//MM_ERR(MMPR2(e.m_vx.size(),e.size())) //  m_stats.push_back(Stats()); 
MM_LOOP(jj,e.m_vx)
{
const auto& locs=(*jj).first;
const auto& vals= (*jj).second;
//MM_ERR(MMPR2(m_stats.size(),vals.size())) //  m_stats.push_back(Stats()); 
while (m_stats.size()<vals.size()) m_stats.push_back(Stats()); 
MM_SZ_LOOP(k,vals,vsz) {m_stats[k].add(vals[k]); } 
if ((i==0)||(locs[0]<m_xmin)) m_xmin=locs[0]; 
if ((i==0)||(locs[0]>m_xmax)) m_xmax=locs[0];
if ((i==0)||(locs[1]<m_ymin)) m_ymin=locs[1];
if ((i==0)||(locs[1]>m_ymax)) m_ymax=locs[1];

++i; // total vertex count
} // jj 


} // ii 

return 0;
} // MakeStats
// MEMBERS
Loc m_xmin,m_xmax,m_ymin,m_ymax;
Elements m_el;
StatsVec m_stats;
Properties m_kvp;
}; // mjm_glut_elements

//////////////////////////////////////////////

template <class Tr>
class mjm_glut_elements_map : public std::map<typename Tr::StrTy, mjm_glut_elements< Tr > >  
{
 typedef mjm_glut_elements_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_glut_elements< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_glut_elements_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_glut_elements_map




////////////////////////////////////////////
#ifdef  TEST_MJM_GLUT_ELEMENTS
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_glut_elements <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_GLUT_ELEMENTS "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_glut_elements<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_GLUT_ELEMENTS_H__ 
