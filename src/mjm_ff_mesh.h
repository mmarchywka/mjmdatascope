#ifndef MJM_FF_MESH_H__
#define MJM_FF_MESH_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
//#include "mjm_data_model_error_log.h"
#include "mjm_block_matrix.h"
#include "mjm_instruments.h"
#include "mjm_pawnoff.h"
#include "mjm_ff_objects.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_worm_blob.h"
#include "mjm_affine_mesh_hood.h"
#include "mjm_generic_iterators.h"

#include "mjm_canned_methods.h"
//#include "mjm_dscope_dgram.h"

#include "mjm_cli_ui.h"

#include "mjm_tokenized_collections.h"

#include <map> 
#include <set> 
#include <vector> 
#include <deque> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Sat 27 May 2023 08:37:15 AM EDT
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_ff_mesh   

// g++  -Wall -std=gnu++11 -DTEST_MJM_FF_MESH -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0 -Wno-misleading-indentation  -x c++ mjm_ff_mesh.h  -o mjm_ff_mesh.out -lpthread -lreadline



// g++  -Wall -std=gnu++11 -DTEST_MJM_FF_MESH -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_ff_mesh.h  -o mjm_ff_mesh.out -lpthread -lreadline
/*
Read or write a freefem mesh. Should be general but not sure
what others support 

This seems to work but never tested the equalitie code
which is complicated because the hit only has one vertex
not two. Will have to wait or generate a dof..

 2092  g++  -Wall -std=gnu++11 -DTEST_MJM_FF_MESH_ADAPT -Wno-misleading-indentation  -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_ff_mesh_adapt.h  -o mjm_ff_mesh_adapt.out -lpthread -lreadline
 2093  ./mjm_ff_mesh_adapt.out "load foo play/equsaven.msh" "conform doo foo" "dof c play/equsavenc.txt foo"  "iso foo c c .5" quit  2>&1
 2094  ./backup
 2095  ./mjm_ff_mesh_adapt.out "load foo play/equsaven.msh" "conform doo foo" "dof c play/equsavenc.txt foo"  "iso foo c c .5" quit  2>&1


A lot of intricate but useless code is in scraps in 
mjm_ff_mesh_11.h
mjm_ff_mesh_1.h

*/


mjm_global_credits::credit __credit__mjm_ff_mesh("mjm_ff_mesh"
, "  ");

template <class Tr>
class mjm_ff_mesh 
{
 typedef mjm_ff_mesh Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
typedef OsTy Os;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
// BAD should be in traits
enum { BAD=~0}; 
typedef mjm_canned_methods Canned;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map<StrTy, Ragged> RaggedMap;
typedef std::vector<StrTy> Words;
typedef mjm_string_base_params<Tr> BaseParams;

typedef mjm_ff_node<Tr> vertex_type;
typedef vertex_type V;
typedef std::vector<vertex_type> Verticies;

typedef mjm_adapt_adopt_matrix<Tr,Myt> Aam;
typedef std::map<StrTy, Aam> AdoptMap;

// TYPEDEF
typedef mjm_affine_mesh_hood<Tr> MeshHood;
typedef mjm_block_matrix<D> MyMatrix;
typedef mjm_pawnoff<Tr>  Hand;
typedef mjm_blob<Tr>  Blob;


// API 
public:
mjm_ff_mesh() {}
~mjm_ff_mesh() {}
// note the FF numbering starts a 1 not zero... 
typedef mjm_ff_triangle<Tr,Myt> tri_type;
typedef std::vector<tri_type> Triangles;
typedef mjm_ff_edge<Tr> edge_type;
typedef std::vector<edge_type> Edges;
typedef mjm_worm_blob<Tr,D> WORMBlob;
typedef mjm_ff_seg<Tr> seg_type;
//typedef std::vector<seg_type> trail_type;
typedef mjm_ff_trail<Tr,Myt> trail_type;
//typedef  Verticies trail_type;
typedef std::map<StrTy,trail_type> Trails;
typedef Aam adopt_matrix_type;
typedef mjm_ff_path<Tr> path_type;

typedef mjm_ff_dof<Tr,Myt> dof_type;
typedef std::map<StrTy,dof_type> Dofs;
typedef Dofs dofmap_type;
void clear() { Clear(); }
IdxTy size() const { return m_verticies.size(); }
IdxTy size(const IdxTy n) const { return Size(n); }
IdxTy read_ff_mesh(const StrTy & fn, const StrTy & sv, const IdxTy flags)
{ return ReadFFMesh(fn,sv,flags); } 
IdxTy read_ff_mesh(const Ragged & r, const StrTy & sv, const IdxTy start, const IdxTy flags)
{ return  LoadFFMesh( r,  sv, start, flags); } 
// TODO needs a mode to write only the verticies for triangulate to mesh 
IdxTy write(const StrTy & fn, const StrTy & sv, const IdxTy flags)
{ return Write(fn,sv,flags); } 
IdxTy get_path(path_type & path, const IdxTy bn, const IdxTy flags) const
{ return GetPath(path,bn,flags); }
void get_mesh(WORMBlob & wb, const IdxTy flags) const { GetMesh(wb,flags); } 
IdxTy make_mesh(const StrTy & ptsfile, const StrTy &sin, const IdxTy flags)
{ return MakeMesh(ptsfile,sin,flags); } 
IdxTy change_boundary_numbers(const IdxTy flags)
{ return ChangeBoundaryNumbers(flags); } 

const Verticies & get_verticies() const { return m_verticies; }
IdxTy save_dofs(const StrTy & fn, const IdxTy flags)
{ return SaveDofs(fn,flags); }
IdxTy dump_path(const StrTy & fn , const path_type & path, const IdxTy flags) const
{ return DumpPath(fn,path,flags); }
IdxTy dump_edges(const StrTy & fn ,  const IdxTy flags) const
{ return DumpEdges(fn,flags); }
IdxTy read_dof(const StrTy & dof, const StrTy & fn, const IdxTy flags)
{ return ReadDof(dof,fn,flags); } 
IdxTy write_dof(const StrTy & dof, const StrTy & fn, const IdxTy flags)
{ return WriteDof(dof,fn,flags); } 
const dof_type & get_dof(const StrTy & nm) { return m_dofs[nm]; } 
dof_type & get_dof_rw(const StrTy & nm) {m_dofs[nm].m_mesh=this;  return m_dofs[nm]; } 
IdxTy adopt(dofmap_type & dm, const Aam & aam, const IdxTy flags) const
{
MM_LOOP(ii,m_dofs) { dm[(*ii).first]=aam((*ii).second); } 
return 0; 
}
Aam& get_adopt_matrix(const StrTy & oldmesh, Myt * tholdp, const IdxTy flags)
{ return  GetAdoptMatrix( oldmesh,tholdp,  flags) ; } 
IdxTy adopt_dof(const StrTy & dof, const StrTy & oldmesh, Myt & thold, const IdxTy flags)
{ return AdoptDof(dof,oldmesh,thold,flags); } 
IdxTy adopt_dofs( const StrTy & oldmesh, Myt & thold, const IdxTy flags)
{ return AdoptDofs(oldmesh,thold,flags); } 

void clear_adopt() { m_adopts.clear(); } 
template <class Tv> 
void make_aam(adopt_matrix_type  & aam, const_vector_iterator<Tv,Tr> begin, const_vector_iterator<Tv,Tr> end, MeshHood& mh  , const IdxTy flags)
{ MakeAam( aam, begin, end , mh, flags); }

IdxTy isotrail(const StrTy  & trailn, const StrTy & dofn, const D & v, const IdxTy flags) //const
{ return IsoTrail(m_trails[trailn],dofn,v,flags); } 
IdxTy isotrail(trail_type & trail, const StrTy & dofn, const D & v, const IdxTy flags) //const
{ return IsoTrail(trail,dofn,v,flags); }
const trail_type &  get_trail(const StrTy & s)  { return m_trails[s]; } 
trail_type &  get_trail_rw(const StrTy & s)  { return m_trails[s]; } 
 
 
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
static bool Bit(const IdxTy f, const IdxTy b)  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
IdxTy SaveDofs(const StrTy & fn, const IdxTy flags)
{ std::ofstream os(fn); return SaveDofs(os,flags); } 

IdxTy SaveDofs( OsTy & os, const IdxTy flags)
{
const bool hdr=!Bit(flags,0);
if (hdr)
{
os<<"x"<<" "<<"y";
MM_LOOP(ii,m_dofs) { os<<" "<<(*ii).first; } 
os<<CRLF;
} // hdr

MM_SZ_LOOP(i,m_verticies, szv)
{
os<<m_verticies[i].x<<" "<<m_verticies[i].y;
MM_LOOP(ii,m_dofs) { os<<" "<<(*ii).second[i]; } 
os<<CRLF;
} //i 

return 0; 
} // SaveDofs


// the saved  point format is as follows, 
// os<<p.x<<" "<<p.y<<" "<<p.src<<" "<<serial<<" "<<block<<CRLF;
// so we can add src+5 to the point types. 
// or edges using the trails but that is a mess... 
IdxTy MakeMesh(const StrTy & ptsfil, const StrTy &sin, const IdxTy flags)
{ 
const bool  add_src_info_from_hood =!Bit(flags,0); //  true; 
// TODO FIXME these names need to be documented non-conflicting etc. 
const StrTy newmesh="newmeshfil.msh";

Hand hand;
//mh.save_points(ptsfil,0);
Blob d,out,err;
StrTy cmd="( FreeFem++ ./play/maketrimesh.edp -load "+ptsfil+" -save "+newmesh+" 2>&1 | tail -n 50 )  "; 
hand.fileio(out,err,d,cmd);
MM_ERR(MMPR3(StrTy(err),StrTy(out),cmd))
read_ff_mesh(newmesh,sin,0);
change_boundary_numbers(0); 
if (add_src_info_from_hood)
{
Ragged r;
r.load(ptsfil);
MM_SZ_LOOP(i,r,szr)
{
const Line  & l=r[i];
const IdxTy len=l.size();
if (len!=5)
{
MM_ERR(" wrong len mayu bomb "<<MMPR4(ptsfil,i,r.size(),len))
}
const D x=atof(l[0].c_str()); 
const D y=atof(l[1].c_str()); 
const IdxTy src =atoi(l[2].c_str()); 
const IdxTy serial =atoi(l[3].c_str()); 
// block meaninfless here... 
//const IdxTy block=atoi(l[0].c_str()); 
// doh serial is the block serial not point serial.. 
//if (false) 
if (serial!=i)
{
MM_ERR(" points  order wrong in ptsfil  "<<MMPR(ptsfil)<< MMPR4(x,y,i,serial))
} // serial 
// be default mh writs with 12 digits precision
// but not sure what FF etc does 
const D tol=1e-6;
auto & p=m_verticies[i];
const D dx=x-p.x;
const D sx=x+p.x;
const D dy=y-p.y;
const D sy=y+p.y;
// zero should mean zero... 
const bool xbad= (fabs(dx)>tol*fabs(sx) );
const bool ybad= (fabs(dy)>tol*fabs(sy) );
if (xbad||ybad)
{
MM_ERR(" points dont line up "<<MMPR4(x,p.x,y,p.y)<<MMPR2(ptsfil,i))
} // bad 
// not to be confused with boundary numbers.. 
p.b=src;
} // i 

} // add_src_info_from_hood
//MM_DIE(" see if this worked ")

return 0; 
//  return MakeMesh(ptsfile,sin,flags); } 
//m_meshes[new_mesh_name].make_mesh(ptsfile,sin,0);
} // MakeMesh 







IdxTy ChangeBoundaryNumbers(const IdxTy flags)
{ 
// if the initial mesh is here, then the isocurves
// could be labelled too... 
// from surface.idp, 
// left=1, top=2, right=3, boyt=4, surf=5
//const bool surfaces_idp_numbers=!Bit(flags,0);
// apparently triangulate results all the edges with type 1"
// need to change into defalt of the electrop convention
MeshHood mh;
mh.infer(m_verticies,0);
//mh.add(thold.m_verticies,0,0);
// get l r b t
MM_SZ_LOOP(i,m_edges,sz)
{
auto & e=m_edges[i];
const auto & p1 =m_verticies[e.p1-1];
const auto & p2 =m_verticies[e.p2-1];
IdxTy b1=mh.edge_codes(p1.x,p1.y,0);
IdxTy b2=mh.edge_codes(p2.x,p2.y,0);
int bc=b1&b2;
int b=0;
while (bc>>=1) ++b;
e.b=b;

} // i 

return 0; 

} // ChangeBoundaryNumbers 


IdxTy DumpPath(const StrTy & fn , const path_type & path, const IdxTy flags) const
{ 
std::ofstream os(fn);

return DumpPath(os,path,flags); 
} // DumpPath

IdxTy DumpPath(OsTy & os , const path_type & path, const IdxTy flags) const
{ 
IdxTy i=0; 
MM_LOOP(ii,path.m_p)
{
MM_LOOP(jj,(*ii))
{
const V & p = m_verticies[(*jj)-1];
os<<i<<" "<<p.x<<" "<<p.y<<" "<<p.b<<" "<<(*jj)<<CRLF;
} // jj 
++i;
} // ii 

return 0;
} // DumpPath
 
IdxTy DumpEdges(const StrTy & fn ,const IdxTy flags) const
{ 
std::ofstream os(fn);

return DumpEdges(os,flags); 
} // DumpEdges

IdxTy DumpEdges(OsTy & os ,  const IdxTy flags) const
{ 
IdxTy i=0; 
MM_LOOP(ii,m_edges)
{
const V & p1 = m_verticies[(*ii).p1-1];
const V & p2 = m_verticies[(*ii).p2-1];
os<<i<<" "<<p1.x<<" "<<p1.y<<" "<<p2.x<<" "<<p2.y<<" "<<(*ii).b<<CRLF;
++i;
} // ii 

return 0;
} // DumpPath
 
 



IdxTy GetPath(path_type & path, const IdxTy bn, const IdxTy flags) const 
{
MM_LOOP(ii,m_edges)
{
if ((*ii).b!=bn) continue;
path.add_edge((*ii).p1,(*ii).p2);
} // ii 
path.concat_all(0);
return 0; 
} // GetPath

IdxTy ReadFFMesh(const StrTy & fn, const StrTy & sv, const IdxTy flags)
{
Ragged r;
r.load(fn);
MM_ERR(" loading mesh file "<<MMPR4(fn,r.size(),sv,flags))
return LoadFFMesh(r,sv,0,flags); ;
} 
/*
ð‘› ð‘£ denotes the number of vertices, 
ð‘› ð‘¡ the number of triangles 
and ð‘› ð‘  the number of edges
n_v n_t n_e
q_x1 q_y1 boundary label = 1 ( vertex coords 
I_1 I_2 I_3 region lagel =0  ( triangle verex numbers ) 
I_1 I_2 boundary labl=1


*/
IdxTy LoadFFMesh(const Ragged & r, const StrTy & sv, const IdxTy _start, const IdxTy flags)
{
const bool save_old=Bit(flags,0);
const bool total_area=!Bit(flags,1);
const bool write_R=!Bit(flags,2);
MM_ERR(MMPR4(__FUNCTION__,save_old,total_area,write_R)<<MMPR(flags))
if (!save_old) Clear(); 
const IdxTy sz=r.size();
IdxTy start=_start;
if (sz<(1+start))
{
MM_ERR(" blank mesh file do nothing ");
return 0;
} // sz
IdxTy i=start;
{ // scoping 
while (start<r.size()) { 
if (r[start].size()==0) { ++start; continue; }
if (r[start][0].c_str()[0]=='#') { ++start; continue; }
break;
} // while 
MM_ERR(MMPR3(i,start,r.size()))
if (start==r.size()) 
{
MM_ERR(" no mesh ")
return BAD;
}
i=start;
const Line & l=r[0+start];
const IdxTy len=l.size();
if (len!=3)
{
MM_ERR(" first line should be n_v n_t n_e but len is "<<MMPR(len))
if ( len<3) return BAD; 
} // len
m_nv=myatoi(l[0]);
m_nt=myatoi(l[1]);
m_ne=myatoi(l[2]);
} // scoping 
IdxTy sum=m_nv+m_nt+m_ne+start;
if (sz!=(sum+1))
{
MM_ERR(" mesh file size is wrong "<<MMPR4(sz,m_nv,m_nt,m_ne)<<MMPR2(start,sum))

} // sum 
else 
MM_ERR(" mesh file sums ok  "<<MMPR4(sz,m_nv,m_nt,m_ne)<<MMPR(sum))

// in reality the last fields may have defaults allowing them to be read
// with short lines.. 
IdxTy nend=1+m_nv+start;
for(i=1+start; i<nend; ++i)
{
const Line & l = r[i];
if (l.size()!=3)
{
MM_ERR(" vertex line size wrong "<<MMPR2(i,l.size()))
if (l.size()<2) return BAD; 
}
m_verticies.push_back(vertex_type(l));
} // vertexes 
nend+=m_nt;
while (i<nend)
{
const Line & l = r[i];
if (l.size()!=4)
{
MM_ERR(" triangel line size wrong "<<MMPR2(i,l.size()))
if (l.size()<3) return BAD; 
} // size 

m_tri.push_back(tri_type(l));

++i;
} // while 
nend+=m_ne;
while (i<nend)
{
const Line & l = r[i];
if (l.size()!=3)
{
MM_ERR(" edgeline size wrong "<<MMPR2(i,l.size()))
if (l.size()<2) return BAD; 
} // size 

m_edges.push_back(edge_type(l));

++i;
} // while
if (total_area)
{
D area=0;
MM_LOOP(ii,m_tri)
{
area+=(*ii).area(*this); 
//	{ return area(m_verticies[p1-1],m_verticies[p2-1],m_verticies[p3-1]); } 
} // ii 
// TODO need w*h ... 
MM_ERR(MMPR2(area,(area-int(area+.5))))
} // total_area
if (write_R) { WriteRTri("xxx.mesh","",0); } 
return 0; 
}// LoadFFMesh 


IdxTy WriteRTri(const StrTy & fn, const StrTy & sv, const IdxTy flags)
{
std::ofstream os(fn);
return WriteRTri(os,sv,flags); 
} // Write
IdxTy WriteRTri(Os  & os, const StrTy & sv, const IdxTy flags)
{
const bool no_prec=Bit(flags,0);
if (!no_prec) {os<<std::setprecision(12); } 
IdxTy i=0; 
MM_LOOP(ii,m_tri) 
{ 
++i;
const vertex_type & v1=m_verticies[(*ii).p1-1];
const vertex_type & v2=m_verticies[(*ii).p2-1];
const vertex_type & v3=m_verticies[(*ii).p3-1];
os<<i<<" "<<v1.x<<" "<<v2.x<<" "<<v3.x
<<" "<<v1.y<<" "<<v2.y<<" "<<v3.y<<CRLF;
// (*ii).write(os); os<<CRLF; 
} // ii  

return 0; 
} // WriteR
void GetMesh(WORMBlob & wb, const IdxTy flags) const
{
//const bool no_prec=Bit(flags,0);
//if (!no_prec) {os<<std::setprecision(12); } 
const bool include_reg=false; // Bit(flags,0);
const IdxTy szet = include_reg?7:6;
wb.pitch(szet);
wb.capacity(szet*m_tri.size());
IdxTy i=0; 
MM_LOOP(ii,m_tri) 
{ 
++i;
const auto & t=(*ii);
const vertex_type & v1=m_verticies[t.p1-1];
const vertex_type & v2=m_verticies[t.p2-1];
const vertex_type & v3=m_verticies[t.p3-1];
//os<<i<<" "<<v1.x<<" "<<v2.x<<" "<<v3.x
wb.push_back(v1.x); wb.push_back(v1.y);
wb.push_back(v2.x); wb.push_back(v2.y);
wb.push_back(v3.x); wb.push_back(v3.y);
if (include_reg) wb.push_back(t.reg);
}
} // GetMesh


IdxTy Write(const StrTy & fn, const StrTy & sv, const IdxTy flags)
{
std::ofstream os(fn);
return Write(os,sv,flags); 
} // Write
IdxTy Write(Os  & os, const StrTy & sv, const IdxTy flags)
{
const bool no_prec=Bit(flags,0);
if (!no_prec) {os<<std::setprecision(12); } 

os<<m_nv<<" "<<m_nt<<" "<<m_ne<<CRLF;
MM_LOOP(ii,m_verticies) {  (*ii).write(os); os<<CRLF; } 
MM_LOOP(ii,m_tri) {  (*ii).write(os); os<<CRLF; } 
MM_LOOP(ii,m_edges) {  (*ii).write(os); os<<CRLF; } 
return 0;
} // Write

IdxTy ReadDof(const StrTy & dof, const StrTy & fn, const IdxTy flags)
{

m_dofs[dof].m_name=dof;
m_dofs[dof].m_mesh=this;
m_dofs[dof].load(fn,flags);
MM_ERR(MMPR4(__FUNCTION__,dof,fn,m_dofs[dof].size()))
return 0; 
} // ReadDof 

IdxTy WriteDof(const StrTy & dof, const StrTy & fn, const IdxTy flags)
{

//m_dofs[dof].m_name=dof;
//m_dofs[dof].m_mesh=this;
m_dofs[dof].save(fn,flags);
MM_ERR(MMPR4(__FUNCTION__,dof,fn,m_dofs[dof].size())<<MMPR(flags) )
return 0; 
} // WriteDof 


// must exist 
Aam& GetAdoptMatrix(const StrTy & oldmesh, Myt * tholdp, const IdxTy flags)
{
auto ii=m_adopts.find(oldmesh);
if (ii==m_adopts.end()) 
	{ 
if (!tholdp) throw " no existin adop matrix "; 
MakeAam(m_adopts[oldmesh], *tholdp,flags); ii=m_adopts.find(oldmesh); } 
return (*ii).second;
} // GetAdoptMatrix
IdxTy AdoptDofs( const StrTy & oldmesh, Myt & thold, const IdxTy flags)
{
IdxTy rc=0;
MM_LOOP(ii,thold.m_dofs)
{
rc+=AdoptDof((*ii).first,oldmesh,thold,flags);
} // ii 
return rc;
} // AdoptDofs

// TODO m_adopts can become stale, need time stamps or
// similar on source and est Aam. 
IdxTy AdoptDof(const StrTy & dof, const StrTy & oldmesh, Myt & thold, const IdxTy flags)
{ IdxTy rc=0;
Aam & aam=GetAdoptMatrix(oldmesh,&thold,flags); ;
const dof_type & s=thold.get_dof(dof);
dof_type & d=get_dof_rw(dof);
MM_ERR(MMPR3(d.size(),s.size(),aam.dump()))
d=aam(s);
d.m_mesh=this;
return rc; 
}  // AdoptDof
// index all the triangles in each hood
typedef std::set<IdxTy> TriList;
typedef std::map<IdxTy, TriList> TriIdx; 
// that has to index the old mesh... 
// the trianagle number is zero based array index. 
void IndexTriangles(TriIdx & ti, const MeshHood & mh )
{
MM_SZ_LOOP(i,m_tri,szt)
{
const tri_type & t=m_tri[i];  
// the set of all hoods LIKELY to include a piece of this triangle
// ideally it is exact but ok if too includsive.
std::set<IdxTy> hoods;
const auto & p1=m_verticies[t.p1-1];
const auto & p2=m_verticies[t.p2-1];
const auto & p3=m_verticies[t.p3-1];
// add the hoods containing a piece of each seg
mh.isin(hoods, p1.x,p1.y,p2.x,p2.y,0);
mh.isin(hoods, p1.x,p1.y,p3.x,p3.y,0);
mh.isin(hoods, p3.x,p3.y,p2.x,p2.y,0);
// get any empty area
mh.fill(hoods);
// add this triangele to each hood that it may occupy  
if (false) MM_ERR(MMPR2(i,hoods.size()))
MM_LOOP(ii,hoods) { ti[*ii].insert(i); } 
//asd
} // i 

} // IndexTriangles
// TODO allow matrix to go from a trail too
// this is operating on the current mesh (*this) and mh
// should be made already... 
template <class Tv> 
void MakeAam(Aam & aam, const_vector_iterator<Tv,Tr> &  begin, const_vector_iterator<Tv,Tr> &  end  , MeshHood & mh, const IdxTy flags)
{
TriIdx ti;
IndexTriangles(ti,mh);
const IdxTy n=end-begin;
aam.resize(n);
while (begin!=end)
{
const auto & p=(*begin).second;
const IdxTy loc=mh.hood(p.x,p.y);
if (!false) { MM_ERR(MMPR(int(end))<<MMPR4(int(begin),loc,p.x,p.y)) } 
const TriList & tl=ti[loc];
IdxTy tidx=BAD;
MM_LOOP(ii,tl)
{
const IdxTy i=(*ii);
//const bool prab=true; // (i>8000)&&(i<9500);
//if (prab) MM_ERR(MMPR(i))
const tri_type & t=m_tri[i];
//if (t.contains(p.x,p.y,m_verticies,prab?2:0)) { tidx=i; break; } 
// flag is now only for printing has no effect
// even now that the logic is ommented out 
if (t.contains(p.x,p.y,m_verticies,2+1)) { tidx=i; break; } 
} // ii 
// 
if (int(tidx)==BAD)
{
MM_ERR(" no triangle will die nw  "<<MMPR2(int(begin),m_tri.size())<<MMPR4(p.x,p.y,loc,tl.size()))
MM_DIE(" here ")
tidx=FindTriangle(p,loc,tl,ti);
}
const tri_type & t=m_tri[tidx];
// these were already computed in the contains doh 
D a,b;
// a 1, b 2, delta p3
t.coords(a,b,p.x,p.y,m_verticies,flags);
aam.add(begin,t.p1-1,a);
aam.add(begin,t.p2-1,b);
aam.add(begin,t.p3-1,1.0-a-b);
++begin;
} // begin 

} // MakeAam vector iterator
///////////////////////////////////////////////
template <class Tp,class Tl, class Ti  > IdxTy FindTriangle(Tp & p, const IdxTy loc, 
const Tl & tl, const Ti & ti )  const 
{
IdxTy tidx=BAD;
MM_SZ_LOOP(j,m_tri,szcert)
{
const tri_type & t=m_tri[j];
if (t.contains(p.x,p.y,m_verticies,0)) { tidx=j; break; } 
} // j 
if ( (tidx)==IdxTy(BAD)) MM_ERR( " exhaiustve search fails ")
else
{
MM_ERR(" point is in hood "<<MMPR2(loc,tidx))
{Ss ss; MM_LOOP(ii,tl) { ss<<(*ii)<<" "; }
MM_ERR(" containing tiangles "<<MMPR(ss.str())) }

{ Ss ss; MM_LOOP(ii,ti) 
{ 
const IdxTy cnt=(*ii).second.count(tidx);
if (cnt) ss<<"("<<(*ii).first<<"."<<cnt<<")"; 
} // ii 
MM_ERR(" triangl "<<MMPR2(tidx,m_tri[tidx].dump(m_verticies,0))<<"  is  in hoods "<<MMPR(ss.str()))
} // Ss 

} // tidx found 
return tidx;
} // FindTriangle

///////////////////////////////////////////////
void MakeAam(Aam & aam, Myt & thold, const IdxTy flags)
{
// index the input or old mesh and put into an affine grid
MeshHood mh;
mh.infer(thold.m_verticies,0);
mh.add(thold.m_verticies,0,0);
// TODO these should be cached.... 
TriIdx ti;
thold.IndexTriangles(ti,mh);
// needs to know how bit the output is
const IdxTy n=m_verticies.size();
aam.resize(n);
// either use the mesh or just find closest points lol.
// for each vertex, find a relevant set in the input mesh
// and coefficients... 
for(IdxTy i=0; i<n; ++i)
{
const vertex_type & p=m_verticies[i];
// find the element or nearest 3 nodes using mh restricted search  lol.
const IdxTy loc=mh.hood(p.x,p.y);
if (false) { MM_ERR(MMPR(n)<<MMPR4(i,loc,p.x,p.y)) } 
// find all triangles in that hood
const TriList & tl=ti[loc];
IdxTy tidx=BAD;
MM_LOOP(ii,tl)
{
const IdxTy i=(*ii);
if (false)  MM_ERR(MMPR(i))
const tri_type & t=thold.m_tri[i];
if (t.contains(p.x,p.y,thold.m_verticies,0)) { tidx=i; break; } 
} // ii 
// 
if (int(tidx)==BAD)
{
MM_ERR(" no triangle "<<MMPR4(p.x,p.y,loc,tl.size()))
MM_DIE(" wtf ")
// find 3 closest points or exhasutive triangle search....
MM_SZ_LOOP(j,thold.m_tri,szcert)
{
const tri_type & t=thold.m_tri[j];
if (t.contains(p.x,p.y,thold.m_verticies,0)) { tidx=j; break; } 
} // j 
if ( (tidx)==IdxTy(BAD)) MM_ERR( " exhaiustve search fails ")
else
{
MM_ERR(" point is in hood "<<MMPR2(loc,tidx))
{Ss ss; MM_LOOP(ii,tl) { ss<<(*ii)<<" "; }
MM_ERR(" containing tiangles "<<MMPR(ss.str())) }

{ Ss ss; MM_LOOP(ii,ti) 
{ 
const IdxTy cnt=(*ii).second.count(tidx);
if (cnt) ss<<"("<<(*ii).first<<"."<<cnt<<")"; 
} // ii 
MM_ERR(" triangl "<<MMPR2(tidx,thold.m_tri[tidx].dump(thold.m_verticies,0))<<"  is  in hoods "<<MMPR(ss.str()))
} // Ss 

} // tidx found 

// find 3 close points

}// tidx==BAD 
const tri_type & t=thold.m_tri[tidx];
// these were already computed in the contains doh 
D a,b;
// a 1, b 2, delta p3
t.coords(a,b,p.x,p.y,thold.m_verticies,flags);
aam.add(i,t.p1-1,a);
aam.add(i,t.p2-1,b);
aam.add(i,t.p3-1,1.0-a-b);

} // i 
 
} // MakeAam




template<class Ti> IdxTy  IsoSeg(Ti & segidx, trail_type &trail, const dof_type & dof, const D & v, const IdxTy p1, const IdxTy p2)
{
IdxTy exacts=0; 
if ( p1>dof.m_vals.size()) {MM_ERR(" bad elements "<<MMPR2(p1,dof.m_vals.size())) }
if ( p2>dof.m_vals.size()){  MM_ERR(" bad elements pt2  "<<MMPR2(p2,dof.m_vals.size())) }
IdxTy rv=0;
typedef typename Ti::key_type Key;
Key k1=Key(p1,p2);
// FIXME this just doubled nodes to be eliminated... 
//if (segidx.find(k1)!=segidx.end()) return ~0;
// Is this faster to just gate out dups later? 
Key k2=Key(p2,p1);
const D v1=dof.m_vals[p1-1];
const D v2=dof.m_vals[p2-1];
// the first one is smaller now... 
IdxTy p1o=p1, p2o=p2; D v1o=v1, v2o=v2;
if (v1>v2) { v1o=v2; v2o=v1; p1o=p2; p2o=p1; } 
if ( (v>v1)&&(v>v2)) rv=1;
else if ( (v<v1)&&(v<v2)) rv=1;
else if ( ((v>v1)&&(v<v2))|| ((v<v1)&&(v>v2)))
{
 const D a=(v-v1o)/(v2o-v1o);
//MM_ERR(MMPR4(a,v,v1,v2))
//V vnew;
seg_type vnew;
// TODO ordering was added later, need to fix code to
// do this from the beginning and handle equality better
const V & va=m_verticies[p1o-1];
const V & vb=m_verticies[p2o-1];
vnew.x= va.x+ (vb.x-va.x)*a;
vnew.y= va.y+ (vb.y-va.y)*a;
vnew.a=a;
vnew.p1=p1o;
vnew.p2=p2o;
const D dn=va.dist(vb);
vnew.grad=(v1o-v2o)/dn;
//MM_ERR(MMPR4(va.x,vb.x,va.y,vb.y))
//MM_ERR(MMPR4(vnew.x,vnew.y,a,v))
trail.push_back(vnew);
rv=2;
}
else
{
// TODO the seen map needs to get the point not the seg.... 
// TODO apparently this takes a seg but calls ctor from vertex 
// convention has been that unused point is zero which is 
// possible with unity base index. 
if (v1==v){  trail.push_back(m_verticies[p1-1]); trail.back().p1=p1; ++exacts; } 
if (v2==v) { trail.push_back(m_verticies[p2-1]); trail.back().p2=p2; ++exacts; } 
rv=3;
} // add both 
segidx[k1]=rv;
segidx[k2]=rv;
if (exacts) MM_ERR(" exacts "<<MMPR(exacts))
return rv; 
}// IsoSeg
// TODO this needs to orient so etching knows which ay to go lol 
IdxTy IsoTrail(trail_type & trail, const StrTy & dofn, const D & v, const IdxTy flags) //const
{
const dof_type & dof=m_dofs[dofn];
// index segments
typedef std::pair<IdxTy,IdxTy> Key;
std::map< Key, IdxTy> segidx;
IdxTy ti=0;
MM_LOOP(ii,m_tri)
{
const tri_type & t=(*ii);
const IdxTy szi=trail.size();
// p1, p2, p3 could just compute but then lots of redundant
// segs get tested.. although easier to delete dups as
// in theory they should interpolate identically... 
 IsoSeg(segidx, trail,  dof, v,t.p1, t.p2);
 IsoSeg(segidx, trail,  dof, v,t.p2, t.p3);
 IsoSeg(segidx, trail,  dof, v,t.p3, t.p1);
const IdxTy szf=trail.size();
for(IdxTy i=szi; i<szf; ++i){trail[i].t=ti; } // t is zero based, 
// if two points were added, both can have a ds term... 
if ((szf-szi)==2)
{
trail[szi].ds(trail[szi+1]);
trail[szi+1].ds(trail[szi]);

} // 
++ti;
} // ii 
MM_ERR(MMPR4(__FUNCTION__, v,dofn,trail.size()))
trail_type cleaned;
trail.m_mesh=this;
trail.sorted(cleaned,1);
trail=cleaned;
MM_ERR("cleaned "<< MMPR4(__FUNCTION__, v,dofn,trail.size()))
// now to order. This needs the triangle list to know whoich ones
// touch. gg


std::ofstream os("xxx.trail");
IdxTy i=0;
MM_LOOP(ii,trail)
{
os<<i<<" "<<(*ii).x<<" "<<(*ii).y<<CRLF;
++i;
}

return 0;
} // IsoTrail

// FIXME doh put this somwhere lol 
static int myatoi(const StrTy & s )  { return Canned::myatoi(s.c_str()); }
static int myatoi(const char * c)  { return Canned::myatoi(c); }

void Clear()
{
m_verticies.clear();
m_tri.clear();
m_edges.clear();
m_dofs.clear();
m_trails.clear();
} // Clear
IdxTy Size(const IdxTy n) const 
{ 
switch (n)
{
case 0:{ return m_verticies.size(); } 
case 1:{ return m_tri.size(); } 
case 2:{ return m_edges.size(); } 
case 3:{ return m_dofs.size(); } 
case 4:{ return m_trails.size(); } 
case 5:{ return m_adopts.size(); } 
default: return ~0;
} // switch 
return  ~0; 
} // Size

public: // objects need to be friends 
// MEMBERS
IdxTy m_nv, m_nt,m_ne;
Verticies m_verticies;
Triangles m_tri;
Edges m_edges;
Dofs m_dofs;
Trails m_trails;
AdoptMap m_adopts;
}; // mjm_ff_mesh

//////////////////////////////////////////////

template <class Tr>
class mjm_ff_mesh_map : public std::map<typename Tr::StrTy, mjm_ff_mesh< Tr > >  
{
 typedef mjm_ff_mesh_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_ff_mesh< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
typedef OsTy Os;
public:
mjm_ff_mesh_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
static bool Bit(const IdxTy f, const IdxTy b)   { return  ((f>>b)&1)!=0; }
private:
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_ff_mesh_map




////////////////////////////////////////////
#ifdef  TEST_MJM_FF_MESH
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_ff_mesh <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_FF_MESH "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_ff_mesh<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//IdxTy read_ff_mesh(const StrTy & fn, const StrTy & sv, const IdxTy flags)
else if (cmd=="load") { MM_ERR(x.read_ff_mesh(cip.p1,cip.p2,0)) }
else if (cmd=="save") { MM_ERR(x.write(cip.p1,cip.p2,0)) }
else if (cmd=="dof") { MM_ERR(" readunbg dof "<< x.read_dof(cip.p1,cip.p2,0)) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_FF_MESH_H__ 
