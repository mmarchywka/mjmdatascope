#ifndef MJM_STRING_KVP_H__
#define MJM_STRING_KVP_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"

// throw in params here 
#include "mjm_collections.h"
#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Wed Feb 15 08:35:42 EST 2023
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_string_kvp   
// g++  -Wall -std=gnu++11 -DTEST_MJM_STRING_KVP -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_string_kvp.h  -o mjm_string_kvp.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_string_kvp("mjm_string_kvp"
, "  ");

template <class Tr>
class mjm_string_kvp 
{
 typedef mjm_string_kvp Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line ;

typedef std::map<StrTy, StrTy> Map;
typedef std::pair<StrTy, StrTy> Pair;
typedef std::vector<Pair> Vector;

public:
mjm_string_kvp() {}
~mjm_string_kvp() {}

IdxTy parse(Map & m, const StrTy & s, const IdxTy flags=0)
{ return Parse(m,s,flags); } 
IdxTy parse(Vector & v,Map & m, const StrTy & s, const IdxTy flags=0)
{ return Parse(v,m,s,flags); } 



IdxTy parse(Ragged & m, const StrTy & s, const IdxTy flags=0)
{ return Parse(m,s,flags); } 


StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
IdxTy Parse(Ragged & d, const StrTy & s, const IdxTy flags=0)
{
IdxTy rc=9;
StrTy k="";
StrTy v="";
const IdxTy len=s.length();
char cc[len+1];
memcpy(cc,s.c_str(),len);
cc[len]=0;
IdxTy pc=0;
//IdxTy kz=0;
IdxTy vz=0;
Line l;
while (pc<len)
{
do
{
char c=cc[pc];
//if (c=='=') { cc[pc]=0; vz=pc+1; break; } 
if (c==' ') { cc[pc]=0;l.push_back(StrTy(cc+vz));  vz=pc+1;  break; } 
//if (c==';') { cc[pc]=0; m[StrTy(cc+kz)]+=StrTy(cc+vz); kz=pc+1;  break; } 
if (c==';') { cc[pc]=0; l.push_back(StrTy(cc+vz)); vz=pc+1;  break; } 
} while (false) ; 

++pc;
} // pc 
if (vz!=pc) { l.push_back(StrTy(cc+vz));} 
if (l.size()) d.add(l); 
//MM_LOOP(ii,m) { MM_ERR(MMPR2((*ii).first,(*ii).second)) } // ii 
MM_ERR(MMPR(d.size()))
return rc; 
} // Parse


IdxTy Parse(Map & m, const StrTy & s, const IdxTy flags=0)
{
Vector v;
return Parse(v,m,s,flags); 
}
IdxTy Parse(Vector & _v,Map & m, const StrTy & s, const IdxTy flags=0)
{
const bool do_dump=Bit(flags,0);
IdxTy rc=9;
StrTy k="";
StrTy v="";
const IdxTy len=s.length();
char cc[len+1];
memcpy(cc,s.c_str(),len);
cc[len]=0;
IdxTy pc=0;
IdxTy kz=0;
IdxTy vz=0;
while (pc<len)
{
do
{
char c=cc[pc];
if (c=='=') { cc[pc]=0; vz=pc+1; break; } 
if (c==';') { cc[pc]=0; 
StrTy kk=StrTy(cc+kz);
StrTy vv=StrTy(cc+vz);
//m[StrTy(cc+kz)]+=StrTy(cc+vz); 
m[kk]+=StrTy(vv); 
_v.push_back(Pair(kk,vv));
kz=pc+1;  break; } 
} while (false) ; 

++pc;
} // pc 
if (vz!=pc) { 
//m[StrTy(cc+kz)]+=StrTy(cc+vz);
StrTy kk=StrTy(cc+kz);
StrTy vv=StrTy(cc+vz);
//m[StrTy(cc+kz)]+=StrTy(cc+vz); 
m[kk]+=StrTy(vv); 
_v.push_back(Pair(kk,vv));
} 
if (vz<=kz) { 
//m[StrTy("")]+=StrTy(cc+vz);
StrTy kk=StrTy("");
StrTy vv=StrTy(cc+vz);
m[kk]+=StrTy(vv); 
_v.push_back(Pair(kk,vv));
} 
if ( do_dump) { MM_LOOP(ii,m) { MM_ERR(MMPR2((*ii).first,(*ii).second))}}// ii 
return rc; 
} // Parse

///////////////////////////////
// MEMBERS



}; // mjm_string_kvp

//////////////////////////////////////////////

template <class Tr>
class mjm_string_kvp_map : public std::map<typename Tr::StrTy, mjm_string_kvp< Tr > >  
{
 typedef mjm_string_kvp_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_string_kvp< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_string_kvp_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_string_kvp_map


template <class Tr>
class mjm_string_base_params
{

 typedef mjm_string_base_params Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

typedef mjm_string_kvp<Tr> StrKvp;

typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line ;

typedef std::map<StrTy, StrTy> Map;
typedef std::pair<StrTy, StrTy> Pair;
typedef std::vector<Pair> Vector;

/*
typedef std::string StrTy;
typedef std::stringstream Ss;
typedef unsigned int IdxTy;
typedef double D;
*/


static int myatoi(const char * c)  { return ::strtol(c,0,0); }
static int myatoi(const StrTy & s)  { return myatoi(s.c_str()); }

public:

mjm_string_base_params(const StrTy & s) :m_s(s) {Init();}
void add(Ragged& d, const D & x, const D & y, const IdxTy flags) const
{Add(d,x,y,flags); }
IdxTy vsize() const { return m_vector.size(); }
const Pair & kvp(const IdxTy i ) const { return m_vector[i]; } 
bool has(const StrTy  & n ) { return m_map.find(n)!=m_map.end(); } 
const IdxTy  get(IdxTy  & d,const StrTy & n ) const { 
IdxTy rc=1;
const auto  ii=(m_map.find(n)); 
if (ii==m_map.end()) { rc=0; }//  return 0;
// want to allow hex etc too myatoi
//d=atoi((*ii).second.c_str());
else d=myatoi((*ii).second.c_str());
if ((m_flags&1)!=0) {MM_ERR(MMPR3(rc,d,n)) } 
return rc;
}
const IdxTy  get(int  & d,const StrTy & n ) const { 
IdxTy rc=1;
const auto  ii=(m_map.find(n)); 
if (ii==m_map.end()) { rc=0; }//  return 0;
// want to allow hex etc too myatoi
//d=atoi((*ii).second.c_str());
else d=myatoi((*ii).second.c_str());
if ((m_flags&1)!=0) {MM_ERR(MMPR3(rc,d,n)) } 
return rc;
}
const IdxTy  get(bool  & d,const StrTy & n ) const { 
IdxTy rc=1;
const auto  ii=(m_map.find(n)); 
if (ii==m_map.end()) { rc=0; }//  return 0;
// want to allow hex etc too myatoi
//d=atoi((*ii).second.c_str());
else
{
 const StrTy & v=((*ii).second.c_str());
if (v=="1") { d=true; }
else if (v=="0") { d=false; }
else if (v=="true") { d=true; }
else if (v=="false") { d=false; }
else if (v=="TRUE") { d=true; }
else if (v=="FA:SE") { d=false; }
else if (v=="+") { d=true; }
else if (v=="-") { d=false; }
else if (v=="yes") { d=true; }
else if (v=="no") { d=false; }
else
{
MM_ERR(" bad bool "<<MMPR2(n,v))
return ~0; 
}
} // found 
if ((m_flags&1)!=0) {MM_ERR(MMPR3(rc,d,n)) } 
return rc;
}




const IdxTy  get(D & d,const StrTy & n ) const { 
IdxTy rc=1;
const auto  ii=(m_map.find(n)); 
if (ii==m_map.end()) { rc=0;} // return 0;
else d=atof((*ii).second.c_str());
if ((m_flags&1)!=0) {MM_ERR(MMPR3(rc,d,n)) } 
return rc;
}
const IdxTy  get(StrTy & d,const StrTy & n ) const { 
IdxTy rc=1;
const auto ii=(m_map.find(n)); 
if (ii==m_map.end()) { rc=0; } //  return 0;
else d=(*ii).second;
if ((m_flags&1)!=0) {MM_ERR(MMPR3(rc,d,n)) } 
return rc;
} 
//const StrTy& get(const StrTy & n )const{ return (*(m_map.find(n))).second;} 
const StrTy get(const StrTy & n ) const { 
//const auto ii= (*(m_map.find(n))).second; 
const auto ii= m_map.find(n); 
if (ii==m_map.end()) return StrTy();
return (*ii).second;
} // get  
void Init()
{
StrKvp kvp;
kvp.parse(m_vector,m_map,m_s);
m_nprec=18;
m_flags=0;
// note these may confluct with user fields... 
get(m_nprec,"nprec"); 
get(m_flags,"m_flags"); 
}
StrTy dump() const
{
Ss ss;
MM_LOOP(ii,m_map)
{
const StrTy k=(*ii).first;
const StrTy v=(*ii).second;
ss<<MMPR2(k,v)<<" ";
} // ii 
return ss.str();
} // dump

void Add(Ragged& d, const D & x, const D & y, const IdxTy flags) const
{
Line l;
{Ss ss; ss<<std::setprecision(m_nprec); ss<<x; l.push_back(ss.str()); } 
{Ss ss; ss<<std::setprecision(m_nprec); ss<<y; l.push_back(ss.str()); } 
d.add(l);
} // Add

private:
Map m_map;
Vector m_vector;
StrTy m_s;
IdxTy m_nprec;
IdxTy m_flags;
}; // _params




////////////////////////////////////////////
#ifdef  TEST_MJM_STRING_KVP
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_string_kvp <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_STRING_KVP "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_string_kvp<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_STRING_KVP_H__ 

