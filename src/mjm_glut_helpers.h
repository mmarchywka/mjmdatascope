#ifndef MJM_GLUT_HELPERS_H__
#define MJM_GLUT_HELPERS_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
// TODO FIXME should use template move this crap out 
#include "mjm_hot_zones.h"


#include "mjm_collections.h"

#include "mjm_strings.h"
#include "mjm_string_kvp.h"


#include <freeglut.h>

#include "mjm_glut_elements.h"
#include "mjm_worm_blob.h"


#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


// Fri Mar 24 04:11:15 EDT 2023
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_glut_helpers   
// g++  -Wall -std=gnu++11 -DTEST_MJM_GLUT_HELPERS -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_glut_helpers.h  -o mjm_glut_helpers.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_glut_helpers("mjm_glut_helpers"
, "  ");

template <class Tr>
class mjm_glut_helpers 
{
 typedef mjm_glut_helpers Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
// traits? 
enum {BAD=~0};


typedef mjm_string_base_params<Tr> BaseParams;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line; 
typedef mjm_worm_blob<Tr,D> WORMBlob;
typedef mjm_glut_elements<Tr> Elements;
typedef  typename Elements::Element Element ;


typedef GLfloat Gf ;


typedef std::map<StrTy,Elements> Scenes;

// accumlate hot zones with actions etc. 
typedef mjm_hot_zones<Tr>  HotZones;
class _draw_info
{

public:
typedef HotZones hot_type;
hot_type m_hz;


}; // _draw_info
class _key_info
{

}; // _key_info

class _ptr_info
{

}; // _ptr_info



class _view
{
typedef Gf G;
typedef std::vector<G> Vec;
public:
_view() {Init(); }
void reset() { Init(); } 
const IdxTy vidx() const { return m_vidx; }
void  vidx(int d )  { int x=m_vidx+d; if (x<0) x=0; m_vidx=x;  }
void mov(const D dx, const D dy,const D dz)
{
m_c[0]+=dx;
m_c[1]+=dy;
m_c[2]+=dz;

}
void rot(const D dt, const D dp)
{
theta+=dt;
phi+=dp;
m_focus[0]=sin(theta)*cos(phi);
m_focus[1]=sin(theta)*sin(phi);
m_focus[2]=cos(theta);

}
void Init()
{
m_vidx=5;
m_c.resize(3);
m_scale.resize(3);
m_scale[0]=.1; // .1;
m_scale[1]=.1; // .1;
m_scale[2]=10; // 10;
m_focus.resize(3);
m_focus[0]=0;
m_focus[1]=0;
m_focus[2]=1;
m_up.resize(3);
m_up[0]=0; m_up[1]=0; m_up[2]=1;
theta=0;
phi=0;
//distance=-1;
distance=1;
//g_lightPos = { 10, 10, -100, 1 };
}
StrTy dump(const IdxTy flags=0) const
{
Ss ss;
ss<<MMPR3(m_c[0],m_c[1],m_c[2]);
ss<<MMPR3(m_focus[0],m_focus[1],m_focus[2]);
ss<<MMPR3(m_scale[0],m_scale[1],m_scale[2]);
ss<<MMPR3(m_up[0],m_up[1],m_up[2]);
ss<<MMPR4(m_vidx,theta,phi,distance);
return ss.str();
}
// center point, size, up
Vec m_c,m_focus, m_scale,  m_up;
IdxTy m_vidx;
D theta,phi;
Gf distance;
//float g_lightPos[4] = { 10, 10, -100, 1 };
Gf g_lightPos[4] = { 10, 10, -100, 1 };


}; // _view




#if 0
// obsolelet 
class _element
{
typedef D Loc;
typedef D V;
typedef std::vector<V> Vals;
typedef std::vector<Loc> Point;
typedef std::pair<Point,Vals> Pv;
typedef std::vector<Pv> Vx;
public:
void add(const Line & l , const IdxTy flags)
{
const IdxTy sz=l.size();
if (sz<8)
{
MM_ERR(" line too short to add "<<MMPR(sz))
MM_LOOP(ii,l){ MM_ERR(MMPR((*ii))) }
return;
}
Loc x=atof(l[1].c_str());
Loc y=atof(l[2].c_str());
Point loc;
loc.push_back(x);
loc.push_back(y);
Vals v;
for(IdxTy i=3; i<(sz-4); ++i) v.push_back(atof(l[i].c_str()));
m_vx.push_back(Pv(loc,v));
} // add

Vx m_vx;
}; // _element


#endif

class _color_desc
{

public:
_color_desc(): r(1),g(1),b(1) {}
template <class Tt> _color_desc(const Tt & t): r(t.r),g(t.g),b(t.b) {}
_color_desc( const D& _r, const D& _g,const D& _b) 
	: r(_r),g(_g),b(_b) {}
D r,g,b;
}; // _color_desc

typedef _color_desc color_type;

class _point_desc
{
public:
// bit 0 : 2d face user. 
//_point_desc(): x(0),y(0),z(0),r(1),g(1),b(1),sz(24),flags(0) {}
_point_desc(): x(0),y(0),z(0),sz(24),flags(0) {}
_point_desc( const D& _x, const D& _y,const color_type & _r=color_type())
//: x(_x),y(_y),z(0),r(1),g(1),b(1),sz(24),flags(1) {}
: x(_x),y(_y),z(0),rgb(_r),sz(24),flags(1) {}
_point_desc( const D& _x, const D& _y,const D& _z,const color_type & _r=color_type())
//: x(_x),y(_y),z(_z),r(1),g(1),b(1),sz(24),flags(1) {}
: x(_x),y(_y),z(_z),rgb(_r),sz(24),flags(1) {}
//StrTy m_s;
D x,y,z;
color_type rgb;
//D r,g,b;
D sz;
IdxTy flags;
}; // _point_desc


class _text_desc : public _point_desc
{
typedef _point_desc Super;
public:
_text_desc() {}
_text_desc(const StrTy & s,  const D& _x, const D& _y)
: m_s(s),Super(_x,_y){}
StrTy m_s;

}; // _text_desc


class _seg_desc : public std::vector<_point_desc>
{

}; // _seg_desc
// does not accomodate draw order/Z-buffer etc
// although each is a 3D point and gl should
// do z processing huh? 
class _junk_bin
{

public:
_junk_bin(): m_code(0),m_szlim(10) {}
void add_point(const D & x, const D & y, const D & z=0)
{ _point_desc p(x,y,z); m_points.push_back(p); } 

void add_seg(const IdxTy s, const D & x, const D & y, const D & z, const
color_type & ct)
{ _point_desc p(x,y,z,ct); 
if (s>=m_segs.size()) m_segs.resize(s+1); 
m_segs[s].push_back(p); } 

void add_params( const Line & l, const IdxTy ii,const IdxTy len )
{
for(IdxTy i=ii; i<(len-1); i+=2)
{
m_params[l[i]]=l[i+1];
} // i 

} // add_names
void add_names( const Line & l, const IdxTy ii, const IdxTy len )
{
//const IdxTy ii=2;
for(IdxTy i=ii; i<len; ++i)
{
Ss ss; ss<<"name"<<(i-ii);
m_params[ss.str()]=l[i];
} // i 

}// add_params




typedef std::vector<_point_desc> PointVec;
typedef std::vector<_seg_desc> SegVec;
typedef std::vector<_text_desc> StrVec;
typedef std::map<StrTy, StrTy> Parameters;
void clear() { m_strings.clear(); m_points.clear(); m_segs.clear();
}
StrVec m_strings;
PointVec m_points;
SegVec m_segs;
IdxTy m_code;
IdxTy m_szlim;
Parameters m_params;
}; // _junk_bin
typedef _junk_bin junk_bin_type;

private:
mjm_glut_helpers() {}
~mjm_glut_helpers() {}



// these things need mutexes.... 
public:
// TYPEDEFS
typedef _draw_info draw_info_t;
typedef _ptr_info ptr_info_t;
typedef _key_info key_info_t;
typedef _view view_info_t;
typedef _junk_bin junk_bin_t;
typedef color_type color_t;
// API


typedef GLdouble Gc;
static IdxTy unproject(Gc & x, Gc & y, Gc & z, const Gc xin, const Gc yin)
{ return Unproject(x, y, z,  xin,  yin); } 


static IdxTy start_view(const view_info_t & v) 
{ return StartView(v); } 
static IdxTy start_view_zed(const IdxTy flags=0) { return StartViewZed( flags) ; }
static IdxTy display(const junk_bin_t & bin, const view_info_t & view, const IdxTy flags)
{ return Display(bin,view,flags); } 
static IdxTy draw_quad_elements
(const Elements   & el, const view_info_t & view, const IdxTy flags)
{ return  DrawQuadElements( el, view,  flags); } 
// https://stackoverflow.com/questions/538661/how-do-i-draw-text-with-glut-opengl-in-c
static void render_string(float x, float y,  const char* string, const color_t & rgb)
{ render_string(x,y,0,string,rgb); } 
static void render_string(float x, float y, void *font, const char* string, const color_t & rgb)
{  
  char *c;

  glColor3f(rgb.r, rgb.g, rgb.b); 
  glRasterPos2f(x, y);
//  glRasterPos3f(x, y,0.0);
if (font==0)
  glutBitmapString(GLUT_BITMAP_TIMES_ROMAN_24, (const unsigned char *)string);
  else glutBitmapString(font, (const unsigned char *) string);
}

//RenderString(0.0f, 0.0f, GLUT_BITMAP_TIMES_ROMAN_24, "Hello", RGB(1.0f, 0.0f, 0.0f));



// https://users.cs.jmu.edu/bernstdh/web/common/lectures/summary_opengl-text.php
static void begin_screen_coords(const view_info_t & v=view_info_t() ) {
  glMatrixMode(GL_PROJECTION);

  // Save the current projection matrix
  glPushMatrix();

  // Make the current matrix the identity matrix
  glLoadIdentity();
int w,h;
w=glutGet(GLUT_WINDOW_WIDTH);
h=glutGet(GLUT_WINDOW_HEIGHT);
  // Set the projection (to 2D orthographic)
  gluOrtho2D(0, w, 0, h);
//  gluOrtho2D(0, 1, 0, 1);

  glMatrixMode(GL_MODELVIEW);
  
// new code 
glPushMatrix();
  glLoadIdentity();
} // begin_screen_coords


static void draw_string(float x, float y, float z, const StrTy & s) {
draw_string(x,y,z,s.c_str()); } 
static void draw_string(float x, float y, float z, const char *string) {
  // Save the current matrix
  glPushMatrix();
  // Translate to the appropriate starting point
  glTranslatef(x, y, z);
  // Note: We could change the line width with glLineWidth()
  // Render the characters
void * currentFont=GLUT_STROKE_MONO_ROMAN;
  for (const char* c = string; *c != '\0'; c++) {
    glutStrokeCharacter(currentFont, *c);
  }
  // Another useful function
  //    int glutStrokeWidth(void *font, int character);

  // Retrieve the original matrix
  glPopMatrix();
} // draw_string



static void end_screen_coords(const view_info_t & v=view_info_t()) {

  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();
  glMatrixMode(GL_PROJECTION);

  // Restore the original projection matrix
  glPopMatrix();
  glMatrixMode(GL_MODELVIEW);

}




StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
static IdxTy Display(const junk_bin_t & bin, const view_info_t & view, const IdxTy flags)
{
MM_LOOP(ii,bin.m_strings) { DisplayString((*ii),view,flags); } 
MM_LOOP(ii,bin.m_segs) { DisplaySeg((*ii),view,flags); } 
MM_LOOP(ii,bin.m_points) { DisplayPoint((*ii),view,flags); } 
//StrVec m_strings;
//PointVec m_points;
//SegVec m_segs;

return 0; 
} // Display junk_bin_t

static IdxTy DisplaySeg(const _seg_desc & s, const view_info_t & view, const IdxTy flags)
{



return 0; 
} // DisplaySeg  


static IdxTy DisplayPoint(const _point_desc & p, const view_info_t & view, const IdxTy flags)
{

return 0; 
} // DisplayPoint  


static IdxTy DisplayString(const _text_desc & t , const view_info_t & view, const IdxTy flags)
{

return 0; 
} // DisplayString  


// https://stackoverflow.com/questions/538661/how-do-i-draw-text-with-glut-opengl-in-c
static void RenderString(float x, float y, void *font, const  char* string)
{  
//  char *c;

  glColor3f(1.0,1.0,1.0);
  glRasterPos2f(x, y);

  glutBitmapString(font, (const unsigned char *) string);
}
IdxTy Scene(const Ragged & r, const StrTy _scene, const IdxTy flags)
{
const StrTy scene=_scene; // "";
IdxTy rc=0;
Elements el;
//r.save("wtf.xxx");
el.make_elements(r,0);
MM_ERR(MMPR2(r.size(),el.size()))
//MM_ERR(" scene "<<MMPR2(el.size(),scene))
// this is not threa safe... 
//p()->EnterSerial(0);
//p()->m_scenes[scene]=el; // .make_elements(r,0);
//MM_ERR(MMPR(m_scenes[scene].size()))
//p()->ExitSerial(0);
//MM_ERR(MMPR(m_scenes[scene].size()))

// this should only be when a new one is added
MM_ERR(" scene post redisplay ")
      glutPostRedisplay();
return rc;
} // Scene

#if 0 
// https://www.khronos.org/opengl/wiki/Viewing_and_Transformations
//static float zoomFactor; /* Global, if you want. Modified by user input. Initially 1.0 */

   /* A routine for setting the projection matrix. May be called from a resize
      event handler in a typical application. Takes integer width and height 
      dimensions of the drawing area. Creates a projection matrix with correct
      aspect ratio and zoom factor. */
   void setProjectionMatrix (int width, int height, float zoomFactor,  float conditionalaspect)
   {
     glMatrixMode(GL_PROJECTION);
     glLoadIdentity();
     if ( (float)width / (float)height < conditionalaspect ) { // Adjust zoom factor to extend vertical aspect ratio if below the aspect ratio constraint otherwise extend horizontal. By default, the aspect constraint is 1.0.
     zoomfactor *= ((float)width / (float)height) / conditionalaspect;
     }
     gluPerspective(atan(tan(50.0 * 3.14159 / 360.0) / zoomFactor) * 360.0 / 3.14159, (float)width/(float)height, zNear, zFar);
     /* ...Where 'zNear' and 'zFar' are up to you to fill in. */
   }

/*
How can I automatically calculate a view that displays my entire model? (I know the bounding sphere and up vector.)
The following is from a posting by Dave Shreiner on setting up a basic viewing system:

First, compute a bounding sphere for all objects in your scene. This should provide you with two bits of information: the center of the sphere (let ( c.x, c.y, c.z ) be that point) and its diameter (call it "diam").

Next, choose a value for the zNear clipping plane. General guidelines are to choose something larger than, but close to 1.0. So, let's say you set

   zNear = 1.0;
   zFar = zNear + diam;
Structure your matrix calls in this order (for an Orthographic projection):

   GLdouble left = c.x - diam;
   GLdouble right = c.x + diam;
   GLdouble bottom c.y - diam;
   GLdouble top = c.y + diam;

   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   glOrtho(left, right, bottom, top, zNear, zFar);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
This approach should center your objects in the middle of the window and stretch them to fit (i.e., its assuming that you're using a window with aspect ratio = 1.0). If your window isn't square, compute left, right, bottom, and top, as above, and put in the following logic before the call to glOrtho():

   GLdouble aspect = (GLdouble) windowWidth / windowHeight;

   if ( aspect < 1.0 ) { // window taller than wide
     bottom /= aspect;
     top /= aspect;
   } else {
     left *= aspect;
     right *= aspect;
   }
The above code should position the objects in your scene appropriately. If you intend to manipulate (i.e. rotate, etc.), you need to add a viewing transform to it.

A typical viewing transform will go on the ModelView matrix and might look like this:

gluLookAt(0., 0., 2.*diam, c.x, c.y, c.z, 0.0, 1.0, 0.0);


*/
#endif


static IdxTy StartViewOld(const view_info_t & v) 
{
//v.distance=1.1;
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear color and depth buffers
 //  glLoadIdentity();
//   gluLookAt(0, 0, v.distance, 0, 0, -1, 0, 1, 0);
   // Set up the stationary light
// float g_lightPos[4] = { 10, 10, -100, 1 };
  glLightfv(GL_LIGHT0, GL_POSITION, v.g_lightPos);
   // Render the scene
// this is  backarwds light is fd up . 
glDisable(GL_LIGHTING);
glDisable(GL_LIGHT0);
   glMatrixMode(GL_MODELVIEW);     // To operate on model-view matrix
   // Render a color-cube consisting of 6 quads with different colors
   glLoadIdentity();                 // Reset the model-view matrix
if (false) MM_ERR(MMPR4(v.m_focus[0] ,v.m_focus[1] ,v.m_focus[2],v.distance))
// the fing lines don't fing work  . 
Gf fuf=1.0;
Gf nx= -v.m_focus[0]* fuf;//  v.distance;
Gf ny= -v.m_focus[1]* fuf; // v.distance;
Gf nz= -v.m_focus[2]* fuf; // v.distance;
//MM_ERR(MMPR4(__FUNCTION__,nx,ny,nz))
gluLookAt(nx,ny,nz,
Gf(v.m_c[0]), Gf(v.m_c[1]), Gf(v.m_c[2]),
  0, 1, 0);
//glLineWidth(Gf(fabs(v.distance)));
glLineWidth(Gf(1.0));
   // Set up the stationary light
   glLightfv(GL_LIGHT0, GL_POSITION, v.g_lightPos);
// this is fng backarwds light is fi. 
glDisable(GL_LIGHTING);
glDisable(GL_LIGHT0);
//glEnable(GL_LIGHTING);
//glEnable(GL_LIGHT0);
//   glBegin(GL_QUADS);


return 0; 
} // StartViewOld 

//typedef GLdouble Gc;
static IdxTy Unproject(Gc & x, Gc & y, Gc & z, const Gc xin, const Gc yin)
{
  Gc zs;
  glReadPixels (x, y, 1, 1, GL_DEPTH_COMPONENT, GL_DOUBLE, &zs);
Gc mp[128],pp[128];
GLint vp[128];
glGetDoublev(GL_MODELVIEW_MATRIX, &mp[0]);
glGetDoublev(GL_PROJECTION_MATRIX, &pp[0]);
glGetIntegerv(GL_VIEWPORT, &vp[0]);
gluUnProject(xin,yin,zs,mp,pp,vp,&x,&y,&z);
return 0; 
} // Unproject 



static IdxTy StartViewZed(const IdxTy flags=0) 
{
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  
 //  glLoadIdentity();
   glMatrixMode(GL_PROJECTION);     //
   glLoadIdentity();     
return 0; 
}           
static IdxTy StartView(const view_info_t & v) 
{
// https://lmb.informatik.uni-freiburg.de/people/reisert/opengl/doc/glOrtho.html

Gf l=-1.0;
Gf b=-1.0;
Gf t=1.0;
Gf r=1.0;
// TODO this needs to depend on data or be normalized etc 
Gf near =-1e9;
Gf far=1e9;
glOrtho(l,r,b,t,near,far);


   glMatrixMode(GL_MODELVIEW);     // To operate on model-view matrix
   glLoadIdentity();                 // Reset the model-view matrix

Gf nx=v.m_focus[0]; 
Gf ny=v.m_focus[1]; 
Gf nz=v.m_focus[2]; 
Gf ang=acos(nz/sqrt(nx*nx+ny*ny+nz*nz));
// this is double counting things that are hnadled byt
// the code, need to decide on e place or other
// and strings are in screen coords 
Gf fc=0;
Gf dx=fc*v.m_c[0];
Gf dy=fc*v.m_c[1];
Gf dz=fc*v.m_c[2];
Gf vd=1.0; // v.distance;
Gf sx=vd*v.m_scale[0];
Gf sy=vd*v.m_scale[1];
Gf sz=vd*v.m_scale[2];


glTranslatef(dx,dy,dz); // operates on model coords apparently 
glScalef(sx,sy,sz); 


glRotatef(ang,nx,ny,nz); // ang around vector xyz
/*
	mat4 p; // stores the Projection matrix 
	glGetFloatv(GL_PROJECTION_MATRIX,&p[0][0]); // read back the projection matrix 
	mat4 t=mat4(1.0); // soon to be a Translation matrix 
	t[3].z += dz; // set translation offset 
	p=p*t; // multiply projection matrix by translation matrix 
	glLoadMatrixf(&p[0][0]); // copy new matrix into OpenGL 
*/


#if 0 
if (false) MM_ERR(MMPR4(v.m_focus[0] ,v.m_focus[1] ,v.m_focus[2],v.distance))
// the ass  lines don't  work fo . 
Gf fuf=1.0;
Gf nx= -v.m_focus[0]* fuf;//  v.distance;
Gf ny= -v.m_focus[1]* fuf; // v.distance;
Gf nz= -v.m_focus[2]* fuf; // v.distance;
//MM_ERR(MMPR4(__FUNCTION__,nx,ny,nz))
gluLookAt(nx,ny,nz,
Gf(v.m_c[0]), Gf(v.m_c[1]), Gf(v.m_c[2]),
  0, 1, 0);
//glLineWidth(Gf(fabs(v.distance)));

#endif

glLineWidth(Gf(1.0));

// Set up the stationary light
glLightfv(GL_LIGHT0, GL_POSITION, v.g_lightPos);
glLightfv(GL_LIGHT0, GL_POSITION, v.g_lightPos);
glDisable(GL_LIGHTING);
glDisable(GL_LIGHT0);
glDisable(GL_LIGHTING);
glDisable(GL_LIGHT0);


return 0; 
} // StartView 





IdxTy Stream(const StrTy s )
{
MM_ERR(MMPR(__FUNCTION__))
BaseParams sk(s);
StrTy scene="";
StrTy fn="fddump.txt";
sk.get(fn,"fn");
sk.get(scene,"scene");
Ragged r;
r.load(fn);
//Draw(r,0);
Elements el;
el.make_elements(r,0);
// this is not threa safe... 
EnterSerial(0);
//m_scenes[scene]=el; // .make_elements(r,0);
ExitSerial(0);

return 0;
} // Stream






static IdxTy DrawQuadElements(const Elements   & el, const view_info_t & view, const IdxTy flags)
{
EnterSerial(0);
//const Elements  el=m_scenes[scene]; // ; el.make_elements(r,0);
//const View view=m_views[scene];
ExitSerial(0);
if (el.size()==0)
{
//MM_ERR("no scene yet "<<MMPR2(scene,m_scenes.size()))
return -1; 
}
//MM_ERR(" have scene "<<MMPR(el.size()))
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   // Set up viewing transformation, looking down -Z axis
   glLoadIdentity();
   
Gf g_fViewDistance=1;;
Gf nx= -view.m_focus[0]* g_fViewDistance;
Gf ny= -view.m_focus[1]* g_fViewDistance;
Gf nz= -view.m_focus[2]* g_fViewDistance;
float g_lightPos[4] = { 10, 10, -100, 1 }; 
gluLookAt(nx,ny,nz, 
Gf(view.m_c[0]), Gf(view.m_c[1]), Gf(view.m_c[2]), 
  0, 1, 0);
   glLightfv(GL_LIGHT0, GL_POSITION, g_lightPos);
glDisable(GL_LIGHTING);
glDisable(GL_LIGHT0);
//glEnable(GL_LIGHTING);
//glEnable(GL_LIGHT0);
   glBegin(GL_QUADS);       
IdxTy vidx=view.vidx();
const IdxTy nvals=el.nvalues();
vidx=vidx%nvals;
// so now this has for each node a node number, x, y, values, and then 4 elements
Gf vmin=0;
Gf vmax=0;
//MM_ERR(MMPR2(el.nvalues(),el.size()))
const auto & stats=el(vidx);
vmin=stats.mmin;
vmax=stats.mmax;
//MM_ERR(MMPR2(vmax,vmin))

if (vmax==vmin) vmax=vmin+1;
Gf rna=1.0/(vmax-vmin);
Gf c1=vmin*rna;
MM_LOOP(ii,el)
{
const Element & e=(*ii);
if (4!=e.m_vx.size()) continue;
// these need to be ordered... 
const auto& vs=view.m_scale;
for(IdxTy j=0; j<4; ++j) { 
const auto & ei=e.m_vx[j];
const auto & lo=ei.first;
const auto & v=ei.second;

//Gf gb= (v[vidx]-vmin)/(vmax-vmin);
Gf gb= v[vidx]*rna-c1;
Gf r= gb;
Gf g=1.0-4.0*(r-.5)*(r-.5) ;
Gf b=1.0-r ;
//MM_ERR(MMPR4(lo[0],lo[1],gb,r)<<MMPR2(g,b))
  glColor3f(r,g,b);     // Green
      glVertex3f(Gf(lo[0]*vs[0]),Gf(lo[1]*vs[1]),gb*vs[2]);

} // j 
//Gf z=0; Gf x0=0; Gf xf=1; Gf y0=0; Gf yf=1;
//  glColor3f(r,g,b);     // Green
//      glVertex3f(x0,y0,z);
//      glVertex3f(xf,y0,z);
//      glVertex3f(xf,yf,z);
//      glVertex3f(x0,yf,z);

} // i 

glEnd();  // End of drawing color-cube

{ Ss ss;
el.text(ss,0);
ss<<CRLF;
ss<<MMPR2(vidx,nvals);
ss<<CRLF;
ss<<MMPR2(vmin,vmax);
StrTy s=ss.str();
RenderString(5.0,5.0, GLUT_BITMAP_TIMES_ROMAN_24, s.c_str());
}

//MM_ERR(" wt f ")

//glutSwapBuffers();
//      glutPostRedisplay();


return 0;
} // Draw



// MEMBERS



}; // mjm_glut_helpers

//////////////////////////////////////////////

template <class Tr>
class mjm_glut_helpers_map : public std::map<typename Tr::StrTy, mjm_glut_helpers< Tr > >  
{
 typedef mjm_glut_helpers_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_glut_helpers< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_glut_helpers_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{
}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_glut_helpers_map




////////////////////////////////////////////
#ifdef  TEST_MJM_GLUT_HELPERS
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_glut_helpers <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_GLUT_HELPERS "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_ERR(ss.str())

}

int main(int argc,char **args)
{
about();
typedef mjm_glut_helpers<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="quit") break;
if (cmd=="dump") { MM_ERR(x.dump()) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_GLUT_HELPERS_H__ 

