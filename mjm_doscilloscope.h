#ifndef MJM_DOSCILLOSCOPE_H__
#define MJM_DOSCILLOSCOPE_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"


#include <freeglut.h>

#include "mjm_tokenized_points.h"
#include "mjm_colors_2023.h"




//#include "mjm_block_matrix.h"
#include "mjm_instruments.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_worm_blob.h"
#include "mjm_collections.h"
//#include "mjm_tokenized_collections.h"
#include "mjm_canned_methods.h"

#include "mjm_pawnoff.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_generic_iterators.h"



#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


/*
<one line to give the program's name and a brief idea of what it does.>


Conceived and written by Mike Marchywka from 2025 to present.
See dates in individual code pieces as they were 
generated from my wizards. 
Copyright (C) <year> <name of author>


This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
@software{,
  author = {Michael J Marchywka},
  city = {Talking Rock GA 30175 USA},
  title = {},
abstract={},
institution={},
license={Knowledge sir should be free to all },
publisher={Mike Marchywka},
email={marchywka@hotmail.com},
authorid={orcid.org/0000-0001-9237-455X},
  filename={mjm_doscilloscope.h},
  url = {},
  version = {0.0.0},
  date-started={2025-07-17},
}
*/

// Thu 17 Jul 2025 11:33:53 AM EDT
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_doscilloscope   
// QUICKCOMPILE  g++  -MMD -MF mjm_doscilloscope.deps  -Wall -Wno-misleading-indentation  -std=gnu++11 -DTEST_MJM_DOSCILLOSCOPE  -I/usr/include/GL  -I. -I../../mjm/hlib -I../../mjm/num  -gdwarf-3 -O0  -x c++ mjm_doscilloscope.h  -o mjm_doscilloscope.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_doscilloscope("mjm_doscilloscope" , "  ");

template <class Tr>
class mjm_doscilloscope 
{
 typedef mjm_doscilloscope Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

// TYPEDEF 
enum { BAD=~0};
//typedef mjm_canned_methods Canned;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map<StrTy, Ragged> RaggedMap;
typedef std::vector<StrTy> Words;
typedef mjm_string_base_params<Tr> BaseParams;
typedef string_tokenizer Tokenizer;
typedef string_tokenizer St;





typedef mjm_tokenized_points<Tr>  TokPoints;
typedef typename TokPoints::PointEntry PointEntry;
typedef mjm_vector_shapes<Tr> Shapes;
typedef typename Shapes::shape_t Shape;
typedef typename Shapes::point_t Point;

typedef std::map<IdxTy, TokPoints> ChartMap;


typedef GLfloat Gf;

 class _scope_trace  
{

public:
_scope_trace() {Init_scope_trace(); } 
~_scope_trace() {Free_scope_trace(); } 

_scope_trace(const Line & l,  const IdxTy first ) { Init_scope_trace(l,first); }
_scope_trace(const StrTy & s,  const IdxTy flags ) { Init_scope_trace(s,flags); }
_scope_trace(const Ragged & r, const IdxTy first,const IdxTy i0, const IdxTy flags ) 
{Init_scope_trace(r,first,i0,flags); } 

void add_point(const D &x, const D &y, const D &z=0)
{
D r=1;
D g=1;
D b=1;
//PointEntry p(x,y,z,r,g,b);

m_points.load(x,y,z,r,g,b,0);

} // add_point

template <class ModelInfo, class ViewInfo, class DrawInfo>
IdxTy draw_points(ModelInfo & m, ViewInfo & v, DrawInfo * sdp, const IdxTy i, const IdxTy sz)
{
return DrawPoints(m,v,sdp,i,sz);
}



StrTy save( const IdxTy flags=0) const { return Save_scope_trace(flags); } 
StrTy dump( const IdxTy flags=0) const { return Dump_scope_trace(flags); } 
private:
template <class ModelInfo, class ViewInfo, class DrawInfo>
// i is "1" based doh ... 
IdxTy DrawPoints(ModelInfo & m, ViewInfo & v, DrawInfo * sdp, const IdxTy i, const IdxTy sz)
{

    glBegin(GL_LINE_STRIP); //starts drawing of points
// copy? 
const auto& p=m_points;
for(IdxTy j=0; j<p.size(); ++j)
{
const auto & pj=p[j];

Gf r=pj.r();
Gf g=pj.g();
Gf b=pj.b();
if (i==sz)   glColor3f(1,0,0);     // Green
else if (i==1)   glColor3f(0,1,0);     // Green
else  glColor3f(r,g,b);     // Green
// fng distance doesn't fing work with fug line
Gf fukx=(pj.x()); // -v.m_c[0])*fu;
Gf fuky=(pj.y()); // -v.m_c[1])*fu;
Gf fukz=(pj.z()); // -v.m_c[2])*fu;
v.doglutpos(glVertex3f,fukx,fuky,fukz);
} // j 
    glEnd();//end drawing of points


return 0; 

} // DrawPoints 
/*

//MM_ERR(" drawing ornate ")
glPointSize(4.0);
glLineWidth(4.0);
//double xraw=0;
//MM_LOOP(jj,m_map)
{
if (as_points) glBegin(GL_POINTS);
else glBegin(GL_LINE_STRIP);

auto& p=(*jj).second; // m.m_ornate_points;
//MM_ERR(MMPR(p.size()))
IdxTy oldgroup=BAD;
MM_LOOP(ii,p)
{
//MM_ERR(" point ")
// this is a tokenized_point
const PointEntry& pi=(*ii);
const IdxTy group=pi.group();
const IdxTy pflags=pi.flags();
if (pflags){ MM_ERR(MMPR3(pflags,group,oldgroup)) }
if (group!=oldgroup)
{
glEnd();
if (as_points) glBegin(GL_POINTS);
else glBegin(GL_LINE_STRIP);
} // group 
glColor3f(pi.r(),pi.g(),pi.b() );//
// these need to be translated internally.
const StrTy & shape=p(pi.shape());
Shape * pshape=(Shape*)pi.shapep();
// can have a retrace blanking problem in line mode 
v.doglutpos(glVertex3f,pi.x(),pi.y(),pi.z());
if (pshape==NULL)
{
//MM_ERR(" no pshapep")
//continue;
} // null 
//MM_ERR(MMPR4(shape,pi.x(),pi.y(),pshape))
//MM_ERR(MMPR(pi.dump()))
//DrawOrnateShape(pi,pshape,v,sdp);
if (false) v.draw_ornate_shape(pi,pshape,sdp);
oldgroup=group;
} // ii 
glEnd();
} // jj 





const int style=v.style();
//const bool as_points=Bit(style,0);
//MM_ERR(" drawing ornate ")
glPointSize(4.0);
glLineWidth(4.0);
//double xraw=0;
//MM_LOOP(jj,m_map)

const bool as_points=Bit(style,0);
//MM_ERR(" drawing ornate ")
glPointSize(4.0);
glLineWidth(4.0);
//double xraw=0;
//MM_LOOP(jj,m_map)
if (as_points) glBegin(GL_POINTS);
else glBegin(GL_LINE_STRIP);

auto& p=m_points; // (*jj).second; // m.m_ornate_points;
//MM_ERR(MMPR(p.size()))
IdxTy oldgroup=BAD;
MM_LOOP(ii,p)
{
//MM_ERR(" point ")
// this is a tokenized_point
const PointEntry& pi=(*ii);
const IdxTy group=pi.group();
const IdxTy pflags=pi.flags();

} 


*/




void Init_scope_trace(const StrTy & s,  const IdxTy flags ) 
{ Init_scope_trace(); 
BaseParams kvp(s);

}
void Init_scope_trace(const Line & l,  const IdxTy first ) 
{ 
Init_scope_trace();
const IdxTy len=l.size();
for(IdxTy i=first; i<len; ++i)
{


} // i 

} // Init_scope_trace

void Init_scope_trace(const Ragged & r, const IdxTy first,const IdxTy i0,const IdxTy flags ) 
{
Init_scope_trace();
const IdxTy sz=r.size();
for(IdxTy i=i0; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();

} // i 

} // Init_scope_trace

StrTy Save_scope_trace( const IdxTy flags=0) const  
{
StrTy s;
BaseParams kvp();
//kcp,encode(s,"",);
return s; 
} // Dump 



StrTy Dump_scope_trace( const IdxTy flags=0) const  
{
Ss ss;
// ss<<MMPR4(); 
return ss.str(); 
} // Dump 


void Free_scope_trace()
{

} // Free_scope_trace

void Init_scope_trace()
{

} // Init_scope_trace

// _scope_traceMEMBERS

TokPoints m_points;
 
}; // _scope_trace

typedef _scope_trace ScopeTrace;
typedef std::map<IdxTy,ScopeTrace> TraceMap;





// API

public:
mjm_doscilloscope() {Init(); }
mjm_doscilloscope(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
mjm_doscilloscope(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}

const IdxTy size() const { return m_size; }
void clear() { Clear(); }
void load(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
void load(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}
template <class ModelInfo, class ViewInfo, class DrawInfo>
IdxTy draw_points(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{
return DrawPoints(m,v,sdp);
}
const D & xmin() const { return m_x0; }
const D & xmax() const { return m_x1; }
const D & ymin() const { return m_y0; }
const D & ymax() const { return m_y1; }



void append(const Ragged & r, const IdxTy flags) { Append(r,flags); }
template <class Tm> void append(const Ragged & r, Tm & mi, const IdxTy flags) { Append(r,mi,flags); }
void append(const Myt & that, const IdxTy flags) { Append(that,flags); }


void save(const StrTy & fn,const StrTy &s) {Save(fn,s); }

StrTy xxx_test(const StrTy & sin, const IdxTy flags) 
{ return XXX_test(sin,flags); } 
~mjm_doscilloscope() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
D atof(const StrTy & s) const { return ::atof(s.c_str()); } 
int myatoi(const StrTy & s )const   { return mjm_canned_methods::myatoi(s.c_str()); }
int myatoi(const char * c) const  { return mjm_canned_methods::myatoi(c); }
static bool Bit(const IdxTy f, const IdxTy b) { return  ((f>>b)&1)!=0; }
// should loop over map now 
static void Set(IdxTy& f, const IdxTy b,const bool x) //const  
    { if (x) f|=(1<<b); else f&=((~1)<<b); }
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);
template <class ModelInfo, class ViewInfo, class DrawInfo>
IdxTy DrawPoints(ModelInfo & m, ViewInfo & v, DrawInfo * sdp)
{
const int style=v.style();
const bool as_points=Bit(style,0);
const IdxTy sz=m_map.size();
IdxTy i=0; 
const D lwone=1;
const D lwend=5;
const D lw=2;

MM_LOOP(ii,m_map) {
++i;
if (i==1) glLineWidth(lwone);
else if (i==sz) glLineWidth(lwend);
else  glLineWidth(lw);
 (*ii).second.draw_points(m,v,sdp,i,sz); 
} 
return 0;
} // DrawPoints
void Append(const Ragged & r, const IdxTy flags) { 
//m_params.clear();  LoadXNY(r,"",flags); 
}
template <class Tm>
void Append(const Ragged & r, Tm & mi, const IdxTy flags) {
//m_params=mi.params();
//Ss ss; MM_LOOP(ii,m_params) { ss<<MMPR2((*ii).first,(*ii).second); }
//MM_ERR(MMPR2(m_params.size(),ss.str()))

ScopeTrace st;
D xbase=0;
bool setx=false;
//  This needs to be locked if used.. 
//ViewInfo & v=m_view;
MM_ILOOP(i,r.size())
{ 
const Line & l =r[i];
const IdxTy len=l.size();
if (len<2) continue;
if (l[0].c_str()[0]=='#') continue;

D x=atof(l[0]);
//if ( !setx){  xbase=x; setx=true; } 
x=x-xbase;
const D y=atof(l[1]);
const D z=(len>2)?atof(l[2]):0;
//MM_ERR(MMPR3(x,y,z))
st.add_point(x,y,z);
} // i 
while (m_map.size()>10) { m_map.erase(m_map.begin()); } 
m_map[m_next]=st;
++m_next;
}
// these all have different m_st values doh... 
// ASFCK now this is called fcking later fck
void Append(const Myt & that, const IdxTy flags)
{
#if 0 
m_params.clear();
// needs to sort out groups... 
MM_LOOP(ii,that.m_map)
{
const IdxTy oldkey=(*ii).first;
const StrTy nm=that.m_st(oldkey);
// will want to chnage color... 
auto  old=(*ii).second;
const IdxTy chart=m_st(nm);
// want to update colors if default but no idea...
const auto ff=that.m_info.find(oldkey);
// better exist ... 
const auto & oldinfo=(*ff).second; // that.m_info[oldkey];

auto & tnew=m_map[chart];
if (m_info.find(chart)==m_info.end())
{ m_info[chart].color(chart); }
const auto & ci=m_info[chart];

// f-es up color.. 
//tnew+=old;
MM_LOOP(jj,old)
{
//auto
tnew.load((*jj).x(),(*jj).y(),(*jj).z(),ci.r(),ci.g(),ci.b(),0);
} // jj 
//tnew.next_group();

} // ii 
#endif
//m_groups+=that.m_groups;
}  // Append 



void Save(const StrTy & fn,const StrTy &s) {
// std::ofstream ofs(fn);

 } // Save
StrTy XXX_test(const StrTy & sin, const IdxTy flags) 
{
StrTy sout="";
MM_ERR(MMPR3(sin,flags,sout))
BaseParams kvp(sin);

return sout;
} // XXX_test

void Init(const Ragged & r, const IdxTy start=0, const IdxTy first=0, const IdxTy flags=0  )
{
Init();
const IdxTy sz=r.size();
for(IdxTy i=start; i<sz; ++i)
{
//const Line & l=r[i];
//const IdxTy len=l.size();


}  // i 

} // Init 
void Init(const StrTy  & sin,const IdxTy flags =0  )
{
Init();
BaseParams kvp(sin);
} // Init 

void Init()
{
m_size=0;
m_x0=0;
m_x1=0;
m_y0=0;
m_y1=0;
m_next=0;
//m_groups=0;
} // Init

StrTy Show(const IdxTy flags=0)const {Ss ss;
ss<<MMPR4(m_size,m_x0,m_x1,m_y0)<<MMPR(m_y1);
ss<<CRLF;
//MM_LOOP(ii,m_map) { const IdxTy tok=(*ii).first; const StrTy nm=m_st(tok);   ss<<MMPR2(tok,nm)<<" ";  }
//ss<<",";
//ss<<CRLF;
//MM_LOOP(ii,m_info) { const IdxTy tok=(*ii).first; const StrTy nm=m_st(tok);   ss<<MMPR2(tok,nm)<<" ";  }

return ss.str(); }
void Clear()
{
m_map.clear();
//MM_LOOP(ii,m_map) { (*ii).second.clear(); }  // TokPoints
Init();
} // Cleap 



// MEMBERS
St m_st;
//ChartMap m_map;
//InfoMap m_info;
IdxTy m_size;
//IdxTy m_groups;
D m_x0,m_x1,m_y0,m_y1;
//Parameters m_params;
TraceMap m_map;
IdxTy m_next;

}; // mjm_doscilloscope

//////////////////////////////////////////////

template <class Tr>
class mjm_doscilloscope_map : public std::map<typename Tr::StrTy, mjm_doscilloscope< Tr > >  
{
 typedef mjm_doscilloscope_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_doscilloscope< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_doscilloscope_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{


}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_doscilloscope_map




////////////////////////////////////////////
#ifdef  TEST_MJM_DOSCILLOSCOPE
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_doscilloscope <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;

#define CI(n) atoi(cip.wif(n).c_str()) 

void about()
{
Ss ss;
ss<<" MJM_DOSCILLOSCOPE "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_MSG(ss.str())

}
typedef mjm_ragged_table Ragged;

#define CIP(n) atoi(cip.wif(n).c_str())
#define CFP(n) atof(cip.wif(n).c_str())

int main(int argc,char **args)
{
about();
typedef mjm_doscilloscope<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="loadragged") {
 	const IdxTy start=atoi(cip.wif(2).c_str()); 
	const IdxTy first=atoi(cip.wif(3).c_str()); 
	const IdxTy flags=atoi(cip.wif(4).c_str()); 
Ragged r; r.load(cip.p1); x.load(r,start,first,flags); }
if (cmd=="load") {x.load(cip.p1,atoi(cip.p2.c_str())); }
if (cmd=="save") {x.save(cip.p1,cip.p2); }
if (cmd=="test") {StrTy xxx=x.xxx_test(cip.p1,CIP(2)); MM_ERR(MMPR(xxx))  }
if (cmd=="quit") break;
// NB this does not work in gneral when errors are disabled
//if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="dump") { auto wtf=x.dump();  MM_ERR(wtf) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_DOSCILLOSCOPE_H__ 
