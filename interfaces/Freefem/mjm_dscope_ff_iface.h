#ifndef MJM_DSCOPE_FF_IFACE_H__
#define MJM_DSCOPE_FF_IFACE_H__


/*
<one line to give the program's name and a brief idea of what it does.>


Conceived and written by Mike Marchywka from 2023 to present.
See dates in individual code pieces as they were 
generated from my wizards. 
Copyright (C) <year> <name of author>


This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
@software{,
  author = {Michael J Marchywka},
  city = {Jasper GA 30143 USA},
  title = {},
abstract={},
institution={},
license={Knowledge sir should be free to all },
publisher={Mike Marchywka},
email={marchywka@hotmail.com},
authorid={orcid.org/0000-0001-9237-455X},
  filename={mjm_dscope_ff_iface.h},
  url = {},
  version = {0.0.0},
  date-started={2023-09-11},
}
*/

// Mon 11 Sep 2023 07:02:19 PM EDT
// generated by /home/documents/cpp/scripts/cpputil -classhdr mjm_dscope_ff_iface   


#include "mjm_globals.h"
#include "mjm_dscope_interface.h"
// no idea FIXME TODO wtf 
#undef OK 
// even these may not be needed but I moved some ff functions
// into the ds name space 
#include "ff++.hpp"
#include "AFunction_ext.hpp"

// so far these do not seem to be needed here limit scope into cpp
//#include "lgmesh.hpp"
//using Fem2D::Mesh;
//using Fem2D::MeshPoint;
//extern bool NoWait;
//typedef Mesh const * pmesh;



mjm_global_credits::credit __credit__mjm_dscope_ff_iface("mjm_dscope_ff_iface" , "  ");

namespace mjm_dscope_globals
{

typedef mjm_dscope_interface<> Dscope;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef mjm_string_base_params<Dscope::traits_type> BaseParams;
typedef double ValTy;
typedef mjm_block_matrix<ValTy> DscopeBlock;
typedef Dscope::traits_type::Ss Ss;

typedef std::string StrTy;
typedef unsigned int IdxTy;

typedef std::map<int,Expression> PMap;
typedef std::vector<StrTy> DscopeParams;

// mjm_globals presents a lot of debugging  macro's
// that could be turned off at runtime or compile time.
// in case of debugging, do not instantiate glob_fix
// or see the variables defined in mjm_globals.h
class _fix_globs
{
public:
_fix_globs() { mjm_global_flags::mm_err_enable=false; }
}; // _fix_globs
_fix_globs glob_fix;


// TODO some of this stuff may be moced into mjm_datatscope code
// as it is not FF specific and msy be useful in many cases.
// other users include my FD code and an R package. 

// each Dscope transaction is identified by source to allow
// resolution at receiving end. 
// this should be hierarchial allowing multiple sources
// within a particular run of an app 
StrTy dscope_src="FreeFem++";
// this launches a fifo to communicate with
// dscope which is either local or the fifo is on
// a filesystem they both can see. 
//StrTy dscope_init="rawfifo launch  2"; 
// note that spaces are crucial here like comma ( or python lol ) 
// a dscope_config impl may have to modify these 
//StrTy dscope_init="rawfifo launch  2"; 
StrTy dscope_init="rawfifo launch file_name=/tmp/datascope_fifo.txt 2"; 
StrTy dscope_fifo="/tmp/datascope_fifo.txt"; 

// only want one of these for all callers
//Dscope m_dscope;
// TODO right now there is no clean way to shut everything off
// probably the dtor will be fixed first and destroying it
// is eady. Forgetting to delete on exit should cause not problems
Dscope *  p_dscope=0;
Dscope & dscope() { return * p_dscope; } 
// this should be called from all compile methods
IdxTy dscope_start()
{
// assume user deletes if really want restart 
if (p_dscope) return 0;
p_dscope = new Dscope();
dscope().load(dscope_init,0);     
return 0; 
} // dscope_start
IdxTy dscope_stop()
{
delete p_dscope;
p_dscope=0;
return 0; 
} // dscope_stop

// TODO this all needs to be moved into the mjm_dscope interace
// ias it is not specific to Freefem++
void add_id(Ss & ss, const StrTy & id)
{ ss<<"# id "<<dscope_src<<" "<<id<<CRLF; } // add_id

IdxTy dscope_trace_header(Ragged & r,const StrTy &  id)
{ return dscope_trace_header(r,id.c_str()); } 
IdxTy dscope_trace_header(Ragged & r,const char * id)
{
Ss ss;
//ss<<"# id test pattern chunks 0 "<<CRLF;
add_id(ss,id);
//ss<<"# id "<<dscope_src<<" "<<id<<CRLF;
ss<<"# time-snap 1D "<<CRLF;
ss<<"# trace "<<CRLF;
r.load(ss,false);
return 0; 
} // dscope_trace_header

IdxTy dscope_mesh_header(Ragged & r,const StrTy & id)
{
Ss ss;
//ss<<"# id test pattern chunks 0 "<<CRLF;
add_id(ss,id);
//ss<<"# id "<<dscope_src<<" "<<id<<CRLF;
ss<<"# ffmesh 2D "<<CRLF;
//ss<<"# trace "<<CRLF;
//ss<<""<<CRLF;
r.load(ss,false);
return 0;
} // dscope_mesh_header


// now onto actual ff specific code 
IdxTy dscope_add_params(Ragged & r,const Ragged & m_evct_header,const string * params)
{
if ( &r != &m_evct_header) r=m_evct_header;
std::stringstream ss;
ss<<"# "<<*params;
r.load(ss,false);
return 0;
} // dscope_add_params
IdxTy dsacope_express(PMap & exp, PMap & str,const basicAC_F0 & args ,const int i0)
{
for(int i=i0; i<args.size(); ++i)
{
int iz=i-i0;
try { 
try { 
// TODO retrhink the approach here. 
// throwing works but clutters the display and there is no assurance
// the compiler cleanly handles a perceived fatal error lol. 
 if (BCastTo< double >(args[i]))
 exp[iz]= to< double >(args[i]);
else 
 str[iz]= to< string *  >(args[i]);
} catch (...) { // MM_ERR("try string "); 
 str[iz]= to< string *  >(args[i]);
} 
} catch (...) { // MM_ERR("try string "); 
MM_ERR(" need a fespace or a string here "<<MMPR(i))
throw; 
} // catch 2 
} //i 
return 0;
} // dscope_express

// convert the ff strings with position index into normal strings 
IdxTy dscope_params(DscopeParams & pv, const PMap & str, const Stack & stack)
{
MM_LOOP(ii,str) 
{
string * p =  GetAny<string*>((*(*ii).second)(stack));
typedef std::stringstream Ss;
Ss ss;
ss<<p;
pv.push_back(ss.str());
} // ii 

return 0;
} // dscope_params

}; // mjm_dscope_globals;

















#endif // MJM_DSCOPE_FF_IFACE_H__ 
