#ifndef MJM_SWARNALATOR_H__
#define MJM_SWARNALATOR_H__

#include "mjm_globals.h"
#include "mjm_thread_util.h"
#include "mjm_dscope_interface.h"

//#include "mjm_block_matrix.h"
#include "mjm_instruments.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_worm_blob.h"
#include "mjm_collections.h"
//#include "mjm_tokenized_collections.h"
#include "mjm_canned_methods.h"

#include "mjm_pawnoff.h"
#include "mjm_strings.h"
#include "mjm_string_kvp.h"
#include "mjm_generic_iterators.h"



#include <random> 
#include <map> 
#include <vector> 
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <string>
#include <fstream>
#include <signal.h>
#include <stdlib.h>
#include <stdint.h>


/*
<one line to give the program's name and a brief idea of what it does.>


Conceived and written by Mike Marchywka from 2023 to present.
See dates in individual code pieces as they were 
generated from my wizards. 
Copyright (C) <year> <name of author>


This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
@software{,
  author = {Michael J Marchywka},
  city = {Jasper GA 30143 USA},
  title = {},
abstract={},
institution={},
license={Knowledge sir should be free to all },
publisher={Mike Marchywka},
email={marchywka@hotmail.com},
authorid={orcid.org/0000-0001-9237-455X},
  filename={mjm_swarnalator.h},
  url = {},
  version = {0.0.0},
  date-started={2023-12-22},
}
*/

// Fri 22 Dec 2023 06:22:49 PM EST
// generated by /home/documents/cpp/scripts/cpputil -operand -classhdr mjm_swarnalator   
// QUICKCOMPILE  g++  -MMD -MF mjm_swarmalator.deps  -Wall -Wno-misleading-indentation  -std=gnu++11 -DTEST_MJM_SWARNALATOR -I. -I../../mjm/hlib -I../datascope -I../../mjm/num  -gdwarf-3 -O3  -x c++ mjm_swarnalator.h  -o mjm_swarnalator.out -lpthread -lreadline

mjm_global_credits::credit __credit__mjm_swarnalator("mjm_swarnalator" , " https://www.nature.com/articles/s41467-017-01190-3 ");

template <class Tr>
class mjm_swarnalator 
{
 typedef mjm_swarnalator Myt;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;

// TYPEDEF 
enum { BAD=~0};
//typedef mjm_canned_methods Canned;
typedef mjm_ragged_table Ragged;
typedef Ragged::Line Line;
typedef std::map<StrTy, Ragged> RaggedMap;
typedef std::vector<StrTy> Words;
typedef mjm_string_base_params<Tr> BaseParams;
typedef mjm_dscope_interface<Tr> Dscope;

static int my_random_seed()
{
struct timeval tp;
gettimeofday(&tp, NULL);
typedef long long Tl;
Tl  t = ((Tl) tp.tv_sec)  * 1000000 + tp.tv_usec; //  / 1000;
if (tp.tv_usec==0) t=tp.tv_sec;
return int(t);
}

 class _model_params  
{

public:
_model_params() {Init_model_params(); } 
~_model_params() {Free_model_params(); } 

_model_params(const Line & l,  const IdxTy first ) { Init_model_params(l,first); }
_model_params(const StrTy & s,  const IdxTy flags ) { Init_model_params(s,flags); }
_model_params(const Ragged & r, const IdxTy first,const IdxTy i0, const IdxTy flags ) 
{Init_model_params(r,first,i0,flags); } 

_model_params(const _model_params & that ) { *this=that ; }  

MM_GETSET(D,A,m_A) 
MM_GETSET(D,B,m_B) 
MM_GETSET(D,J,m_J) 
MM_GETSET(D,K,m_K) 
MM_GETSET(D,dt,m_dt) 
MM_GETSET(IdxTy,imod,m_imod) 
MM_GETSET(IdxTy,uswait,m_uswait) 



bool operator<(const _model_params & that) const { return false;}
bool operator==(const _model_params & that) const { return false;}
bool operator>(const _model_params & that) const { return false;}
_model_params & operator++() const { return *this;}
_model_params & operator+=(const _model_params & that ) const { return *this;}
// default
//_model_params & operator=(const _model_params & that )  { return *this;}

StrTy save( const IdxTy flags=0) const { return Save_model_params(flags); } 
StrTy dump( const IdxTy flags=0) const { return Dump_model_params(flags); } 
private:
void Init_model_params(const StrTy & s,  const IdxTy flags ) 
{ Init_model_params(); 
BaseParams kvp(s);
kvp.get(m_dt,"dt");
kvp.get(m_imod,"imod");
kvp.get(m_uswait,"uswait");
kvp.get(m_A,"A");
kvp.get(m_J,"J");
kvp.get(m_B,"B");
kvp.get(m_K,"K");
// m_A=1; m_J=1; m_B=1; m_K=1; m_dt=.0001;

}
void Init_model_params(const Line & l,  const IdxTy first ) 
{ 
Init_model_params();
const IdxTy len=l.size();
for(IdxTy i=first; i<len; ++i)
{


} // i 

} // Init_model_params

void Init_model_params(const Ragged & r, const IdxTy first,const IdxTy i0,const IdxTy flags ) 
{
Init_model_params();
const IdxTy sz=r.size();
for(IdxTy i=i0; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();

} // i 

} // Init_model_params

StrTy Save_model_params( const IdxTy flags=0) const  
{
StrTy s;
BaseParams kvp();
//kcp,encode(s,"",);
return s; 
} // Dump 



StrTy Dump_model_params( const IdxTy flags=0) const  
{
Ss ss;
// ss<<MMPR4(); 
return ss.str(); 
} // Dump 


void Free_model_params()
{

} // Free_model_params

void Init_model_params()
{
 m_A=1;
 m_J=1;
 m_B=1;
m_K=1;
m_imod=1;
m_dt=.0001;
m_uswait=0;
} // Init_model_params

// _model_paramsMEMBERS
D m_A,m_B,m_J,m_K,m_dt; 
IdxTy m_imod,m_uswait;
}; // _model_params

typedef _model_params ModelParams;

 class _point  
{

public:
_point() {Init_point(); } 
~_point() {Free_point(); } 

_point(const D & x, const D &y ) { Init_point();m_x=x; m_y=y; }
_point(const D & x, const D &y,const D & t ) { Init_point();m_x=x; m_y=y; m_theta=t; }
_point(const Line & l,  const IdxTy first ) { Init_point(l,first); }
_point(const StrTy & s,  const IdxTy flags ) { Init_point(s,flags); }
_point(const Ragged & r, const IdxTy first,const IdxTy i0, const IdxTy flags ) 
{Init_point(r,first,i0,flags); } 
_point(const _point & that ) { *this=that ; }  
bool operator<(const _point & that) const { return false;}
bool operator==(const _point & that) const { return false;}
bool operator>(const _point & that) const { return false;}
_point & operator++() const { return *this;}
_point & operator=(const D & x)  {m_x=x; m_y=x; m_theta=x;  return *this;}
_point & operator+=(const _point & that ) {
m_x+=that.m_x;
m_y+=that.m_y;
m_theta+=that.m_theta;
m_theta=m_theta-2.0*M_PI*int(m_theta/(2.0*M_PI));
 return *this;}
_point  operator*(const D & x ) const {
_point v;
v.m_x=x*m_x;
v.m_y=x*m_y;
v.m_theta=x*m_theta;
 return v;}



// default ok for no
//_point & operator=(const _point & that ) const { return *this;}
D rxy(const _point & that ) const { D x1=m_x-that.m_x; D x2=m_y-that.m_y;
return x1*x1+x2*x2; } 
MM_GETSET(D,x,m_x) 
MM_GETSET(D,y,m_y) 
MM_GETSET(D,theta,m_theta) 
StrTy save( const IdxTy flags=0) const { return Save_point(flags); } 
StrTy dump( const IdxTy flags=0) const { return Dump_point(flags); } 
private:
void Init_point(const StrTy & s,  const IdxTy flags ) 
{ Init_point(); 
BaseParams kvp(s);

}
void Init_point(const Line & l,  const IdxTy first ) 
{ 
Init_point();
const IdxTy len=l.size();
for(IdxTy i=first; i<len; ++i)
{


} // i 

} // Init_point

void Init_point(const Ragged & r, const IdxTy first,const IdxTy i0,const IdxTy flags ) 
{
Init_point();
const IdxTy sz=r.size();
for(IdxTy i=i0; i<sz; ++i)
{
const Line & l=r[i];
const IdxTy len=l.size();

} // i 

} // Init_point

StrTy Save_point( const IdxTy flags=0) const  
{
StrTy s;
BaseParams kvp();
//kcp,encode(s,"",);
return s; 
} // Dump 



StrTy Dump_point( const IdxTy flags=0) const  
{
Ss ss;

 ss<<MMPR3(m_x,m_y,m_theta); 
return ss.str(); 
} // Dump 


void Free_point()
{

} // Free_point

void Init_point()
{
m_x=0;
m_y=0;
m_theta=0;
} // Init_point

// _pointMEMBERS
D m_x,m_y,m_theta; 
}; // _point

typedef _point Point;
typedef std::vector<Point> Points;
typedef std::vector<D> State;
// API

public:
mjm_swarnalator() {Init(); }
mjm_swarnalator(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
mjm_swarnalator(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}

void load(const StrTy & sin,const IdxTy flags) {Init(sin,flags); }
void load(const Ragged & r,const IdxTy start, const IdxTy first,const IdxTy flags ) {Init(r,start,first,flags);}
void save(const StrTy & fn,const StrTy &s) {Save(fn,s); }

~mjm_swarnalator() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
int myatoi(const StrTy & s )const   { return mjm_canned_methods::myatoi(s.c_str()); }
int myatoi(const char * c) const  { return mjm_canned_methods::myatoi(c); }
IdxTy dscope(const StrTy & cmd, const StrTy & s) { m_dscope.load(cmd,0); return 0;  }
// "rawfifo launch  2"
void launch_default() { dscope(m_fifo_launch,StrTy()); }
void send_stuff(const StrTy &fn, const StrTy & ty)
{
const StrTy sid="catmjmds";
Ragged r;
m_dscope.setup(r,sid,ty);
MM_ERR(MMPR2(fn,r.size()))
r.load(fn);
MM_ERR(MMPR(r.size()))
m_dscope.send(r,0);
if (false) MM_ERR(MMPR(r.dump_ssv()));
} // send_stuff
// x y z sz color shape
//.1 .2 0 .2 #FFFFFF circle 
//.3 .2 0 .2 #FFFF triangle
// -m/2 -> m/2 
D dmod( const D & x, const D & m)
{return x-int(x/m)*m-.5*m; } 
StrTy  theta_color(const D & t)
{
const D m=2*M_PI;
IdxTy i=0;
D r=2.0*255*fabs(dmod(t,m)/m);
D g=2.0*255*fabs(dmod(t+m/3.0,m)/m);
D b=2.0*255*fabs(dmod(t+2.0*m/3.0,m)/m);
i=(int(r)&255);
i|=(int(g)&255)<<8;
i|=(int(b)&255)<<16;
Ss ss;
ss<<"#"<<std::hex<<i;

if (r<2) if (g<2) if (b<2) 
MM_ERR(MMPR4(r,g,b,ss.str()))

//MM_ERR(MMPR(ss.str()))
return ss.str();
} // theta_color

bool send_points(const StrTy & params=StrTy())
{
const bool wait_on_full=true;
IdxTy cnt=0;
if (wait_on_full) 
{ while (m_dscope.que_full()) {++cnt;  usleep(10000); }   }
else { 
MM_ERR(" wtf ")
if (m_dscope.que_full()) return false;  }
if (cnt) MM_ERR(MMPR2(cnt,m_dscope.que_full()))
Ragged r;
//StrTy params="";
const StrTy ty="ornate-points";
const StrTy sid="swarmalaotr";
m_dscope.setup(r,sid,ty,params);
//const D sz=.05;
const D szd=1.0/::log(m_points.size())*log(10.0);
const D sz=.15*szd*szd;
MM_LOOP(ii,m_points)
{
Line l;
r.add(l);
const auto & p=(*ii);
///const StrTy c="#FFFFFF";
const StrTy c=theta_color(p.theta()); // "#FFFFFF";
const StrTy shape="circle";
r<<p.x()<<p.y()<<"0"<<sz<<c<<shape;
//MM_ERR(MMPR((*ii).dump()))
} // ii 
m_dscope.send(r,0);
if (false) MM_ERR(MMPR(r.dump_ssv()));
//usleep(100000);
return true; 
} // send_points

static bool Bit(const IdxTy f, const IdxTy b)   { return  ((f>>b)&1)!=0; }
// should loop over map now 
StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


void Save(const StrTy & fn,const StrTy &s) {
// std::ofstream ofs(fn);

 } // Save
void Init(const Ragged & r, const IdxTy start=0, const IdxTy first=0, const IdxTy flags=0  )
{
Init();
const IdxTy sz=r.size();
for(IdxTy i=start; i<sz; ++i)
{
//const Line & l=r[i];
//const IdxTy len=l.size();


}  // i 

} // Init 
void Init(const StrTy  & sin,const IdxTy flags =0  )
{
Init();
BaseParams kvp(sin);
IdxTy n=10;
//D dt=.01;
kvp.get(n,"n");
m_params=ModelParams(sin,flags); 
//kvp.get(dt,"dt");
Random(n);
Loop();
} // Init 
void Init()
{
m_fifo_launch="rawfifo launch  2";
launch_default(); // TODO really premature but ok for testing 

} // Init
void Loop()
{
const D dt=m_params.dt();
const IdxTy uswait=m_params.uswait();
const IdxTy imod=m_params.imod();
D time=0;
IdxTy i=0;
while (true)
{
//State rhs;
Points  rhs;
Rhs(rhs,m_params);
// x,y,t
const IdxTy sz=m_points.size();
MM_ILOOP(i,sz) { m_points[i]+=rhs[i]*dt; }
Ss ss; ss<<" time="<<time;
if ((i%imod)==0){  send_points(ss.str()); usleep(uswait); }
time+=dt;
++i;
} // true

} //  Loop 
void Random(const IdxTy n)
{
m_points.resize(n);
static std::mt19937_64 mt(my_random_seed());
MM_ILOOP(i,n)
{
D nr=IdxTy(mt()); // 64 bit int...
nr/=IdxTy(~0);
D ns=IdxTy(mt()); // 64 bit int...
ns/=IdxTy(~0);
D t=IdxTy(mt())&0xFFFFFF;
t=t-2.0*M_PI*int(t/(2.0*M_PI));
if ((nr>1)||(nr<0)) MM_ERR(MMPR(nr))
if ((ns>1)||(ns<0)) MM_ERR(MMPR(ns))
if ((t>(2.0*M_PI))||(t<0)) MM_ERR(MMPR(t))
m_points[i]=Point(nr,ns,t);
} // i 
} // Random
#if 0 
void Rhs(State &rhs)
{
const IdxTy n=m_points.size();
rhs.resize(3*n);
IdxTy b=0;
const D A=1;
const D J=1;
const D B=1;
const D K=1;
MM_ILOOP(i,n)
{
const auto & pi=m_points[i];
rhs[b]=0;
rhs[b+1]=0;
rhs[b+2]=0;
// figure it out later lol. 
//for(IdxTy j=(i+1); j<n; ++j)
for(IdxTy j=0; j<n; ++j)
{
if (j==i) continue; 
const auto & pj=m_points[i];
const D r2=(pj.rxy(pi));
const D r=sqrt(r2);
const D x1=pi.x()-pj.x();
const D y1=pi.y()-pj.y();
const D t1=pi.theta()-pj.theta();
rhs[b]+=x1/r*(A+J*cos(t1))-B*x1/r2;
rhs[b+1]+=y1/r*(A+J*cos(t1))-B*y1/r2;
rhs[b+2]+=sin(t1)/r;
} // j 
rhs[b]/=n;
rhs[b+1]/=n;
rhs[b+2]*=K/n;
b+=3;
} // i 
//send_points();
} // Rhs
#endif

void Rhs(Points &rhs, const ModelParams & mp)
{
const IdxTy n=m_points.size();
rhs.resize(n);
//IdxTy b=0;
const D A=mp.A();
const D J=mp.J();
const D B=mp.B();
const D K=mp.K();
MM_ILOOP(i,n)
{
const auto & pi=m_points[i];
auto & ri=rhs[i];
ri=0;
//rhs[b]=0;
//rhs[b+1]=0;
//rhs[b+2]=0;
// figure it out later lol. 
//for(IdxTy j=(i+1); j<n; ++j)
for(IdxTy j=0; j<n; ++j)
{
if (j==i) continue; 
const auto & pj=m_points[j];
//MM_ERR(MMPR2(pi.dump(),pj.dump()))
const D r2=(pj.rxy(pi));
const D r=sqrt(r2);
const D x1=pj.x()-pi.x();
const D y1=pj.y()-pi.y();
const D t1=pj.theta()-pi.theta();
//rhs[b]+=x1/r*(A+J*cos(t1))-B*x1/r2;
//rhs[b+1]+=y1/r*(A+J*cos(t1))-B*y1/r2;
//rhs[b+2]+=sin(t1)/r;

rhs[i]+=_point(x1/r*(A+J*cos(t1))/n-B*x1/r2/n,
y1/r*(A+J*cos(t1))/n-B*y1/r2/n,
sin(t1)/r*K/n); 

} // j 
//rhs[b]/=n; rhs[b+1]/=n; rhs[b+2]*=K/n;
//b+=3;
} // i 
//send_points();
} // Rhs


// MEMBERS
Points m_points;
ModelParams m_params;
Dscope m_dscope;
StrTy m_fifo_launch;

}; // mjm_swarnalator

//////////////////////////////////////////////

template <class Tr>
class mjm_swarnalator_map : public std::map<typename Tr::StrTy, mjm_swarnalator< Tr > >  
{
 typedef mjm_swarnalator_map Myt;
typedef typename std::map<typename Tr::StrTy, mjm_swarnalator< Tr> >   Super;
 typedef typename Tr::IdxTy IdxTy;
 typedef typename Tr::D D;
 typedef typename Tr::StrTy StrTy;
 typedef typename Tr::Ss Ss;
 typedef typename Tr::IsTy IsTy;
 typedef typename Tr::OsTy OsTy;
 typedef typename Tr::Ofs Ofs;
//typedef typename Tr::FlagTy; 
// typedef typename Tr::MyBlock  MyBlock;
public:
mjm_swarnalator_map() {}
StrTy dump(const IdxTy flags=0) { return Dump(flags); }
private:
bool Bit(const IdxTy f, const IdxTy b) const  { return  ((f>>b)&1)!=0; }
// should loop over map now 
//StrTy Dump(const IdxTy flags=0) {Ss ss;  return ss.str(); }
typedef typename mjm_thread_util<Tr>::mutex_vector MutexVector;

enum { MAP_MU=0 , MU_SZ};
mutable MutexVector m_mutex_vector;
void EnterSerial(const IdxTy i)const  {  m_mutex_vector.enter_serial(i ); }
void ExitSerial(const IdxTy i)const  {  m_mutex_vector.exit_serial(i ); }
//m_mutex_vector = MutexVector(MU_SZ);


//StrTy dump(const IdxTy flags=0) { return Dump(flags); }

private:

void Init()
{


}

StrTy Dump(const IdxTy flags=0)
{
Ss ss;
MM_LOOP(ii,(*this))
{
ss<<(*ii).first<<CRLF;
ss<<(*ii).second.dump()<<CRLF;


}
return ss.str();
// return Dump(flags); 

}




private:

}; // mjm_swarnalator_map




////////////////////////////////////////////
#ifdef  TEST_MJM_SWARNALATOR
class Tr {
public:
// typedef mjm_string_picker Myt;
 typedef unsigned int IdxTy;
 typedef double  D;
 typedef std::string StrTy;
 typedef std::stringstream Ss;
 typedef std::istream  IsTy;
 typedef std::ostream  OsTy;
 typedef std::ofstream  Ofs;
// typedef typename Tr::MyBlock  MyBlock;
}; // 


#include "mjm_instruments.h"
#include "mjm_cli_ui.h"
typedef Tr::StrTy StrTy;
typedef Tr::IdxTy IdxTy;

template <class Tt> class tester_ {
typedef tester_<Tt> Myt;
typedef mjm_cli_ui<Myt> Cli;
//typedef tester Myt;
//typedef mjm_cli_ui<Myt> Cli;
typedef std::map<StrTy, StrTy> LocalVar;

typedef CommandInterpretterParam Cip ;
typedef void (Myt:: * CmdFunc)(Cip &, LocalVar &  ) ;
typedef std::map<StrTy, CmdFunc> CmdMap;
typedef std::vector<StrTy> Choices;
//typedef void (Myt:: * CompleteFunc) ( Cli::list_type & choices,  const char * cmd, const char * frag);
typedef void (Myt:: * CompleteFunc) ( Choices & choices,  const char * cmd, const char * frag);
typedef std::map<StrTy, CompleteFunc> CompMap;

public:
 //void cli_cmd( Cli::list_type & choices,  const char * frag)
 void cli_cmd( Choices & choices,  const char * frag)
{
const IdxTy nfrag=strlen(frag);
MM_LOOP(ii,m_cmd_map)
{
const StrTy & v=(*ii).first;
if (strncmp(v.c_str(),frag,nfrag)==0)  choices.push_back(v);
}
}

 //void cli_param( Cli::list_type & choices,  const char * _cmd, const char * frag)
 void cli_param( Choices & choices,  const char * _cmd, const char * frag)
{
MM_ERR("cli_param"<<MMPR2(_cmd,frag))
//const StrTy cmd=CliTy::word(StrTy(_cmd),0);
//auto ii=m_comp_map.find(cmd);
//if ( ii!=m_comp_map.end()) ((this)->*(*ii).second)(choices,cmd.c_str(),frag);
}

CmdMap m_cmd_map;


 }; // tester_
typedef tester_< mjm_swarnalator <Tr>  > tester;

typedef mjm_cli_ui<tester> Cli;


typedef Tr::Ss Ss;
void about()
{
Ss ss;
ss<<" MJM_SWARNALATOR "<<__DATE__<<" "<<__TIME__<<CRLF;
MM_MSG(ss.str())

}
typedef mjm_ragged_table Ragged;
int main(int argc,char **args)
{
about();
typedef mjm_swarnalator<Tr>  Myt;
//Myt x(argc,args);
Myt x;

//if (!x.done()) x.command_mode();
Cli cli;
tester tester;
CommandInterpretter li(&std::cin);
li.push(args,argc);
cli.set_target(tester);
cli.set_command_handler(&tester::cli_cmd);
cli.set_param_handler(&tester::cli_param);
cli.activate();
li.set_split(1,' ');
while (li.nextok())
{
const IdxTy sz=li.size();
if (sz<1) continue;
const StrTy cmd=li.word(0);
if (cmd=="") continue;
if (cmd=="about"){ about();  continue; } 
CommandInterpretterParam  cip(li);

if (cmd=="loadragged") {
 	const IdxTy start=atoi(cip.wif(2).c_str()); 
	const IdxTy first=atoi(cip.wif(3).c_str()); 
	const IdxTy flags=atoi(cip.wif(4).c_str()); 
Ragged r; r.load(cip.p1); x.load(r,start,first,flags); }
if (cmd=="load") {x.load(cip.p1,atoi(cip.p2.c_str())); }
if (cmd=="save") {x.save(cip.p1,cip.p2); }
if (cmd=="quit") break;
// NB this does not work in gneral when errors are disabled
//if (cmd=="dump") { MM_ERR(x.dump()) }
if (cmd=="dump") { auto wtf=x.dump();  MM_ERR(wtf) }
//else if (cmd=="load") { x.load(li.words(),1); }
//else if (cmd=="clear") { x.clear(); }

} // nextok

//if (!x.done()) x.command_mode();
return 0;
}

#endif // main

#endif // MJM_SWARNALATOR_H__ 
